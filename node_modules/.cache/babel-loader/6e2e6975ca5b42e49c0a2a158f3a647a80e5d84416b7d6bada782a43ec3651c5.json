{"ast":null,"code":"import { Point, Path, Polyline } from '../../g/index.mjs';\nimport { assign, isPlainObject, pick, isObject, isPercentage, breakText } from '../../util/util.mjs';\nimport { isCalcAttribute, evalCalcAttribute } from './calc.mjs';\nimport props from './props.mjs';\nimport $ from 'jquery';\nimport V from '../../V/index.mjs';\nfunction setWrapper(attrName, dimension) {\n  return function (value, refBBox) {\n    var isValuePercentage = isPercentage(value);\n    value = parseFloat(value);\n    if (isValuePercentage) {\n      value /= 100;\n    }\n    var attrs = {};\n    if (isFinite(value)) {\n      var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n      attrs[attrName] = attrValue;\n    }\n    return attrs;\n  };\n}\nfunction positionWrapper(axis, dimension, origin) {\n  return function (value, refBBox) {\n    var valuePercentage = isPercentage(value);\n    value = parseFloat(value);\n    if (valuePercentage) {\n      value /= 100;\n    }\n    var delta;\n    if (isFinite(value)) {\n      var refOrigin = refBBox[origin]();\n      if (valuePercentage || value > 0 && value < 1) {\n        delta = refOrigin[axis] + refBBox[dimension] * value;\n      } else {\n        delta = refOrigin[axis] + value;\n      }\n    }\n    var point = Point();\n    point[axis] = delta || 0;\n    return point;\n  };\n}\nfunction offsetWrapper(axis, dimension, corner) {\n  return function (value, nodeBBox) {\n    var delta;\n    if (value === 'middle') {\n      delta = nodeBBox[dimension] / 2;\n    } else if (value === corner) {\n      delta = nodeBBox[dimension];\n    } else if (isFinite(value)) {\n      // TODO: or not to do a breaking change?\n      delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;\n    } else if (isPercentage(value)) {\n      delta = nodeBBox[dimension] * parseFloat(value) / 100;\n    } else {\n      delta = 0;\n    }\n    var point = Point();\n    point[axis] = -(nodeBBox[axis] + delta);\n    return point;\n  };\n}\nfunction shapeWrapper(shapeConstructor, opt) {\n  var cacheName = 'joint-shape';\n  var resetOffset = opt && opt.resetOffset;\n  return function (value, refBBox, node) {\n    var $node = $(node);\n    var cache = $node.data(cacheName);\n    if (!cache || cache.value !== value) {\n      // only recalculate if value has changed\n      var cachedShape = shapeConstructor(value);\n      cache = {\n        value: value,\n        shape: cachedShape,\n        shapeBBox: cachedShape.bbox()\n      };\n      $node.data(cacheName, cache);\n    }\n    var shape = cache.shape.clone();\n    var shapeBBox = cache.shapeBBox.clone();\n    var shapeOrigin = shapeBBox.origin();\n    var refOrigin = refBBox.origin();\n    shapeBBox.x = refOrigin.x;\n    shapeBBox.y = refOrigin.y;\n    var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n    // `maxRectScaleToFit` can give Infinity if width or height is 0\n    var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n    var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n    shape.scale(sx, sy, shapeOrigin);\n    if (resetOffset) {\n      shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n    }\n    return shape;\n  };\n}\n\n// `d` attribute for SVGPaths\nfunction dWrapper(opt) {\n  function pathConstructor(value) {\n    return new Path(V.normalizePathData(value));\n  }\n  var shape = shapeWrapper(pathConstructor, opt);\n  return function (value, refBBox, node) {\n    var path = shape(value, refBBox, node);\n    return {\n      d: path.serialize()\n    };\n  };\n}\n\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(opt) {\n  var shape = shapeWrapper(Polyline, opt);\n  return function (value, refBBox, node) {\n    var polyline = shape(value, refBBox, node);\n    return {\n      points: polyline.serialize()\n    };\n  };\n}\nfunction atConnectionWrapper(method, opt) {\n  var zeroVector = new Point(1, 0);\n  return function (value) {\n    var p, angle;\n    var tangent = this[method](value);\n    if (tangent) {\n      angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n      p = tangent.start;\n    } else {\n      p = this.path.start;\n      angle = 0;\n    }\n    if (angle === 0) return {\n      transform: 'translate(' + p.x + ',' + p.y + ')'\n    };\n    return {\n      transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')'\n    };\n  };\n}\nfunction setIfChangedWrapper(attribute) {\n  return function setIfChanged(value, _, node) {\n    const vel = V(node);\n    if (vel.attr(attribute) === value) return;\n    vel.attr(attribute, value);\n  };\n}\nfunction isTextInUse(_value, _node, attrs) {\n  return attrs.text !== undefined;\n}\nfunction isLinkView() {\n  return this.model.isLink();\n}\nfunction contextMarker(context) {\n  var marker = {};\n  // Stroke\n  // The context 'fill' is disregared here. The usual case is to use the marker with a connection\n  // (for which 'fill' attribute is set to 'none').\n  var stroke = context.stroke;\n  if (typeof stroke === 'string') {\n    marker['stroke'] = stroke;\n    marker['fill'] = stroke;\n  }\n  // Opacity\n  // Again the context 'fill-opacity' is ignored.\n  var strokeOpacity = context.strokeOpacity;\n  if (strokeOpacity === undefined) strokeOpacity = context['stroke-opacity'];\n  if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n  if (strokeOpacity !== undefined) {\n    marker['stroke-opacity'] = strokeOpacity;\n    marker['fill-opacity'] = strokeOpacity;\n  }\n  return marker;\n}\nfunction setPaintURL(def) {\n  const {\n    paper\n  } = this;\n  const url = def.type === 'pattern' ? paper.definePattern(def) : paper.defineGradient(def);\n  return `url(#${url})`;\n}\nconst attributesNS = {\n  xlinkShow: {\n    set: 'xlink:show'\n  },\n  xlinkRole: {\n    set: 'xlink:role'\n  },\n  xlinkType: {\n    set: 'xlink:type'\n  },\n  xlinkArcrole: {\n    set: 'xlink:arcrole'\n  },\n  xlinkTitle: {\n    set: 'xlink:title'\n  },\n  xlinkActuate: {\n    set: 'xlink:actuate'\n  },\n  xmlSpace: {\n    set: 'xml:space'\n  },\n  xmlBase: {\n    set: 'xml:base'\n  },\n  xmlLang: {\n    set: 'xml:lang'\n  },\n  preserveAspectRatio: {\n    set: 'preserveAspectRatio'\n  },\n  requiredExtension: {\n    set: 'requiredExtension'\n  },\n  requiredFeatures: {\n    set: 'requiredFeatures'\n  },\n  systemLanguage: {\n    set: 'systemLanguage'\n  },\n  externalResourcesRequired: {\n    set: 'externalResourceRequired'\n  },\n  href: {\n    set: setIfChangedWrapper('href')\n  },\n  xlinkHref: {\n    set: setIfChangedWrapper('xlink:href')\n  },\n  filter: {\n    qualify: isPlainObject,\n    set: function (filter) {\n      return 'url(#' + this.paper.defineFilter(filter) + ')';\n    }\n  },\n  fill: {\n    qualify: isPlainObject,\n    set: setPaintURL\n  },\n  stroke: {\n    qualify: isPlainObject,\n    set: setPaintURL\n  },\n  sourceMarker: {\n    qualify: isPlainObject,\n    set: function (marker, refBBox, node, attrs) {\n      marker = assign(contextMarker(attrs), marker);\n      return {\n        'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')'\n      };\n    }\n  },\n  targetMarker: {\n    qualify: isPlainObject,\n    set: function (marker, refBBox, node, attrs) {\n      marker = assign(contextMarker(attrs), {\n        'transform': 'rotate(180)'\n      }, marker);\n      return {\n        'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')'\n      };\n    }\n  },\n  vertexMarker: {\n    qualify: isPlainObject,\n    set: function (marker, refBBox, node, attrs) {\n      marker = assign(contextMarker(attrs), marker);\n      return {\n        'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')'\n      };\n    }\n  },\n  text: {\n    qualify: function (_text, _node, attrs) {\n      return !attrs.textWrap || !isPlainObject(attrs.textWrap);\n    },\n    set: function (text, refBBox, node, attrs) {\n      var $node = $(node);\n      var cacheName = 'joint-text';\n      var cache = $node.data(cacheName);\n      var textAttrs = pick(attrs, 'lineHeight', 'annotations', 'textPath', 'x', 'textVerticalAnchor', 'eol', 'displayEmpty');\n      // eval `x` if using calc()\n      const {\n        x\n      } = textAttrs;\n      if (isCalcAttribute(x)) {\n        textAttrs.x = evalCalcAttribute(x, refBBox);\n      }\n      let fontSizeAttr = attrs['font-size'] || attrs['fontSize'];\n      if (isCalcAttribute(fontSizeAttr)) {\n        fontSizeAttr = evalCalcAttribute(fontSizeAttr, refBBox);\n      }\n      var fontSize = textAttrs.fontSize = fontSizeAttr;\n      var textHash = JSON.stringify([text, textAttrs]);\n      // Update the text only if there was a change in the string\n      // or any of its attributes.\n      if (cache === undefined || cache !== textHash) {\n        // Chrome bug:\n        // Tspans positions defined as `em` are not updated\n        // when container `font-size` change.\n        if (fontSize) node.setAttribute('font-size', fontSize);\n        // Text Along Path Selector\n        var textPath = textAttrs.textPath;\n        if (isObject(textPath)) {\n          var pathSelector = textPath.selector;\n          if (typeof pathSelector === 'string') {\n            var pathNode = this.findBySelector(pathSelector)[0];\n            if (pathNode instanceof SVGPathElement) {\n              textAttrs.textPath = assign({\n                'xlink:href': '#' + pathNode.id\n              }, textPath);\n            }\n          }\n        }\n        V(node).text('' + text, textAttrs);\n        $node.data(cacheName, textHash);\n      }\n    }\n  },\n  textWrap: {\n    qualify: isPlainObject,\n    set: function (value, refBBox, node, attrs) {\n      var size = {};\n      // option `width`\n      var width = value.width || 0;\n      if (isPercentage(width)) {\n        size.width = refBBox.width * parseFloat(width) / 100;\n      } else if (isCalcAttribute(width)) {\n        size.width = Number(evalCalcAttribute(width, refBBox));\n      } else {\n        if (value.width === null) {\n          // breakText() requires width to be specified.\n          size.width = Infinity;\n        } else if (width <= 0) {\n          size.width = refBBox.width + width;\n        } else {\n          size.width = width;\n        }\n      }\n      // option `height`\n      var height = value.height || 0;\n      if (isPercentage(height)) {\n        size.height = refBBox.height * parseFloat(height) / 100;\n      } else if (isCalcAttribute(height)) {\n        size.height = Number(evalCalcAttribute(height, refBBox));\n      } else {\n        if (value.height === null) {\n          // if height is not specified breakText() does not\n          // restrict the height of the text.\n        } else if (height <= 0) {\n          size.height = refBBox.height + height;\n        } else {\n          size.height = height;\n        }\n      }\n      // option `text`\n      var wrappedText;\n      var text = value.text;\n      if (text === undefined) text = attrs.text;\n      if (text !== undefined) {\n        const breakTextFn = value.breakText || breakText;\n        const fontSizeAttr = attrs['font-size'] || attrs.fontSize;\n        wrappedText = breakTextFn('' + text, size, {\n          'font-weight': attrs['font-weight'] || attrs.fontWeight,\n          'font-size': isCalcAttribute(fontSizeAttr) ? evalCalcAttribute(fontSizeAttr, refBBox) : fontSizeAttr,\n          'font-family': attrs['font-family'] || attrs.fontFamily,\n          'lineHeight': attrs.lineHeight,\n          'letter-spacing': 'letter-spacing' in attrs ? attrs['letter-spacing'] : attrs.letterSpacing\n        }, {\n          // Provide an existing SVG Document here\n          // instead of creating a temporary one over again.\n          svgDocument: this.paper.svg,\n          ellipsis: value.ellipsis,\n          hyphen: value.hyphen,\n          maxLineCount: value.maxLineCount,\n          preserveSpaces: value.preserveSpaces\n        });\n      } else {\n        wrappedText = '';\n      }\n      attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n    }\n  },\n  title: {\n    qualify: function (title, node) {\n      // HTMLElement title is specified via an attribute (i.e. not an element)\n      return node instanceof SVGElement;\n    },\n    set: function (title, refBBox, node) {\n      var $node = $(node);\n      var cacheName = 'joint-title';\n      var cache = $node.data(cacheName);\n      if (cache === undefined || cache !== title) {\n        $node.data(cacheName, title);\n        if (node.tagName === 'title') {\n          // The target node is a <title> element.\n          node.textContent = title;\n          return;\n        }\n        // Generally <title> element should be the first child element of its parent.\n        var firstChild = node.firstElementChild;\n        if (firstChild && firstChild.tagName === 'title') {\n          // Update an existing title\n          firstChild.textContent = title;\n        } else {\n          // Create a new title\n          var titleNode = document.createElementNS(node.namespaceURI, 'title');\n          titleNode.textContent = title;\n          node.insertBefore(titleNode, firstChild);\n        }\n      }\n    }\n  },\n  lineHeight: {\n    qualify: isTextInUse\n  },\n  textVerticalAnchor: {\n    qualify: isTextInUse\n  },\n  textPath: {\n    qualify: isTextInUse\n  },\n  annotations: {\n    qualify: isTextInUse\n  },\n  eol: {\n    qualify: isTextInUse\n  },\n  displayEmpty: {\n    qualify: isTextInUse\n  },\n  // `port` attribute contains the `id` of the port that the underlying magnet represents.\n  port: {\n    set: function (port) {\n      return port === null || port.id === undefined ? port : port.id;\n    }\n  },\n  // `style` attribute is special in the sense that it sets the CSS style of the subelement.\n  style: {\n    qualify: isPlainObject,\n    set: function (styles, refBBox, node) {\n      $(node).css(styles);\n    }\n  },\n  html: {\n    set: function (html, refBBox, node) {\n      $(node).html(html + '');\n    }\n  },\n  // Properties setter (set various properties on the node)\n  props,\n  ref: {\n    // We do not set `ref` attribute directly on an element.\n    // The attribute itself does not qualify for relative positioning.\n  },\n  // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n  // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n  // otherwise, `refX` is the left coordinate of the bounding box\n\n  refX: {\n    position: positionWrapper('x', 'width', 'origin')\n  },\n  refY: {\n    position: positionWrapper('y', 'height', 'origin')\n  },\n  // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n  // coordinate of the reference element.\n\n  refDx: {\n    position: positionWrapper('x', 'width', 'corner')\n  },\n  refDy: {\n    position: positionWrapper('y', 'height', 'corner')\n  },\n  // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n  // the reference element size\n  // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n  // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n  refWidth: {\n    set: setWrapper('width', 'width')\n  },\n  refHeight: {\n    set: setWrapper('height', 'height')\n  },\n  refRx: {\n    set: setWrapper('rx', 'width')\n  },\n  refRy: {\n    set: setWrapper('ry', 'height')\n  },\n  refRInscribed: {\n    set: function (attrName) {\n      var widthFn = setWrapper(attrName, 'width');\n      var heightFn = setWrapper(attrName, 'height');\n      return function (value, refBBox) {\n        var fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n        return fn(value, refBBox);\n      };\n    }('r')\n  },\n  refRCircumscribed: {\n    set: function (value, refBBox) {\n      var isValuePercentage = isPercentage(value);\n      value = parseFloat(value);\n      if (isValuePercentage) {\n        value /= 100;\n      }\n      var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n      var rValue;\n      if (isFinite(value)) {\n        if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;else rValue = Math.max(value + diagonalLength, 0);\n      }\n      return {\n        r: rValue\n      };\n    }\n  },\n  refCx: {\n    set: setWrapper('cx', 'width')\n  },\n  refCy: {\n    set: setWrapper('cy', 'height')\n  },\n  // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\n  // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n\n  xAlignment: {\n    offset: offsetWrapper('x', 'width', 'right')\n  },\n  // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\n  // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n\n  yAlignment: {\n    offset: offsetWrapper('y', 'height', 'bottom')\n  },\n  resetOffset: {\n    offset: function (val, nodeBBox) {\n      return val ? {\n        x: -nodeBBox.x,\n        y: -nodeBBox.y\n      } : {\n        x: 0,\n        y: 0\n      };\n    }\n  },\n  refDResetOffset: {\n    set: dWrapper({\n      resetOffset: true\n    })\n  },\n  refDKeepOffset: {\n    set: dWrapper({\n      resetOffset: false\n    })\n  },\n  refPointsResetOffset: {\n    set: pointsWrapper({\n      resetOffset: true\n    })\n  },\n  refPointsKeepOffset: {\n    set: pointsWrapper({\n      resetOffset: false\n    })\n  },\n  // LinkView Attributes\n\n  connection: {\n    qualify: isLinkView,\n    set: function ({\n      stubs = 0\n    }) {\n      let d;\n      if (isFinite(stubs) && stubs !== 0) {\n        let offset;\n        if (stubs < 0) {\n          offset = (this.getConnectionLength() + stubs) / 2;\n        } else {\n          offset = stubs;\n        }\n        const path = this.getConnection();\n        const segmentSubdivisions = this.getConnectionSubdivisions();\n        const sourceParts = path.divideAtLength(offset, {\n          segmentSubdivisions\n        });\n        const targetParts = path.divideAtLength(-offset, {\n          segmentSubdivisions\n        });\n        if (sourceParts && targetParts) {\n          d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n        }\n      }\n      return {\n        d: d || this.getSerializedConnection()\n      };\n    }\n  },\n  atConnectionLengthKeepGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtLength', {\n      rotate: true\n    })\n  },\n  atConnectionLengthIgnoreGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtLength', {\n      rotate: false\n    })\n  },\n  atConnectionRatioKeepGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtRatio', {\n      rotate: true\n    })\n  },\n  atConnectionRatioIgnoreGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtRatio', {\n      rotate: false\n    })\n  }\n};\nattributesNS['xlink:href'] = attributesNS.xlinkHref;\n\n// Support `calc()` with the following SVG attributes\n['transform',\n// g\n'd',\n// path\n'points',\n// polyline / polygon\n'cx', 'cy',\n// circle / ellipse\n'x1', 'x2', 'y1', 'y2',\n// line\n'x', 'y',\n// rect / text / image\n'dx', 'dy' // text\n].forEach(attribute => {\n  attributesNS[attribute] = {\n    qualify: isCalcAttribute,\n    set: function setCalcAttribute(value, refBBox) {\n      return {\n        [attribute]: evalCalcAttribute(value, refBBox)\n      };\n    }\n  };\n});\n\n// Prevent \"A negative value is not valid\" error.\n['width', 'height',\n// rect / image\n'r',\n// circle\n'rx', 'ry',\n// rect / ellipse\n'font-size',\n// text\n'stroke-width' // elements\n].forEach(attribute => {\n  attributesNS[attribute] = {\n    qualify: isCalcAttribute,\n    set: function setCalcAttribute(value, refBBox) {\n      return {\n        [attribute]: Math.max(0, evalCalcAttribute(value, refBBox))\n      };\n    }\n  };\n});\n\n// Aliases\nattributesNS.refR = attributesNS.refRInscribed;\nattributesNS.refD = attributesNS.refDResetOffset;\nattributesNS.refPoints = attributesNS.refPointsResetOffset;\nattributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;\nattributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient;\nattributesNS.fontSize = attributesNS['font-size'];\nattributesNS.strokeWidth = attributesNS['stroke-width'];\n\n// This allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nattributesNS.refX2 = attributesNS.refX;\nattributesNS.refY2 = attributesNS.refY;\nattributesNS.refWidth2 = attributesNS.refWidth;\nattributesNS.refHeight2 = attributesNS.refHeight;\n\n// Aliases for backwards compatibility\nattributesNS['ref-x'] = attributesNS.refX;\nattributesNS['ref-y'] = attributesNS.refY;\nattributesNS['ref-dy'] = attributesNS.refDy;\nattributesNS['ref-dx'] = attributesNS.refDx;\nattributesNS['ref-width'] = attributesNS.refWidth;\nattributesNS['ref-height'] = attributesNS.refHeight;\nattributesNS['x-alignment'] = attributesNS.xAlignment;\nattributesNS['y-alignment'] = attributesNS.yAlignment;\nexport const attributes = attributesNS;","map":{"version":3,"names":["Point","Path","Polyline","assign","isPlainObject","pick","isObject","isPercentage","breakText","isCalcAttribute","evalCalcAttribute","props","$","V","setWrapper","attrName","dimension","value","refBBox","isValuePercentage","parseFloat","attrs","isFinite","attrValue","Math","max","positionWrapper","axis","origin","valuePercentage","delta","refOrigin","point","offsetWrapper","corner","nodeBBox","shapeWrapper","shapeConstructor","opt","cacheName","resetOffset","node","$node","cache","data","cachedShape","shape","shapeBBox","bbox","clone","shapeOrigin","x","y","fitScale","maxRectScaleToFit","sx","width","sy","height","scale","translate","dWrapper","pathConstructor","normalizePathData","path","d","serialize","pointsWrapper","polyline","points","atConnectionWrapper","method","zeroVector","p","angle","tangent","rotate","vector","vectorAngle","start","transform","setIfChangedWrapper","attribute","setIfChanged","_","vel","attr","isTextInUse","_value","_node","text","undefined","isLinkView","model","isLink","contextMarker","context","marker","stroke","strokeOpacity","opacity","setPaintURL","def","paper","url","type","definePattern","defineGradient","attributesNS","xlinkShow","set","xlinkRole","xlinkType","xlinkArcrole","xlinkTitle","xlinkActuate","xmlSpace","xmlBase","xmlLang","preserveAspectRatio","requiredExtension","requiredFeatures","systemLanguage","externalResourcesRequired","href","xlinkHref","filter","qualify","defineFilter","fill","sourceMarker","defineMarker","targetMarker","vertexMarker","_text","textWrap","textAttrs","fontSizeAttr","fontSize","textHash","JSON","stringify","setAttribute","textPath","pathSelector","selector","pathNode","findBySelector","SVGPathElement","id","size","Number","Infinity","wrappedText","breakTextFn","fontWeight","fontFamily","lineHeight","letterSpacing","svgDocument","svg","ellipsis","hyphen","maxLineCount","preserveSpaces","call","title","SVGElement","tagName","textContent","firstChild","firstElementChild","titleNode","document","createElementNS","namespaceURI","insertBefore","textVerticalAnchor","annotations","eol","displayEmpty","port","style","styles","css","html","ref","refX","position","refY","refDx","refDy","refWidth","refHeight","refRx","refRy","refRInscribed","widthFn","heightFn","fn","refRCircumscribed","diagonalLength","sqrt","rValue","r","refCx","refCy","xAlignment","offset","yAlignment","val","refDResetOffset","refDKeepOffset","refPointsResetOffset","refPointsKeepOffset","connection","stubs","getConnectionLength","getConnection","segmentSubdivisions","getConnectionSubdivisions","sourceParts","divideAtLength","targetParts","getSerializedConnection","atConnectionLengthKeepGradient","atConnectionLengthIgnoreGradient","atConnectionRatioKeepGradient","atConnectionRatioIgnoreGradient","forEach","setCalcAttribute","refR","refD","refPoints","atConnectionLength","atConnectionRatio","strokeWidth","refX2","refY2","refWidth2","refHeight2","attributes"],"sources":["/Users/lijiaxin/Documents/workspace/hydsoft-oms-frontend/node_modules/jointjs/src/dia/attributes/index.mjs"],"sourcesContent":["import { Point, Path, Polyline } from '../../g/index.mjs';\nimport { assign, isPlainObject, pick, isObject, isPercentage, breakText } from '../../util/util.mjs';\nimport { isCalcAttribute, evalCalcAttribute } from './calc.mjs';\nimport props from './props.mjs';\nimport $ from 'jquery';\nimport V from '../../V/index.mjs';\n\nfunction setWrapper(attrName, dimension) {\n    return function(value, refBBox) {\n        var isValuePercentage = isPercentage(value);\n        value = parseFloat(value);\n        if (isValuePercentage) {\n            value /= 100;\n        }\n\n        var attrs = {};\n        if (isFinite(value)) {\n            var attrValue = (isValuePercentage || value >= 0 && value <= 1)\n                ? value * refBBox[dimension]\n                : Math.max(value + refBBox[dimension], 0);\n            attrs[attrName] = attrValue;\n        }\n\n        return attrs;\n    };\n}\n\nfunction positionWrapper(axis, dimension, origin) {\n    return function(value, refBBox) {\n        var valuePercentage = isPercentage(value);\n        value = parseFloat(value);\n        if (valuePercentage) {\n            value /= 100;\n        }\n\n        var delta;\n        if (isFinite(value)) {\n            var refOrigin = refBBox[origin]();\n            if (valuePercentage || value > 0 && value < 1) {\n                delta = refOrigin[axis] + refBBox[dimension] * value;\n            } else {\n                delta = refOrigin[axis] + value;\n            }\n        }\n\n        var point = Point();\n        point[axis] = delta || 0;\n        return point;\n    };\n}\n\nfunction offsetWrapper(axis, dimension, corner) {\n    return function(value, nodeBBox) {\n        var delta;\n        if (value === 'middle') {\n            delta = nodeBBox[dimension] / 2;\n        } else if (value === corner) {\n            delta = nodeBBox[dimension];\n        } else if (isFinite(value)) {\n            // TODO: or not to do a breaking change?\n            delta = (value > -1 && value < 1) ? (-nodeBBox[dimension] * value) : -value;\n        } else if (isPercentage(value)) {\n            delta = nodeBBox[dimension] * parseFloat(value) / 100;\n        } else {\n            delta = 0;\n        }\n\n        var point = Point();\n        point[axis] = -(nodeBBox[axis] + delta);\n        return point;\n    };\n}\n\nfunction shapeWrapper(shapeConstructor, opt) {\n    var cacheName = 'joint-shape';\n    var resetOffset = opt && opt.resetOffset;\n    return function(value, refBBox, node) {\n        var $node = $(node);\n        var cache = $node.data(cacheName);\n        if (!cache || cache.value !== value) {\n            // only recalculate if value has changed\n            var cachedShape = shapeConstructor(value);\n            cache = {\n                value: value,\n                shape: cachedShape,\n                shapeBBox: cachedShape.bbox()\n            };\n            $node.data(cacheName, cache);\n        }\n\n        var shape = cache.shape.clone();\n        var shapeBBox = cache.shapeBBox.clone();\n        var shapeOrigin = shapeBBox.origin();\n        var refOrigin = refBBox.origin();\n\n        shapeBBox.x = refOrigin.x;\n        shapeBBox.y = refOrigin.y;\n\n        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n        // `maxRectScaleToFit` can give Infinity if width or height is 0\n        var sx = (shapeBBox.width === 0 || refBBox.width === 0) ? 1 : fitScale.sx;\n        var sy = (shapeBBox.height === 0 || refBBox.height === 0) ? 1 : fitScale.sy;\n\n        shape.scale(sx, sy, shapeOrigin);\n        if (resetOffset) {\n            shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n        }\n\n        return shape;\n    };\n}\n\n// `d` attribute for SVGPaths\nfunction dWrapper(opt) {\n    function pathConstructor(value) {\n        return new Path(V.normalizePathData(value));\n    }\n\n    var shape = shapeWrapper(pathConstructor, opt);\n    return function(value, refBBox, node) {\n        var path = shape(value, refBBox, node);\n        return {\n            d: path.serialize()\n        };\n    };\n}\n\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(opt) {\n    var shape = shapeWrapper(Polyline, opt);\n    return function(value, refBBox, node) {\n        var polyline = shape(value, refBBox, node);\n        return {\n            points: polyline.serialize()\n        };\n    };\n}\n\nfunction atConnectionWrapper(method, opt) {\n    var zeroVector = new Point(1, 0);\n    return function(value) {\n        var p, angle;\n        var tangent = this[method](value);\n        if (tangent) {\n            angle = (opt.rotate) ? tangent.vector().vectorAngle(zeroVector) : 0;\n            p = tangent.start;\n        } else {\n            p = this.path.start;\n            angle = 0;\n        }\n        if (angle === 0) return { transform: 'translate(' + p.x + ',' + p.y + ')' };\n        return { transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')' };\n    };\n}\n\nfunction setIfChangedWrapper(attribute) {\n    return function setIfChanged(value, _, node) {\n        const vel = V(node);\n        if (vel.attr(attribute) === value) return;\n        vel.attr(attribute, value);\n    };\n}\n\nfunction isTextInUse(_value, _node, attrs) {\n    return (attrs.text !== undefined);\n}\n\nfunction isLinkView() {\n    return this.model.isLink();\n}\n\nfunction contextMarker(context) {\n    var marker = {};\n    // Stroke\n    // The context 'fill' is disregared here. The usual case is to use the marker with a connection\n    // (for which 'fill' attribute is set to 'none').\n    var stroke = context.stroke;\n    if (typeof stroke === 'string') {\n        marker['stroke'] = stroke;\n        marker['fill'] = stroke;\n    }\n    // Opacity\n    // Again the context 'fill-opacity' is ignored.\n    var strokeOpacity = context.strokeOpacity;\n    if (strokeOpacity === undefined) strokeOpacity = context['stroke-opacity'];\n    if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n    if (strokeOpacity !== undefined) {\n        marker['stroke-opacity'] = strokeOpacity;\n        marker['fill-opacity'] = strokeOpacity;\n    }\n    return marker;\n}\n\nfunction setPaintURL(def) {\n    const { paper } = this;\n    const url = (def.type === 'pattern')\n        ? paper.definePattern(def)\n        : paper.defineGradient(def);\n    return `url(#${url})`;\n}\n\nconst attributesNS = {\n\n    xlinkShow: {\n        set: 'xlink:show'\n    },\n\n    xlinkRole: {\n        set: 'xlink:role'\n    },\n\n    xlinkType: {\n        set: 'xlink:type'\n    },\n\n    xlinkArcrole: {\n        set: 'xlink:arcrole'\n    },\n\n    xlinkTitle: {\n        set: 'xlink:title'\n    },\n\n    xlinkActuate: {\n        set: 'xlink:actuate'\n    },\n\n    xmlSpace: {\n        set: 'xml:space'\n    },\n\n    xmlBase: {\n        set: 'xml:base'\n    },\n\n    xmlLang: {\n        set: 'xml:lang'\n    },\n\n    preserveAspectRatio: {\n        set: 'preserveAspectRatio'\n    },\n\n    requiredExtension: {\n        set: 'requiredExtension'\n    },\n\n    requiredFeatures: {\n        set: 'requiredFeatures'\n    },\n\n    systemLanguage: {\n        set: 'systemLanguage'\n    },\n\n    externalResourcesRequired: {\n        set: 'externalResourceRequired'\n    },\n\n    href: {\n        set: setIfChangedWrapper('href')\n    },\n\n    xlinkHref: {\n        set: setIfChangedWrapper('xlink:href')\n    },\n\n    filter: {\n        qualify: isPlainObject,\n        set: function(filter) {\n            return 'url(#' + this.paper.defineFilter(filter) + ')';\n        }\n    },\n\n    fill: {\n        qualify: isPlainObject,\n        set: setPaintURL\n    },\n\n    stroke: {\n        qualify: isPlainObject,\n        set: setPaintURL\n    },\n\n    sourceMarker: {\n        qualify: isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), marker);\n            return { 'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    targetMarker: {\n        qualify: isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), { 'transform': 'rotate(180)' }, marker);\n            return { 'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    vertexMarker: {\n        qualify: isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), marker);\n            return { 'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    text: {\n        qualify: function(_text, _node, attrs) {\n            return !attrs.textWrap || !isPlainObject(attrs.textWrap);\n        },\n        set: function(text, refBBox, node, attrs) {\n            var $node = $(node);\n            var cacheName = 'joint-text';\n            var cache = $node.data(cacheName);\n            var textAttrs = pick(attrs, 'lineHeight', 'annotations', 'textPath', 'x', 'textVerticalAnchor', 'eol', 'displayEmpty');\n            // eval `x` if using calc()\n            const { x } = textAttrs;\n            if (isCalcAttribute(x)) {\n                textAttrs.x = evalCalcAttribute(x, refBBox);\n            }\n\n            let fontSizeAttr = attrs['font-size'] || attrs['fontSize'];\n            if (isCalcAttribute(fontSizeAttr)) {\n                fontSizeAttr = evalCalcAttribute(fontSizeAttr, refBBox);\n            }\n            var fontSize = textAttrs.fontSize = fontSizeAttr;\n            var textHash = JSON.stringify([text, textAttrs]);\n            // Update the text only if there was a change in the string\n            // or any of its attributes.\n            if (cache === undefined || cache !== textHash) {\n                // Chrome bug:\n                // Tspans positions defined as `em` are not updated\n                // when container `font-size` change.\n                if (fontSize) node.setAttribute('font-size', fontSize);\n                // Text Along Path Selector\n                var textPath = textAttrs.textPath;\n                if (isObject(textPath)) {\n                    var pathSelector = textPath.selector;\n                    if (typeof pathSelector === 'string') {\n                        var pathNode = this.findBySelector(pathSelector)[0];\n                        if (pathNode instanceof SVGPathElement) {\n                            textAttrs.textPath = assign({ 'xlink:href': '#' + pathNode.id }, textPath);\n                        }\n                    }\n                }\n                V(node).text('' + text, textAttrs);\n                $node.data(cacheName, textHash);\n            }\n        }\n    },\n\n    textWrap: {\n        qualify: isPlainObject,\n        set: function(value, refBBox, node, attrs) {\n            var size = {};\n            // option `width`\n            var width = value.width || 0;\n            if (isPercentage(width)) {\n                size.width = refBBox.width * parseFloat(width) / 100;\n            } else if (isCalcAttribute(width)) {\n                size.width = Number(evalCalcAttribute(width, refBBox));\n            } else {\n                if (value.width === null) {\n                    // breakText() requires width to be specified.\n                    size.width = Infinity;\n                } else if (width <= 0) {\n                    size.width = refBBox.width + width;\n                } else {\n                    size.width = width;\n                }\n            }\n            // option `height`\n            var height = value.height || 0;\n            if (isPercentage(height)) {\n                size.height = refBBox.height * parseFloat(height) / 100;\n            } else if (isCalcAttribute(height)) {\n                size.height = Number(evalCalcAttribute(height, refBBox));\n            } else {\n                if (value.height === null) {\n                    // if height is not specified breakText() does not\n                    // restrict the height of the text.\n                } else if (height <= 0) {\n                    size.height = refBBox.height + height;\n                } else {\n                    size.height = height;\n                }\n            }\n            // option `text`\n            var wrappedText;\n            var text = value.text;\n            if (text === undefined) text = attrs.text;\n            if (text !== undefined) {\n                const breakTextFn = value.breakText || breakText;\n                const fontSizeAttr = attrs['font-size'] || attrs.fontSize;\n                wrappedText = breakTextFn('' + text, size, {\n                    'font-weight': attrs['font-weight'] || attrs.fontWeight,\n                    'font-size': isCalcAttribute(fontSizeAttr) ? evalCalcAttribute(fontSizeAttr, refBBox) : fontSizeAttr,\n                    'font-family': attrs['font-family'] || attrs.fontFamily,\n                    'lineHeight': attrs.lineHeight,\n                    'letter-spacing': 'letter-spacing' in attrs ? attrs['letter-spacing'] : attrs.letterSpacing\n                }, {\n                    // Provide an existing SVG Document here\n                    // instead of creating a temporary one over again.\n                    svgDocument: this.paper.svg,\n                    ellipsis: value.ellipsis,\n                    hyphen: value.hyphen,\n                    maxLineCount: value.maxLineCount,\n                    preserveSpaces: value.preserveSpaces\n                });\n            } else {\n                wrappedText = '';\n            }\n            attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n        }\n    },\n\n    title: {\n        qualify: function(title, node) {\n            // HTMLElement title is specified via an attribute (i.e. not an element)\n            return node instanceof SVGElement;\n        },\n        set: function(title, refBBox, node) {\n            var $node = $(node);\n            var cacheName = 'joint-title';\n            var cache = $node.data(cacheName);\n            if (cache === undefined || cache !== title) {\n                $node.data(cacheName, title);\n                if (node.tagName === 'title') {\n                    // The target node is a <title> element.\n                    node.textContent = title;\n                    return;\n                }\n                // Generally <title> element should be the first child element of its parent.\n                var firstChild = node.firstElementChild;\n                if (firstChild && firstChild.tagName === 'title') {\n                    // Update an existing title\n                    firstChild.textContent = title;\n                } else {\n                    // Create a new title\n                    var titleNode = document.createElementNS(node.namespaceURI, 'title');\n                    titleNode.textContent = title;\n                    node.insertBefore(titleNode, firstChild);\n                }\n            }\n        }\n    },\n\n    lineHeight: {\n        qualify: isTextInUse\n    },\n\n    textVerticalAnchor: {\n        qualify: isTextInUse\n    },\n\n    textPath: {\n        qualify: isTextInUse\n    },\n\n    annotations: {\n        qualify: isTextInUse\n    },\n\n    eol: {\n        qualify: isTextInUse\n    },\n\n    displayEmpty: {\n        qualify: isTextInUse\n    },\n\n    // `port` attribute contains the `id` of the port that the underlying magnet represents.\n    port: {\n        set: function(port) {\n            return (port === null || port.id === undefined) ? port : port.id;\n        }\n    },\n\n    // `style` attribute is special in the sense that it sets the CSS style of the subelement.\n    style: {\n        qualify: isPlainObject,\n        set: function(styles, refBBox, node) {\n            $(node).css(styles);\n        }\n    },\n\n    html: {\n        set: function(html, refBBox, node) {\n            $(node).html(html + '');\n        }\n    },\n\n    // Properties setter (set various properties on the node)\n    props,\n\n    ref: {\n        // We do not set `ref` attribute directly on an element.\n        // The attribute itself does not qualify for relative positioning.\n    },\n\n    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n    // otherwise, `refX` is the left coordinate of the bounding box\n\n    refX: {\n        position: positionWrapper('x', 'width', 'origin')\n    },\n\n    refY: {\n        position: positionWrapper('y', 'height', 'origin')\n    },\n\n    // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n    // coordinate of the reference element.\n\n    refDx: {\n        position: positionWrapper('x', 'width', 'corner')\n    },\n\n    refDy: {\n        position: positionWrapper('y', 'height', 'corner')\n    },\n\n    // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n    // the reference element size\n    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n    refWidth: {\n        set: setWrapper('width', 'width')\n    },\n\n    refHeight: {\n        set: setWrapper('height', 'height')\n    },\n\n    refRx: {\n        set: setWrapper('rx', 'width')\n    },\n\n    refRy: {\n        set: setWrapper('ry', 'height')\n    },\n\n    refRInscribed: {\n        set: (function(attrName) {\n            var widthFn = setWrapper(attrName, 'width');\n            var heightFn = setWrapper(attrName, 'height');\n            return function(value, refBBox) {\n                var fn = (refBBox.height > refBBox.width) ? widthFn : heightFn;\n                return fn(value, refBBox);\n            };\n        })('r')\n    },\n\n    refRCircumscribed: {\n        set: function(value, refBBox) {\n            var isValuePercentage = isPercentage(value);\n            value = parseFloat(value);\n            if (isValuePercentage) {\n                value /= 100;\n            }\n\n            var diagonalLength = Math.sqrt((refBBox.height * refBBox.height) + (refBBox.width * refBBox.width));\n\n            var rValue;\n            if (isFinite(value)) {\n                if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;\n                else rValue = Math.max(value + diagonalLength, 0);\n            }\n\n            return { r: rValue };\n        }\n    },\n\n    refCx: {\n        set: setWrapper('cx', 'width')\n    },\n\n    refCy: {\n        set: setWrapper('cy', 'height')\n    },\n\n    // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\n    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n\n    xAlignment: {\n        offset: offsetWrapper('x', 'width', 'right')\n    },\n\n    // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\n    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n\n    yAlignment: {\n        offset: offsetWrapper('y', 'height', 'bottom')\n    },\n\n    resetOffset: {\n        offset: function(val, nodeBBox) {\n            return (val)\n                ? { x: -nodeBBox.x, y: -nodeBBox.y }\n                : { x: 0, y: 0 };\n        }\n\n    },\n\n    refDResetOffset: {\n        set: dWrapper({ resetOffset: true })\n    },\n\n    refDKeepOffset: {\n        set: dWrapper({ resetOffset: false })\n    },\n\n    refPointsResetOffset: {\n        set: pointsWrapper({ resetOffset: true })\n    },\n\n    refPointsKeepOffset: {\n        set: pointsWrapper({ resetOffset: false })\n    },\n\n    // LinkView Attributes\n\n    connection: {\n        qualify: isLinkView,\n        set: function({ stubs = 0 }) {\n            let d;\n            if (isFinite(stubs) && stubs !== 0) {\n                let offset;\n                if (stubs < 0) {\n                    offset = (this.getConnectionLength() + stubs) / 2;\n                } else {\n                    offset = stubs;\n                }\n                const path = this.getConnection();\n                const segmentSubdivisions = this.getConnectionSubdivisions();\n                const sourceParts = path.divideAtLength(offset, { segmentSubdivisions });\n                const targetParts = path.divideAtLength(-offset, { segmentSubdivisions });\n                if (sourceParts && targetParts) {\n                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n                }\n            }\n\n            return { d: d || this.getSerializedConnection() };\n        }\n    },\n\n    atConnectionLengthKeepGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtLength', { rotate: true })\n    },\n\n    atConnectionLengthIgnoreGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtLength', { rotate: false })\n    },\n\n    atConnectionRatioKeepGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: true })\n    },\n\n    atConnectionRatioIgnoreGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: false })\n    }\n};\n\nattributesNS['xlink:href'] = attributesNS.xlinkHref;\n\n// Support `calc()` with the following SVG attributes\n[\n    'transform', // g\n    'd', // path\n    'points', // polyline / polygon\n    'cx', 'cy', // circle / ellipse\n    'x1', 'x2', 'y1', 'y2', // line\n    'x', 'y', // rect / text / image\n    'dx', 'dy' // text\n].forEach(attribute => {\n    attributesNS[attribute] = {\n        qualify: isCalcAttribute,\n        set: function setCalcAttribute(value, refBBox) {\n            return { [attribute]: evalCalcAttribute(value, refBBox) };\n        }\n    };\n});\n\n// Prevent \"A negative value is not valid\" error.\n[\n    'width', 'height', // rect / image\n    'r', // circle\n    'rx', 'ry', // rect / ellipse\n    'font-size', // text\n    'stroke-width' // elements\n].forEach(attribute => {\n    attributesNS[attribute] = {\n        qualify: isCalcAttribute,\n        set: function setCalcAttribute(value, refBBox) {\n            return { [attribute]: Math.max(0, evalCalcAttribute(value, refBBox)) };\n        }\n    };\n});\n\n// Aliases\nattributesNS.refR = attributesNS.refRInscribed;\nattributesNS.refD = attributesNS.refDResetOffset;\nattributesNS.refPoints = attributesNS.refPointsResetOffset;\nattributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;\nattributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient;\nattributesNS.fontSize = attributesNS['font-size'];\nattributesNS.strokeWidth = attributesNS['stroke-width'];\n\n// This allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nattributesNS.refX2 = attributesNS.refX;\nattributesNS.refY2 = attributesNS.refY;\nattributesNS.refWidth2 = attributesNS.refWidth;\nattributesNS.refHeight2 = attributesNS.refHeight;\n\n// Aliases for backwards compatibility\nattributesNS['ref-x'] = attributesNS.refX;\nattributesNS['ref-y'] = attributesNS.refY;\nattributesNS['ref-dy'] = attributesNS.refDy;\nattributesNS['ref-dx'] = attributesNS.refDx;\nattributesNS['ref-width'] = attributesNS.refWidth;\nattributesNS['ref-height'] = attributesNS.refHeight;\nattributesNS['x-alignment'] = attributesNS.xAlignment;\nattributesNS['y-alignment'] = attributesNS.yAlignment;\n\nexport const attributes = attributesNS;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}