{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport { config } from '../config/index.mjs';\nimport { View } from '../mvc/index.mjs';\nimport { assign, guid, omit, parseDOMJSON, isFunction, isObject, isPlainObject, isBoolean, isEmpty, isString, toKebabCase, result, sortedIndex, merge, uniq } from '../util/index.mjs';\nimport { Point, Rect } from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport $ from 'jquery';\nimport { HighlighterView } from './HighlighterView.mjs';\nconst HighlightingTypes = {\n  DEFAULT: 'default',\n  EMBEDDING: 'embedding',\n  CONNECTING: 'connecting',\n  MAGNET_AVAILABILITY: 'magnetAvailability',\n  ELEMENT_AVAILABILITY: 'elementAvailability'\n};\nconst Flags = {\n  TOOLS: 'TOOLS'\n};\n\n// CellView base view and controller.\n// --------------------------------------------\n\n// This is the base view and controller for `ElementView` and `LinkView`.\nexport const CellView = View.extend({\n  tagName: 'g',\n  svgElement: true,\n  selector: 'root',\n  metrics: null,\n  className: function () {\n    var classNames = ['cell'];\n    var type = this.model.get('type');\n    if (type) {\n      type.toLowerCase().split('.').forEach(function (value, index, list) {\n        classNames.push('type-' + list.slice(0, index + 1).join('-'));\n      });\n    }\n    return classNames.join(' ');\n  },\n  _presentationAttributes: null,\n  _flags: null,\n  setFlags: function () {\n    var flags = {};\n    var attributes = {};\n    var shift = 0;\n    var i, n, label;\n    var presentationAttributes = result(this, 'presentationAttributes');\n    for (var attribute in presentationAttributes) {\n      if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n      var labels = presentationAttributes[attribute];\n      if (!Array.isArray(labels)) labels = [labels];\n      for (i = 0, n = labels.length; i < n; i++) {\n        label = labels[i];\n        var flag = flags[label];\n        if (!flag) {\n          flag = flags[label] = 1 << shift++;\n        }\n        attributes[attribute] |= flag;\n      }\n    }\n    var initFlag = result(this, 'initFlag');\n    if (!Array.isArray(initFlag)) initFlag = [initFlag];\n    for (i = 0, n = initFlag.length; i < n; i++) {\n      label = initFlag[i];\n      if (!flags[label]) flags[label] = 1 << shift++;\n    }\n\n    // 26 - 30 are reserved for paper flags\n    // 31+ overflows maximal number\n    if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n    this._flags = flags;\n    this._presentationAttributes = attributes;\n  },\n  hasFlag: function (flag, label) {\n    return flag & this.getFlag(label);\n  },\n  removeFlag: function (flag, label) {\n    return flag ^ flag & this.getFlag(label);\n  },\n  getFlag: function (label) {\n    var flags = this._flags;\n    if (!flags) return 0;\n    var flag = 0;\n    if (Array.isArray(label)) {\n      for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n    } else {\n      flag |= flags[label];\n    }\n    return flag;\n  },\n  attributes: function () {\n    var cell = this.model;\n    return {\n      'model-id': cell.id,\n      'data-type': cell.attributes.type\n    };\n  },\n  constructor: function (options) {\n    // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n    // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n    // still be associated to the same object among all those clients. This is necessary for real-time\n    // collaboration mechanism.\n    options.id = options.id || guid(this);\n    View.call(this, options);\n  },\n  initialize: function () {\n    this.setFlags();\n    View.prototype.initialize.apply(this, arguments);\n    this.cleanNodesCache();\n\n    // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\n    this.$el.data('view', this);\n    this.startListening();\n  },\n  startListening: function () {\n    this.listenTo(this.model, 'change', this.onAttributesChange);\n  },\n  onAttributesChange: function (model, opt) {\n    var flag = model.getChangeFlag(this._presentationAttributes);\n    if (opt.updateHandled || !flag) return;\n    if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n    // TODO: tool changes does not need to be sync\n    // Fix Segments tools\n    if (opt.tool) opt.async = false;\n    this.requestUpdate(flag, opt);\n  },\n  requestUpdate: function (flags, opt) {\n    const {\n      paper\n    } = this;\n    if (paper && flags > 0) {\n      paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n    }\n  },\n  parseDOMJSON: function (markup, root) {\n    var doc = parseDOMJSON(markup);\n    var selectors = doc.selectors;\n    var groups = doc.groupSelectors;\n    for (var group in groups) {\n      if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n      selectors[group] = groups[group];\n    }\n    if (root) {\n      var rootSelector = this.selector;\n      if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n      selectors[rootSelector] = root;\n    }\n    return {\n      fragment: doc.fragment,\n      selectors: selectors\n    };\n  },\n  // Return `true` if cell link is allowed to perform a certain UI `feature`.\n  // Example: `can('vertexMove')`, `can('labelMove')`.\n  can: function (feature) {\n    var interactive = isFunction(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;\n    return isObject(interactive) && interactive[feature] !== false || isBoolean(interactive) && interactive !== false;\n  },\n  findBySelector: function (selector, root, selectors) {\n    root || (root = this.el);\n    selectors || (selectors = this.selectors);\n\n    // These are either descendants of `this.$el` of `this.$el` itself.\n    // `.` is a special selector used to select the wrapping `<g>` element.\n    if (!selector || selector === '.') return [root];\n    if (selectors) {\n      var nodes = selectors[selector];\n      if (nodes) {\n        if (Array.isArray(nodes)) return nodes;\n        return [nodes];\n      }\n    }\n\n    // Maintaining backwards compatibility\n    // e.g. `circle:first` would fail with querySelector() call\n    if (config.useCSSSelectors) return $(root).find(selector).toArray();\n    return [];\n  },\n  notify: function (eventName) {\n    if (this.paper) {\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      // Trigger the event on both the element itself and also on the paper.\n      this.trigger.apply(this, [eventName].concat(args));\n\n      // Paper event handlers receive the view object as the first argument.\n      this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n    }\n  },\n  getBBox: function (opt) {\n    var bbox;\n    if (opt && opt.useModelGeometry) {\n      var model = this.model;\n      bbox = model.getBBox().bbox(model.angle());\n    } else {\n      bbox = this.getNodeBBox(this.el);\n    }\n    return this.paper.localToPaperRect(bbox);\n  },\n  getNodeBBox: function (magnet) {\n    const rect = this.getNodeBoundingRect(magnet);\n    const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n    const magnetMatrix = this.getNodeMatrix(magnet);\n    return V.transformRect(rect, transformMatrix.multiply(magnetMatrix));\n  },\n  getNodeRotateMatrix(node) {\n    if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n      // Rotate transformation is applied to all nodes when no rotatableGroup\n      // is present or to nodes inside the rotatableGroup only.\n      return this.getRootRotateMatrix();\n    }\n    // Nodes outside the rotatable group\n    return V.createSVGMatrix();\n  },\n  getNodeUnrotatedBBox: function (magnet) {\n    var rect = this.getNodeBoundingRect(magnet);\n    var magnetMatrix = this.getNodeMatrix(magnet);\n    var translateMatrix = this.getRootTranslateMatrix();\n    return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n  },\n  getRootTranslateMatrix: function () {\n    var model = this.model;\n    var position = model.position();\n    var mt = V.createSVGMatrix().translate(position.x, position.y);\n    return mt;\n  },\n  getRootRotateMatrix: function () {\n    var mr = V.createSVGMatrix();\n    var model = this.model;\n    var angle = model.angle();\n    if (angle) {\n      var bbox = model.getBBox();\n      var cx = bbox.width / 2;\n      var cy = bbox.height / 2;\n      mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n    }\n    return mr;\n  },\n  _notifyHighlight: function (eventName, el, opt = {}) {\n    const {\n      el: rootNode\n    } = this;\n    let node;\n    if (typeof el === 'string') {\n      [node = rootNode] = this.findBySelector(el);\n    } else {\n      [node = rootNode] = this.$(el);\n    }\n    // set partial flag if the highlighted element is not the entire view.\n    opt.partial = node !== rootNode;\n    // translate type flag into a type string\n    if (opt.type === undefined) {\n      let type;\n      switch (true) {\n        case opt.embedding:\n          type = HighlightingTypes.EMBEDDING;\n          break;\n        case opt.connecting:\n          type = HighlightingTypes.CONNECTING;\n          break;\n        case opt.magnetAvailability:\n          type = HighlightingTypes.MAGNET_AVAILABILITY;\n          break;\n        case opt.elementAvailability:\n          type = HighlightingTypes.ELEMENT_AVAILABILITY;\n          break;\n        default:\n          type = HighlightingTypes.DEFAULT;\n          break;\n      }\n      opt.type = type;\n    }\n    this.notify(eventName, node, opt);\n    return this;\n  },\n  highlight: function (el, opt) {\n    return this._notifyHighlight('cell:highlight', el, opt);\n  },\n  unhighlight: function (el, opt = {}) {\n    return this._notifyHighlight('cell:unhighlight', el, opt);\n  },\n  // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n  // an element found, return the root element of the cell view.\n  findMagnet: function (el) {\n    const root = this.el;\n    let magnet = this.$(el)[0];\n    if (!magnet) {\n      magnet = root;\n    }\n    do {\n      const magnetAttribute = magnet.getAttribute('magnet');\n      const isMagnetRoot = magnet === root;\n      if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n        return magnet;\n      }\n      if (isMagnetRoot) {\n        // If the overall cell has set `magnet === false`, then return `undefined` to\n        // announce there is no magnet found for this cell.\n        // This is especially useful to set on cells that have 'ports'. In this case,\n        // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n        return undefined;\n      }\n      magnet = magnet.parentNode;\n    } while (magnet);\n    return undefined;\n  },\n  findProxyNode: function (el, type) {\n    el || (el = this.el);\n    const nodeSelector = el.getAttribute(`${type}-selector`);\n    if (nodeSelector) {\n      const [proxyNode] = this.findBySelector(nodeSelector);\n      if (proxyNode) return proxyNode;\n    }\n    return el;\n  },\n  // Construct a unique selector for the `el` element within this view.\n  // `prevSelector` is being collected through the recursive call.\n  // No value for `prevSelector` is expected when using this method.\n  getSelector: function (el, prevSelector) {\n    var selector;\n    if (el === this.el) {\n      if (typeof prevSelector === 'string') selector = '> ' + prevSelector;\n      return selector;\n    }\n    if (el) {\n      var nthChild = V(el).index() + 1;\n      selector = el.tagName + ':nth-child(' + nthChild + ')';\n      if (prevSelector) {\n        selector += ' > ' + prevSelector;\n      }\n      selector = this.getSelector(el.parentNode, selector);\n    }\n    return selector;\n  },\n  addLinkFromMagnet: function (magnet, x, y) {\n    var paper = this.paper;\n    var graph = paper.model;\n    var link = paper.getDefaultLink(this, magnet);\n    link.set({\n      source: this.getLinkEnd(magnet, x, y, link, 'source'),\n      target: {\n        x: x,\n        y: y\n      }\n    }).addTo(graph, {\n      async: false,\n      ui: true\n    });\n    return link.findView(paper);\n  },\n  getLinkEnd: function (magnet, ...args) {\n    var model = this.model;\n    var id = model.id;\n    var port = this.findAttribute('port', magnet);\n    // Find a unique `selector` of the element under pointer that is a magnet.\n    var selector = magnet.getAttribute('joint-selector');\n    var end = {\n      id: id\n    };\n    if (selector != null) end.magnet = selector;\n    if (port != null) {\n      end.port = port;\n      if (!model.hasPort(port) && !selector) {\n        // port created via the `port` attribute (not API)\n        end.selector = this.getSelector(magnet);\n      }\n    } else if (selector == null && this.el !== magnet) {\n      end.selector = this.getSelector(magnet);\n    }\n    return this.customizeLinkEnd(end, magnet, ...args);\n  },\n  customizeLinkEnd: function (end, magnet, x, y, link, endType) {\n    const {\n      paper\n    } = this;\n    const {\n      connectionStrategy\n    } = paper.options;\n    if (typeof connectionStrategy === 'function') {\n      var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n      if (strategy) return strategy;\n    }\n    return end;\n  },\n  getMagnetFromLinkEnd: function (end) {\n    var root = this.el;\n    var port = end.port;\n    var selector = end.magnet;\n    var model = this.model;\n    var magnet;\n    if (port != null && model.isElement() && model.hasPort(port)) {\n      magnet = this.findPortNode(port, selector) || root;\n    } else {\n      if (!selector) selector = end.selector;\n      if (!selector && port != null) {\n        // link end has only `id` and `port` property referencing\n        // a port created via the `port` attribute (not API).\n        selector = '[port=\"' + port + '\"]';\n      }\n      magnet = this.findBySelector(selector, root, this.selectors)[0];\n    }\n    return this.findProxyNode(magnet, 'magnet');\n  },\n  dragLinkStart: function (evt, magnet, x, y) {\n    this.model.startBatch('add-link');\n    const linkView = this.addLinkFromMagnet(magnet, x, y);\n    // backwards compatibility events\n    linkView.notifyPointerdown(evt, x, y);\n    linkView.eventData(evt, linkView.startArrowheadMove('target', {\n      whenNotAllowed: 'remove'\n    }));\n    this.eventData(evt, {\n      linkView\n    });\n  },\n  dragLink: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var linkView = data.linkView;\n    if (linkView) {\n      linkView.pointermove(evt, x, y);\n    } else {\n      var paper = this.paper;\n      var magnetThreshold = paper.options.magnetThreshold;\n      var currentTarget = this.getEventTarget(evt);\n      var targetMagnet = data.targetMagnet;\n      if (magnetThreshold === 'onleave') {\n        // magnetThreshold when the pointer leaves the magnet\n        if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n      } else {\n        // magnetThreshold defined as a number of movements\n        if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n      }\n      this.dragLinkStart(evt, targetMagnet, x, y);\n    }\n  },\n  dragLinkEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var linkView = data.linkView;\n    if (!linkView) return;\n    linkView.pointerup(evt, x, y);\n    this.model.stopBatch('add-link');\n  },\n  getAttributeDefinition: function (attrName) {\n    return this.model.constructor.getAttributeDefinition(attrName);\n  },\n  setNodeAttributes: function (node, attrs) {\n    if (!isEmpty(attrs)) {\n      if (node instanceof SVGElement) {\n        V(node).attr(attrs);\n      } else {\n        $(node).attr(attrs);\n      }\n    }\n  },\n  processNodeAttributes: function (node, attrs) {\n    var attrName, attrVal, def, i, n;\n    var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n    var relatives = [];\n    // divide the attributes between normal and special\n    for (attrName in attrs) {\n      if (!attrs.hasOwnProperty(attrName)) continue;\n      attrVal = attrs[attrName];\n      def = this.getAttributeDefinition(attrName);\n      if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, attrs, this))) {\n        if (isString(def.set)) {\n          normalAttrs || (normalAttrs = {});\n          normalAttrs[def.set] = attrVal;\n        }\n        if (attrVal !== null) {\n          relatives.push(attrName, def);\n        }\n      } else {\n        normalAttrs || (normalAttrs = {});\n        normalAttrs[toKebabCase(attrName)] = attrVal;\n      }\n    }\n\n    // handle the rest of attributes via related method\n    // from the special attributes namespace.\n    for (i = 0, n = relatives.length; i < n; i += 2) {\n      attrName = relatives[i];\n      def = relatives[i + 1];\n      attrVal = attrs[attrName];\n      if (isFunction(def.set)) {\n        setAttrs || (setAttrs = {});\n        setAttrs[attrName] = attrVal;\n      }\n      if (isFunction(def.position)) {\n        positionAttrs || (positionAttrs = {});\n        positionAttrs[attrName] = attrVal;\n      }\n      if (isFunction(def.offset)) {\n        offsetAttrs || (offsetAttrs = {});\n        offsetAttrs[attrName] = attrVal;\n      }\n    }\n    return {\n      raw: attrs,\n      normal: normalAttrs,\n      set: setAttrs,\n      position: positionAttrs,\n      offset: offsetAttrs\n    };\n  },\n  updateRelativeAttributes: function (node, attrs, refBBox, opt) {\n    opt || (opt = {});\n    var attrName, attrVal, def;\n    var rawAttrs = attrs.raw || {};\n    var nodeAttrs = attrs.normal || {};\n    var setAttrs = attrs.set;\n    var positionAttrs = attrs.position;\n    var offsetAttrs = attrs.offset;\n    for (attrName in setAttrs) {\n      attrVal = setAttrs[attrName];\n      def = this.getAttributeDefinition(attrName);\n      // SET - set function should return attributes to be set on the node,\n      // which will affect the node dimensions based on the reference bounding\n      // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n      var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);\n      if (isObject(setResult)) {\n        assign(nodeAttrs, setResult);\n      } else if (setResult !== undefined) {\n        nodeAttrs[attrName] = setResult;\n      }\n    }\n    if (node instanceof HTMLElement) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.setNodeAttributes(node, nodeAttrs);\n      return;\n    }\n\n    // The final translation of the subelement.\n    var nodeTransform = nodeAttrs.transform;\n    var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n    var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n    if (nodeTransform) {\n      nodeAttrs = omit(nodeAttrs, 'transform');\n      nodeMatrix.e = nodeMatrix.f = 0;\n    }\n\n    // Calculate node scale determined by the scalable group\n    // only if later needed.\n    var sx, sy, translation;\n    if (positionAttrs || offsetAttrs) {\n      var nodeScale = this.getNodeScale(node, opt.scalableNode);\n      sx = nodeScale.sx;\n      sy = nodeScale.sy;\n    }\n    var positioned = false;\n    for (attrName in positionAttrs) {\n      attrVal = positionAttrs[attrName];\n      def = this.getAttributeDefinition(attrName);\n      // POSITION - position function should return a point from the\n      // reference bounding box. The default position of the node is x:0, y:0 of\n      // the reference bounding box or could be further specify by some\n      // SVG attributes e.g. `x`, `y`\n      translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);\n      if (translation) {\n        nodePosition.offset(Point(translation).scale(sx, sy));\n        positioned || (positioned = true);\n      }\n    }\n\n    // The node bounding box could depend on the `size` set from the previous loop.\n    // Here we know, that all the size attributes have been already set.\n    this.setNodeAttributes(node, nodeAttrs);\n    var offseted = false;\n    if (offsetAttrs) {\n      // Check if the node is visible\n      var nodeBoundingRect = this.getNodeBoundingRect(node);\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n        for (attrName in offsetAttrs) {\n          attrVal = offsetAttrs[attrName];\n          def = this.getAttributeDefinition(attrName);\n          // OFFSET - offset function should return a point from the element\n          // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n          // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n          translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs, this);\n          if (translation) {\n            nodePosition.offset(Point(translation).scale(sx, sy));\n            offseted || (offseted = true);\n          }\n        }\n      }\n    }\n\n    // Do not touch node's transform attribute if there is no transformation applied.\n    if (nodeTransform !== undefined || positioned || offseted) {\n      // Round the coordinates to 1 decimal point.\n      nodePosition.round(1);\n      nodeMatrix.e = nodePosition.x;\n      nodeMatrix.f = nodePosition.y;\n      node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n      // TODO: store nodeMatrix metrics?\n    }\n  },\n\n  getNodeScale: function (node, scalableNode) {\n    // Check if the node is a descendant of the scalable group.\n    var sx, sy;\n    if (scalableNode && scalableNode.contains(node)) {\n      var scale = scalableNode.scale();\n      sx = 1 / scale.sx;\n      sy = 1 / scale.sy;\n    } else {\n      sx = 1;\n      sy = 1;\n    }\n    return {\n      sx: sx,\n      sy: sy\n    };\n  },\n  cleanNodesCache: function () {\n    this.metrics = {};\n  },\n  nodeCache: function (magnet) {\n    var metrics = this.metrics;\n    // Don't use cache? It most likely a custom view with overridden update.\n    if (!metrics) return {};\n    var id = V.ensureId(magnet);\n    var value = metrics[id];\n    if (!value) value = metrics[id] = {};\n    return value;\n  },\n  getNodeData: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (!metrics.data) metrics.data = {};\n    return metrics.data;\n  },\n  getNodeBoundingRect: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (metrics.boundingRect === undefined) metrics.boundingRect = V(magnet).getBBox();\n    return new Rect(metrics.boundingRect);\n  },\n  getNodeMatrix: function (magnet) {\n    const metrics = this.nodeCache(magnet);\n    if (metrics.magnetMatrix === undefined) {\n      const {\n        rotatableNode,\n        el\n      } = this;\n      let target;\n      if (rotatableNode && rotatableNode.contains(magnet)) {\n        target = rotatableNode;\n      } else {\n        target = el;\n      }\n      metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n    }\n    return V.createSVGMatrix(metrics.magnetMatrix);\n  },\n  getNodeShape: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n    return metrics.geometryShape.clone();\n  },\n  isNodeConnection: function (node) {\n    return this.model.isLink() && (!node || node === this.el);\n  },\n  findNodesAttributes: function (attrs, root, selectorCache, selectors) {\n    var i, n, nodeAttrs, nodeId;\n    var nodesAttrs = {};\n    var mergeIds = [];\n    for (var selector in attrs) {\n      if (!attrs.hasOwnProperty(selector)) continue;\n      nodeAttrs = attrs[selector];\n      if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n      var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n      for (i = 0, n = selected.length; i < n; i++) {\n        var node = selected[i];\n        nodeId = V.ensureId(node);\n        // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n        // groupSelector referencing a single node is not \"unique\"\n        var unique = selectors && selectors[selector] === node;\n        var prevNodeAttrs = nodesAttrs[nodeId];\n        if (prevNodeAttrs) {\n          // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n          // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n          if (!prevNodeAttrs.array) {\n            mergeIds.push(nodeId);\n            prevNodeAttrs.array = true;\n            prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n            prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n          }\n          var attributes = prevNodeAttrs.attributes;\n          var selectedLength = prevNodeAttrs.selectedLength;\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(nodeAttrs);\n            selectedLength.unshift(-1);\n          } else {\n            // node referenced by `groupSelector`\n            var sortIndex = sortedIndex(selectedLength, n);\n            attributes.splice(sortIndex, 0, nodeAttrs);\n            selectedLength.splice(sortIndex, 0, n);\n          }\n        } else {\n          nodesAttrs[nodeId] = {\n            attributes: nodeAttrs,\n            selectedLength: unique ? -1 : n,\n            node: node,\n            array: false\n          };\n        }\n      }\n    }\n    for (i = 0, n = mergeIds.length; i < n; i++) {\n      nodeId = mergeIds[i];\n      nodeAttrs = nodesAttrs[nodeId];\n      nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n    }\n    return nodesAttrs;\n  },\n  getEventTarget: function (evt, opt = {}) {\n    const {\n      target,\n      type,\n      clientX = 0,\n      clientY = 0\n    } = evt;\n    if (\n    // Explicitly defined `fromPoint` option\n    opt.fromPoint ||\n    // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n    // It holds the element when a touchstart triggered.\n    type === 'touchmove' || type === 'touchend' ||\n    // Pointermove/Pointerup event with the pointer captured\n    'pointerId' in evt && target.hasPointerCapture(evt.pointerId)) {\n      return document.elementFromPoint(clientX, clientY);\n    }\n    return target;\n  },\n  // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n  // unless `attrs` parameter was passed.\n  updateDOMSubtreeAttributes: function (rootNode, attrs, opt) {\n    opt || (opt = {});\n    opt.rootBBox || (opt.rootBBox = Rect());\n    opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n    // Cache table for query results and bounding box calculation.\n    // Note that `selectorCache` needs to be invalidated for all\n    // `updateAttributes` calls, as the selectors might pointing\n    // to nodes designated by an attribute or elements dynamically\n    // created.\n    var selectorCache = {};\n    var bboxCache = {};\n    var relativeItems = [];\n    var relativeRefItems = [];\n    var item, node, nodeAttrs, nodeData, processedAttrs;\n    var roAttrs = opt.roAttributes;\n    var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n    // `nodesAttrs` are different from all attributes, when\n    // rendering only  attributes sent to this method.\n    var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;\n    for (var nodeId in nodesAttrs) {\n      nodeData = nodesAttrs[nodeId];\n      nodeAttrs = nodeData.attributes;\n      node = nodeData.node;\n      processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n      if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) {\n        // Set all the normal attributes right on the SVG/HTML element.\n        this.setNodeAttributes(node, processedAttrs.normal);\n      } else {\n        var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n        var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;\n        var refNode;\n        if (refSelector) {\n          refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n          if (!refNode) {\n            throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n          }\n        } else {\n          refNode = null;\n        }\n        item = {\n          node: node,\n          refNode: refNode,\n          processedAttributes: processedAttrs,\n          allAttributes: nodeAllAttrs\n        };\n        if (refNode) {\n          // If an element in the list is positioned relative to this one, then\n          // we want to insert this one before it in the list.\n          var itemIndex = relativeRefItems.findIndex(function (item) {\n            return item.refNode === node;\n          });\n          if (itemIndex > -1) {\n            relativeRefItems.splice(itemIndex, 0, item);\n          } else {\n            relativeRefItems.push(item);\n          }\n        } else {\n          // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n          // The order of no-ref-items is not specified/important.\n          relativeItems.push(item);\n        }\n      }\n    }\n    relativeItems.push(...relativeRefItems);\n    for (let i = 0, n = relativeItems.length; i < n; i++) {\n      item = relativeItems[i];\n      node = item.node;\n      refNode = item.refNode;\n\n      // Find the reference element bounding box. If no reference was provided, we\n      // use the optional bounding box.\n      const refNodeId = refNode ? V.ensureId(refNode) : '';\n      let refBBox = bboxCache[refNodeId];\n      if (!refBBox) {\n        // Get the bounding box of the reference element using to the common ancestor\n        // transformation space.\n        //\n        // @example 1\n        // <g transform=\"translate(11, 13)\">\n        //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n        //     <rect @selector=\"a\"/>\n        // </g>\n        //\n        // In this case, the reference bounding box can not be affected\n        // by the `transform` attribute of the `<g>` element,\n        // because the exact transformation will be applied to the `a` element\n        // as well as to the `b` element.\n        //\n        // @example 2\n        // <g transform=\"translate(11, 13)\">\n        //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n        // </g>\n        // <rect @selector=\"a\"/>\n        //\n        // In this case, the reference bounding box have to be affected by the\n        // `transform` attribute of the `<g>` element, because the `a` element\n        // is not descendant of the `<g>` element and will not be affected\n        // by the transformation.\n        refBBox = bboxCache[refNodeId] = refNode ? V(refNode).getBBox({\n          target: getCommonAncestorNode(node, refNode)\n        }) : opt.rootBBox;\n      }\n      if (roAttrs) {\n        // if there was a special attribute affecting the position amongst passed-in attributes\n        // we have to merge it with the rest of the element's attributes as they are necessary\n        // to update the position relatively (i.e `ref-x` && 'ref-dx')\n        processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n        this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n      } else {\n        processedAttrs = item.processedAttributes;\n      }\n      this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n    }\n  },\n  mergeProcessedAttributes: function (processedAttrs, roProcessedAttrs) {\n    processedAttrs.set || (processedAttrs.set = {});\n    processedAttrs.position || (processedAttrs.position = {});\n    processedAttrs.offset || (processedAttrs.offset = {});\n    assign(processedAttrs.set, roProcessedAttrs.set);\n    assign(processedAttrs.position, roProcessedAttrs.position);\n    assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n    // Handle also the special transform property.\n    var transform = processedAttrs.normal && processedAttrs.normal.transform;\n    if (transform !== undefined && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform;\n    }\n    processedAttrs.normal = roProcessedAttrs.normal;\n  },\n  // Lifecycle methods\n\n  // Called when the view is attached to the DOM,\n  // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n  // or `paper.options.viewport` returning `true` (isInitialMount === false).\n  onMount(isInitialMount) {\n    if (isInitialMount) return;\n    this.mountTools();\n    HighlighterView.mount(this);\n  },\n  // Called when the view is detached from the DOM,\n  // as result of `paper.options.viewport` returning `false`.\n  onDetach() {\n    this.unmountTools();\n    HighlighterView.unmount(this);\n  },\n  // Called when the view is removed from the DOM\n  // as result of `cell.remove()`.\n  onRemove: function () {\n    this.removeTools();\n    this.removeHighlighters();\n  },\n  _toolsView: null,\n  hasTools: function (name) {\n    var toolsView = this._toolsView;\n    if (!toolsView) return false;\n    if (!name) return true;\n    return toolsView.getName() === name;\n  },\n  addTools: function (toolsView) {\n    this.removeTools();\n    if (toolsView) {\n      this._toolsView = toolsView;\n      toolsView.configure({\n        relatedView: this\n      });\n      toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n    }\n    return this;\n  },\n  unmountTools() {\n    const toolsView = this._toolsView;\n    if (toolsView) toolsView.unmount();\n    return this;\n  },\n  mountTools() {\n    const toolsView = this._toolsView;\n    // Prevent unnecessary re-appending of the tools.\n    if (toolsView && !toolsView.isMounted()) toolsView.mount();\n    return this;\n  },\n  updateTools: function (opt) {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.update(opt);\n    return this;\n  },\n  removeTools: function () {\n    var toolsView = this._toolsView;\n    if (toolsView) {\n      toolsView.remove();\n      this._toolsView = null;\n    }\n    return this;\n  },\n  hideTools: function () {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.hide();\n    return this;\n  },\n  showTools: function () {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.show();\n    return this;\n  },\n  onToolEvent: function (event) {\n    switch (event) {\n      case 'remove':\n        this.removeTools();\n        break;\n      case 'hide':\n        this.hideTools();\n        break;\n      case 'show':\n        this.showTools();\n        break;\n    }\n  },\n  removeHighlighters: function () {\n    HighlighterView.remove(this);\n  },\n  updateHighlighters: function (dirty = false) {\n    HighlighterView.update(this, null, dirty);\n  },\n  transformHighlighters: function () {\n    HighlighterView.transform(this);\n  },\n  // Interaction. The controller part.\n  // ---------------------------------\n\n  preventDefaultInteraction(evt) {\n    this.eventData(evt, {\n      defaultInteractionPrevented: true\n    });\n  },\n  isDefaultInteractionPrevented(evt) {\n    const {\n      defaultInteractionPrevented = false\n    } = this.eventData(evt);\n    return defaultInteractionPrevented;\n  },\n  // Interaction is handled by the paper and delegated to the view in interest.\n  // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n  // If necessary, real coordinates can be obtained from the `evt` event object.\n\n  // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n  // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n  pointerdblclick: function (evt, x, y) {\n    this.notify('cell:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    this.notify('cell:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    this.notify('cell:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    const {\n      model\n    } = this;\n    const {\n      graph\n    } = model;\n    if (graph) {\n      model.startBatch('pointer');\n      this.eventData(evt, {\n        graph\n      });\n    }\n    this.notify('cell:pointerdown', evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    this.notify('cell:pointermove', evt, x, y);\n  },\n  pointerup: function (evt, x, y) {\n    const {\n      graph\n    } = this.eventData(evt);\n    this.notify('cell:pointerup', evt, x, y);\n    if (graph) {\n      // we don't want to trigger event on model as model doesn't\n      // need to be member of collection anymore (remove)\n      graph.stopBatch('pointer', {\n        cell: this.model\n      });\n    }\n  },\n  mouseover: function (evt) {\n    this.notify('cell:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    this.notify('cell:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    this.notify('cell:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    this.notify('cell:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    this.notify('cell:mousewheel', evt, x, y, delta);\n  },\n  onevent: function (evt, eventName, x, y) {\n    this.notify(eventName, evt, x, y);\n  },\n  onmagnet: function () {\n\n    // noop\n  },\n  magnetpointerdblclick: function () {\n\n    // noop\n  },\n  magnetcontextmenu: function () {\n\n    // noop\n  },\n  checkMouseleave(evt) {\n    const {\n      paper,\n      model\n    } = this;\n    if (paper.isAsync()) {\n      // Make sure the source/target views are updated before this view.\n      // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n      // The connected cells could be links as well. In that case, we would\n      // need to recursively go through all the connected links and update\n      // their source/target views as well.\n      if (model.isLink()) {\n        // The `this.sourceView` and `this.targetView` might not be updated yet.\n        // We need to find the view by the model.\n        const sourceElement = model.getSourceElement();\n        if (sourceElement) {\n          const sourceView = paper.findViewByModel(sourceElement);\n          if (sourceView) {\n            paper.dumpView(sourceView);\n            paper.checkViewVisibility(sourceView);\n          }\n        }\n        const targetElement = model.getTargetElement();\n        if (targetElement) {\n          const targetView = paper.findViewByModel(targetElement);\n          if (targetView) {\n            paper.dumpView(targetView);\n            paper.checkViewVisibility(targetView);\n          }\n        }\n      }\n      // Do the updates of the current view synchronously now\n      paper.dumpView(this);\n      paper.checkViewVisibility(this);\n    }\n    const target = this.getEventTarget(evt, {\n      fromPoint: true\n    });\n    const view = paper.findView(target);\n    if (view === this) return;\n    // Leaving the current view\n    this.mouseleave(evt);\n    if (!view) return;\n    // Entering another view\n    view.mouseenter(evt);\n  },\n  setInteractivity: function (value) {\n    this.options.interactive = value;\n  }\n}, {\n  Flags,\n  Highlighting: HighlightingTypes,\n  addPresentationAttributes: function (presentationAttributes) {\n    return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function (a, b) {\n      if (!a || !b) return;\n      if (typeof a === 'string') a = [a];\n      if (typeof b === 'string') b = [b];\n      if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n    });\n  }\n});\n\n// TODO: Move to Vectorizer library.\nfunction getCommonAncestorNode(node1, node2) {\n  let parent = node1;\n  do {\n    if (parent.contains(node2)) return parent;\n    parent = parent.parentNode;\n  } while (parent);\n  return null;\n}","map":{"version":3,"names":["config","View","assign","guid","omit","parseDOMJSON","isFunction","isObject","isPlainObject","isBoolean","isEmpty","isString","toKebabCase","result","sortedIndex","merge","uniq","Point","Rect","V","$","HighlighterView","HighlightingTypes","DEFAULT","EMBEDDING","CONNECTING","MAGNET_AVAILABILITY","ELEMENT_AVAILABILITY","Flags","TOOLS","CellView","extend","tagName","svgElement","selector","metrics","className","classNames","type","model","get","toLowerCase","split","forEach","value","index","list","push","slice","join","_presentationAttributes","_flags","setFlags","flags","attributes","shift","i","n","label","presentationAttributes","attribute","hasOwnProperty","labels","Array","isArray","length","flag","initFlag","Error","hasFlag","getFlag","removeFlag","cell","id","constructor","options","call","initialize","prototype","apply","arguments","cleanNodesCache","$el","data","startListening","listenTo","onAttributesChange","opt","getChangeFlag","updateHandled","dirty","tool","async","requestUpdate","paper","requestViewUpdate","UPDATE_PRIORITY","markup","root","doc","selectors","groups","groupSelectors","group","rootSelector","fragment","can","feature","interactive","findBySelector","el","nodes","useCSSSelectors","find","toArray","notify","eventName","args","trigger","concat","getBBox","bbox","useModelGeometry","angle","getNodeBBox","localToPaperRect","magnet","rect","getNodeBoundingRect","transformMatrix","getRootTranslateMatrix","multiply","getNodeRotateMatrix","magnetMatrix","getNodeMatrix","transformRect","node","rotatableNode","contains","getRootRotateMatrix","createSVGMatrix","getNodeUnrotatedBBox","translateMatrix","position","mt","translate","x","y","mr","cx","width","cy","height","rotate","_notifyHighlight","rootNode","partial","undefined","embedding","connecting","magnetAvailability","elementAvailability","highlight","unhighlight","findMagnet","magnetAttribute","getAttribute","isMagnetRoot","parentNode","findProxyNode","nodeSelector","proxyNode","getSelector","prevSelector","nthChild","addLinkFromMagnet","graph","link","getDefaultLink","set","source","getLinkEnd","target","addTo","ui","findView","port","findAttribute","end","hasPort","customizeLinkEnd","endType","connectionStrategy","strategy","getMagnetFromLinkEnd","isElement","findPortNode","dragLinkStart","evt","startBatch","linkView","notifyPointerdown","eventData","startArrowheadMove","whenNotAllowed","dragLink","pointermove","magnetThreshold","currentTarget","getEventTarget","targetMagnet","mousemoved","dragLinkEnd","pointerup","stopBatch","getAttributeDefinition","attrName","setNodeAttributes","attrs","SVGElement","attr","processNodeAttributes","attrVal","def","normalAttrs","setAttrs","positionAttrs","offsetAttrs","relatives","qualify","offset","raw","normal","updateRelativeAttributes","refBBox","rawAttrs","nodeAttrs","setResult","clone","HTMLElement","nodeTransform","transform","nodeMatrix","transformStringToMatrix","nodePosition","e","f","sx","sy","translation","nodeScale","getNodeScale","scalableNode","positioned","scale","offseted","nodeBoundingRect","nodeBBox","round","setAttribute","matrixToTransformString","nodeCache","ensureId","getNodeData","boundingRect","getTransformToElement","getNodeShape","geometryShape","toGeometryShape","isNodeConnection","isLink","findNodesAttributes","selectorCache","nodeId","nodesAttrs","mergeIds","selected","unique","prevNodeAttrs","array","selectedLength","unshift","sortIndex","splice","reverse","clientX","clientY","fromPoint","hasPointerCapture","pointerId","document","elementFromPoint","updateDOMSubtreeAttributes","rootBBox","bboxCache","relativeItems","relativeRefItems","item","nodeData","processedAttrs","roAttrs","roAttributes","nodesAllAttrs","nodeAllAttrs","refSelector","ref","refNode","processedAttributes","allAttributes","itemIndex","findIndex","refNodeId","getCommonAncestorNode","mergeProcessedAttributes","roProcessedAttrs","onMount","isInitialMount","mountTools","mount","onDetach","unmountTools","unmount","onRemove","removeTools","removeHighlighters","_toolsView","hasTools","name","toolsView","getName","addTools","configure","relatedView","onToolEvent","bind","isMounted","updateTools","update","remove","hideTools","hide","showTools","show","event","updateHighlighters","transformHighlighters","preventDefaultInteraction","defaultInteractionPrevented","isDefaultInteractionPrevented","pointerdblclick","pointerclick","contextmenu","pointerdown","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onevent","onmagnet","magnetpointerdblclick","magnetcontextmenu","checkMouseleave","isAsync","sourceElement","getSourceElement","sourceView","findViewByModel","dumpView","checkViewVisibility","targetElement","getTargetElement","targetView","view","setInteractivity","Highlighting","addPresentationAttributes","a","b","node1","node2","parent"],"sources":["/Users/lijiaxin/Documents/workspace/hydsoft-oms-frontend/node_modules/jointjs/src/dia/CellView.mjs"],"sourcesContent":["import { config } from '../config/index.mjs';\nimport { View } from '../mvc/index.mjs';\nimport {\n    assign,\n    guid,\n    omit,\n    parseDOMJSON,\n    isFunction,\n    isObject,\n    isPlainObject,\n    isBoolean,\n    isEmpty,\n    isString,\n    toKebabCase,\n    result,\n    sortedIndex,\n    merge,\n    uniq\n} from '../util/index.mjs';\nimport { Point, Rect } from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport $ from 'jquery';\nimport { HighlighterView } from './HighlighterView.mjs';\n\nconst HighlightingTypes = {\n    DEFAULT: 'default',\n    EMBEDDING: 'embedding',\n    CONNECTING: 'connecting',\n    MAGNET_AVAILABILITY: 'magnetAvailability',\n    ELEMENT_AVAILABILITY: 'elementAvailability'\n};\n\nconst Flags = {\n    TOOLS: 'TOOLS',\n};\n\n// CellView base view and controller.\n// --------------------------------------------\n\n// This is the base view and controller for `ElementView` and `LinkView`.\nexport const CellView = View.extend({\n\n    tagName: 'g',\n\n    svgElement: true,\n\n    selector: 'root',\n\n    metrics: null,\n\n    className: function() {\n\n        var classNames = ['cell'];\n        var type = this.model.get('type');\n\n        if (type) {\n\n            type.toLowerCase().split('.').forEach(function(value, index, list) {\n                classNames.push('type-' + list.slice(0, index + 1).join('-'));\n            });\n        }\n\n        return classNames.join(' ');\n    },\n\n    _presentationAttributes: null,\n    _flags: null,\n\n    setFlags: function() {\n        var flags = {};\n        var attributes = {};\n        var shift = 0;\n        var i, n, label;\n        var presentationAttributes = result(this, 'presentationAttributes');\n        for (var attribute in presentationAttributes) {\n            if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n            var labels = presentationAttributes[attribute];\n            if (!Array.isArray(labels)) labels = [labels];\n            for (i = 0, n = labels.length; i < n; i++) {\n                label = labels[i];\n                var flag = flags[label];\n                if (!flag) {\n                    flag = flags[label] = 1<<(shift++);\n                }\n                attributes[attribute] |= flag;\n            }\n        }\n        var initFlag = result(this, 'initFlag');\n        if (!Array.isArray(initFlag)) initFlag = [initFlag];\n        for (i = 0, n = initFlag.length; i < n; i++) {\n            label = initFlag[i];\n            if (!flags[label]) flags[label] = 1<<(shift++);\n        }\n\n        // 26 - 30 are reserved for paper flags\n        // 31+ overflows maximal number\n        if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n\n        this._flags = flags;\n        this._presentationAttributes = attributes;\n    },\n\n    hasFlag: function(flag, label) {\n        return flag & this.getFlag(label);\n    },\n\n    removeFlag: function(flag, label) {\n        return flag ^ (flag & this.getFlag(label));\n    },\n\n    getFlag: function(label) {\n        var flags = this._flags;\n        if (!flags) return 0;\n        var flag = 0;\n        if (Array.isArray(label)) {\n            for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n        } else {\n            flag |= flags[label];\n        }\n        return flag;\n    },\n\n    attributes: function() {\n        var cell = this.model;\n        return {\n            'model-id': cell.id,\n            'data-type': cell.attributes.type\n        };\n    },\n\n    constructor: function(options) {\n\n        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n        // still be associated to the same object among all those clients. This is necessary for real-time\n        // collaboration mechanism.\n        options.id = options.id || guid(this);\n\n        View.call(this, options);\n    },\n\n    initialize: function() {\n\n        this.setFlags();\n\n        View.prototype.initialize.apply(this, arguments);\n\n        this.cleanNodesCache();\n\n        // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\n        this.$el.data('view', this);\n\n        this.startListening();\n    },\n\n    startListening: function() {\n        this.listenTo(this.model, 'change', this.onAttributesChange);\n    },\n\n    onAttributesChange: function(model, opt) {\n        var flag = model.getChangeFlag(this._presentationAttributes);\n        if (opt.updateHandled || !flag) return;\n        if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n        // TODO: tool changes does not need to be sync\n        // Fix Segments tools\n        if (opt.tool) opt.async = false;\n        this.requestUpdate(flag, opt);\n    },\n\n    requestUpdate: function(flags, opt) {\n        const { paper } = this;\n        if (paper && flags > 0) {\n            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    parseDOMJSON: function(markup, root) {\n\n        var doc = parseDOMJSON(markup);\n        var selectors = doc.selectors;\n        var groups = doc.groupSelectors;\n        for (var group in groups) {\n            if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n            selectors[group] = groups[group];\n        }\n        if (root) {\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n            selectors[rootSelector] = root;\n        }\n        return { fragment: doc.fragment, selectors: selectors };\n    },\n\n    // Return `true` if cell link is allowed to perform a certain UI `feature`.\n    // Example: `can('vertexMove')`, `can('labelMove')`.\n    can: function(feature) {\n\n        var interactive = isFunction(this.options.interactive)\n            ? this.options.interactive(this)\n            : this.options.interactive;\n\n        return (isObject(interactive) && interactive[feature] !== false) ||\n            (isBoolean(interactive) && interactive !== false);\n    },\n\n    findBySelector: function(selector, root, selectors) {\n\n        root || (root = this.el);\n        selectors || (selectors = this.selectors);\n\n        // These are either descendants of `this.$el` of `this.$el` itself.\n        // `.` is a special selector used to select the wrapping `<g>` element.\n        if (!selector || selector === '.') return [root];\n        if (selectors) {\n            var nodes = selectors[selector];\n            if (nodes) {\n                if (Array.isArray(nodes)) return nodes;\n                return [nodes];\n            }\n        }\n\n        // Maintaining backwards compatibility\n        // e.g. `circle:first` would fail with querySelector() call\n        if (config.useCSSSelectors) return $(root).find(selector).toArray();\n\n        return [];\n    },\n\n    notify: function(eventName) {\n\n        if (this.paper) {\n\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            // Trigger the event on both the element itself and also on the paper.\n            this.trigger.apply(this, [eventName].concat(args));\n\n            // Paper event handlers receive the view object as the first argument.\n            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n        }\n    },\n\n    getBBox: function(opt) {\n\n        var bbox;\n        if (opt && opt.useModelGeometry) {\n            var model = this.model;\n            bbox = model.getBBox().bbox(model.angle());\n        } else {\n            bbox = this.getNodeBBox(this.el);\n        }\n\n        return this.paper.localToPaperRect(bbox);\n    },\n\n    getNodeBBox: function(magnet) {\n\n        const rect = this.getNodeBoundingRect(magnet);\n        const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n        const magnetMatrix = this.getNodeMatrix(magnet);\n        return V.transformRect(rect, transformMatrix.multiply(magnetMatrix));\n    },\n\n    getNodeRotateMatrix(node) {\n        if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n            // Rotate transformation is applied to all nodes when no rotatableGroup\n            // is present or to nodes inside the rotatableGroup only.\n            return this.getRootRotateMatrix();\n        }\n        // Nodes outside the rotatable group\n        return V.createSVGMatrix();\n    },\n\n    getNodeUnrotatedBBox: function(magnet) {\n\n        var rect = this.getNodeBoundingRect(magnet);\n        var magnetMatrix = this.getNodeMatrix(magnet);\n        var translateMatrix = this.getRootTranslateMatrix();\n        return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n    },\n\n    getRootTranslateMatrix: function() {\n\n        var model = this.model;\n        var position = model.position();\n        var mt = V.createSVGMatrix().translate(position.x, position.y);\n        return mt;\n    },\n\n    getRootRotateMatrix: function() {\n\n        var mr = V.createSVGMatrix();\n        var model = this.model;\n        var angle = model.angle();\n        if (angle) {\n            var bbox = model.getBBox();\n            var cx = bbox.width / 2;\n            var cy = bbox.height / 2;\n            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n        }\n        return mr;\n    },\n\n    _notifyHighlight: function(eventName, el, opt = {}) {\n        const { el: rootNode } = this;\n        let node;\n        if (typeof el === 'string') {\n            [node = rootNode] = this.findBySelector(el);\n        } else {\n            [node = rootNode] = this.$(el);\n        }\n        // set partial flag if the highlighted element is not the entire view.\n        opt.partial = (node !== rootNode);\n        // translate type flag into a type string\n        if (opt.type === undefined) {\n            let type;\n            switch (true) {\n                case opt.embedding:\n                    type = HighlightingTypes.EMBEDDING;\n                    break;\n                case opt.connecting:\n                    type = HighlightingTypes.CONNECTING;\n                    break;\n                case opt.magnetAvailability:\n                    type = HighlightingTypes.MAGNET_AVAILABILITY;\n                    break;\n                case opt.elementAvailability:\n                    type = HighlightingTypes.ELEMENT_AVAILABILITY;\n                    break;\n                default:\n                    type = HighlightingTypes.DEFAULT;\n                    break;\n            }\n            opt.type = type;\n        }\n        this.notify(eventName, node, opt);\n        return this;\n    },\n\n    highlight: function(el, opt) {\n        return this._notifyHighlight('cell:highlight', el, opt);\n    },\n\n    unhighlight: function(el, opt = {}) {\n        return this._notifyHighlight('cell:unhighlight', el, opt);\n    },\n\n    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n    // an element found, return the root element of the cell view.\n    findMagnet: function(el) {\n\n        const root = this.el;\n        let magnet = this.$(el)[0];\n        if (!magnet) {\n            magnet = root;\n        }\n\n        do {\n            const magnetAttribute = magnet.getAttribute('magnet');\n            const isMagnetRoot = (magnet === root);\n            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n                return magnet;\n            }\n            if (isMagnetRoot) {\n                // If the overall cell has set `magnet === false`, then return `undefined` to\n                // announce there is no magnet found for this cell.\n                // This is especially useful to set on cells that have 'ports'. In this case,\n                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n                return undefined;\n            }\n            magnet = magnet.parentNode;\n        } while (magnet);\n\n        return undefined;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const [proxyNode] = this.findBySelector(nodeSelector);\n            if (proxyNode) return proxyNode;\n        }\n        return el;\n    },\n\n    // Construct a unique selector for the `el` element within this view.\n    // `prevSelector` is being collected through the recursive call.\n    // No value for `prevSelector` is expected when using this method.\n    getSelector: function(el, prevSelector) {\n\n        var selector;\n\n        if (el === this.el) {\n            if (typeof prevSelector === 'string') selector = '> ' + prevSelector;\n            return selector;\n        }\n\n        if (el) {\n\n            var nthChild = V(el).index() + 1;\n            selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n            if (prevSelector) {\n                selector += ' > ' + prevSelector;\n            }\n\n            selector = this.getSelector(el.parentNode, selector);\n        }\n\n        return selector;\n    },\n\n    addLinkFromMagnet: function(magnet, x, y) {\n\n        var paper = this.paper;\n        var graph = paper.model;\n\n        var link = paper.getDefaultLink(this, magnet);\n        link.set({\n            source: this.getLinkEnd(magnet, x, y, link, 'source'),\n            target: { x: x, y: y }\n        }).addTo(graph, {\n            async: false,\n            ui: true\n        });\n\n        return link.findView(paper);\n    },\n\n    getLinkEnd: function(magnet, ...args) {\n\n        var model = this.model;\n        var id = model.id;\n        var port = this.findAttribute('port', magnet);\n        // Find a unique `selector` of the element under pointer that is a magnet.\n        var selector = magnet.getAttribute('joint-selector');\n\n        var end = { id: id };\n        if (selector != null) end.magnet = selector;\n        if (port != null) {\n            end.port = port;\n            if (!model.hasPort(port) && !selector) {\n                // port created via the `port` attribute (not API)\n                end.selector = this.getSelector(magnet);\n            }\n        } else if (selector == null && this.el !== magnet) {\n            end.selector = this.getSelector(magnet);\n        }\n\n        return this.customizeLinkEnd(end, magnet, ...args);\n    },\n\n    customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n        const { paper } = this;\n        const { connectionStrategy } = paper.options;\n        if (typeof connectionStrategy === 'function') {\n            var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n            if (strategy) return strategy;\n        }\n        return end;\n    },\n\n    getMagnetFromLinkEnd: function(end) {\n\n        var root = this.el;\n        var port = end.port;\n        var selector = end.magnet;\n        var model = this.model;\n        var magnet;\n        if (port != null && model.isElement() && model.hasPort(port)) {\n            magnet = this.findPortNode(port, selector) || root;\n        } else {\n            if (!selector) selector = end.selector;\n            if (!selector && port != null) {\n                // link end has only `id` and `port` property referencing\n                // a port created via the `port` attribute (not API).\n                selector = '[port=\"' + port + '\"]';\n            }\n            magnet = this.findBySelector(selector, root, this.selectors)[0];\n        }\n\n        return this.findProxyNode(magnet, 'magnet');\n    },\n\n    dragLinkStart: function(evt, magnet, x, y) {\n        this.model.startBatch('add-link');\n        const linkView = this.addLinkFromMagnet(magnet, x, y);\n        // backwards compatibility events\n        linkView.notifyPointerdown(evt, x, y);\n        linkView.eventData(evt, linkView.startArrowheadMove('target', { whenNotAllowed: 'remove' }));\n        this.eventData(evt, { linkView });\n    },\n\n    dragLink: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (linkView) {\n            linkView.pointermove(evt, x, y);\n        } else {\n            var paper = this.paper;\n            var magnetThreshold = paper.options.magnetThreshold;\n            var currentTarget = this.getEventTarget(evt);\n            var targetMagnet = data.targetMagnet;\n            if (magnetThreshold === 'onleave') {\n                // magnetThreshold when the pointer leaves the magnet\n                if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n            } else {\n                // magnetThreshold defined as a number of movements\n                if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n            }\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n    },\n\n    dragLinkEnd: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (!linkView) return;\n        linkView.pointerup(evt, x, y);\n        this.model.stopBatch('add-link');\n    },\n\n    getAttributeDefinition: function(attrName) {\n\n        return this.model.constructor.getAttributeDefinition(attrName);\n    },\n\n    setNodeAttributes: function(node, attrs) {\n\n        if (!isEmpty(attrs)) {\n            if (node instanceof SVGElement) {\n                V(node).attr(attrs);\n            } else {\n                $(node).attr(attrs);\n            }\n        }\n    },\n\n    processNodeAttributes: function(node, attrs) {\n\n        var attrName, attrVal, def, i, n;\n        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n        var relatives = [];\n        // divide the attributes between normal and special\n        for (attrName in attrs) {\n            if (!attrs.hasOwnProperty(attrName)) continue;\n            attrVal = attrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, attrs, this))) {\n                if (isString(def.set)) {\n                    normalAttrs || (normalAttrs = {});\n                    normalAttrs[def.set] = attrVal;\n                }\n                if (attrVal !== null) {\n                    relatives.push(attrName, def);\n                }\n            } else {\n                normalAttrs || (normalAttrs = {});\n                normalAttrs[toKebabCase(attrName)] = attrVal;\n            }\n        }\n\n        // handle the rest of attributes via related method\n        // from the special attributes namespace.\n        for (i = 0, n = relatives.length; i < n; i+=2) {\n            attrName = relatives[i];\n            def = relatives[i+1];\n            attrVal = attrs[attrName];\n            if (isFunction(def.set)) {\n                setAttrs || (setAttrs = {});\n                setAttrs[attrName] = attrVal;\n            }\n            if (isFunction(def.position)) {\n                positionAttrs || (positionAttrs = {});\n                positionAttrs[attrName] = attrVal;\n            }\n            if (isFunction(def.offset)) {\n                offsetAttrs || (offsetAttrs = {});\n                offsetAttrs[attrName] = attrVal;\n            }\n        }\n\n        return {\n            raw: attrs,\n            normal: normalAttrs,\n            set: setAttrs,\n            position: positionAttrs,\n            offset: offsetAttrs\n        };\n    },\n\n    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n\n        opt || (opt = {});\n\n        var attrName, attrVal, def;\n        var rawAttrs = attrs.raw || {};\n        var nodeAttrs = attrs.normal || {};\n        var setAttrs = attrs.set;\n        var positionAttrs = attrs.position;\n        var offsetAttrs = attrs.offset;\n\n        for (attrName in setAttrs) {\n            attrVal = setAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // SET - set function should return attributes to be set on the node,\n            // which will affect the node dimensions based on the reference bounding\n            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);\n            if (isObject(setResult)) {\n                assign(nodeAttrs, setResult);\n            } else if (setResult !== undefined) {\n                nodeAttrs[attrName] = setResult;\n            }\n        }\n\n        if (node instanceof HTMLElement) {\n            // TODO: setting the `transform` attribute on HTMLElements\n            // via `node.style.transform = 'matrix(...)';` would introduce\n            // a breaking change (e.g. basic.TextBlock).\n            this.setNodeAttributes(node, nodeAttrs);\n            return;\n        }\n\n        // The final translation of the subelement.\n        var nodeTransform = nodeAttrs.transform;\n        var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n        var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n        if (nodeTransform) {\n            nodeAttrs = omit(nodeAttrs, 'transform');\n            nodeMatrix.e = nodeMatrix.f = 0;\n        }\n\n        // Calculate node scale determined by the scalable group\n        // only if later needed.\n        var sx, sy, translation;\n        if (positionAttrs || offsetAttrs) {\n            var nodeScale = this.getNodeScale(node, opt.scalableNode);\n            sx = nodeScale.sx;\n            sy = nodeScale.sy;\n        }\n\n        var positioned = false;\n        for (attrName in positionAttrs) {\n            attrVal = positionAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // POSITION - position function should return a point from the\n            // reference bounding box. The default position of the node is x:0, y:0 of\n            // the reference bounding box or could be further specify by some\n            // SVG attributes e.g. `x`, `y`\n            translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs, this);\n            if (translation) {\n                nodePosition.offset(Point(translation).scale(sx, sy));\n                positioned || (positioned = true);\n            }\n        }\n\n        // The node bounding box could depend on the `size` set from the previous loop.\n        // Here we know, that all the size attributes have been already set.\n        this.setNodeAttributes(node, nodeAttrs);\n\n        var offseted = false;\n        if (offsetAttrs) {\n            // Check if the node is visible\n            var nodeBoundingRect = this.getNodeBoundingRect(node);\n            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                for (attrName in offsetAttrs) {\n                    attrVal = offsetAttrs[attrName];\n                    def = this.getAttributeDefinition(attrName);\n                    // OFFSET - offset function should return a point from the element\n                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n                    translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs, this);\n                    if (translation) {\n                        nodePosition.offset(Point(translation).scale(sx, sy));\n                        offseted || (offseted = true);\n                    }\n                }\n            }\n        }\n\n        // Do not touch node's transform attribute if there is no transformation applied.\n        if (nodeTransform !== undefined || positioned || offseted) {\n            // Round the coordinates to 1 decimal point.\n            nodePosition.round(1);\n            nodeMatrix.e = nodePosition.x;\n            nodeMatrix.f = nodePosition.y;\n            node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n            // TODO: store nodeMatrix metrics?\n        }\n    },\n\n    getNodeScale: function(node, scalableNode) {\n\n        // Check if the node is a descendant of the scalable group.\n        var sx, sy;\n        if (scalableNode && scalableNode.contains(node)) {\n            var scale = scalableNode.scale();\n            sx = 1 / scale.sx;\n            sy = 1 / scale.sy;\n        } else {\n            sx = 1;\n            sy = 1;\n        }\n\n        return { sx: sx, sy: sy };\n    },\n\n    cleanNodesCache: function() {\n        this.metrics = {};\n    },\n\n    nodeCache: function(magnet) {\n\n        var metrics = this.metrics;\n        // Don't use cache? It most likely a custom view with overridden update.\n        if (!metrics) return {};\n        var id = V.ensureId(magnet);\n        var value = metrics[id];\n        if (!value) value = metrics[id] = {};\n        return value;\n    },\n\n    getNodeData: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (!metrics.data) metrics.data = {};\n        return metrics.data;\n    },\n\n    getNodeBoundingRect: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.boundingRect === undefined) metrics.boundingRect = V(magnet).getBBox();\n        return new Rect(metrics.boundingRect);\n    },\n\n    getNodeMatrix: function(magnet) {\n\n        const metrics = this.nodeCache(magnet);\n        if (metrics.magnetMatrix === undefined) {\n            const { rotatableNode, el } = this;\n            let target;\n            if (rotatableNode && rotatableNode.contains(magnet)) {\n                target = rotatableNode;\n            } else {\n                target = el;\n            }\n            metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n        }\n        return V.createSVGMatrix(metrics.magnetMatrix);\n    },\n\n    getNodeShape: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n        return metrics.geometryShape.clone();\n    },\n\n    isNodeConnection: function(node) {\n        return this.model.isLink() && (!node || node === this.el);\n    },\n\n    findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n\n        var i, n, nodeAttrs, nodeId;\n        var nodesAttrs = {};\n        var mergeIds = [];\n        for (var selector in attrs) {\n            if (!attrs.hasOwnProperty(selector)) continue;\n            nodeAttrs = attrs[selector];\n            if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n            for (i = 0, n = selected.length; i < n; i++) {\n                var node = selected[i];\n                nodeId = V.ensureId(node);\n                // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n                // groupSelector referencing a single node is not \"unique\"\n                var unique = (selectors && selectors[selector] === node);\n                var prevNodeAttrs = nodesAttrs[nodeId];\n                if (prevNodeAttrs) {\n                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n                    if (!prevNodeAttrs.array) {\n                        mergeIds.push(nodeId);\n                        prevNodeAttrs.array = true;\n                        prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n                        prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n                    }\n                    var attributes = prevNodeAttrs.attributes;\n                    var selectedLength = prevNodeAttrs.selectedLength;\n                    if (unique) {\n                        // node referenced by `selector`\n                        attributes.unshift(nodeAttrs);\n                        selectedLength.unshift(-1);\n                    } else {\n                        // node referenced by `groupSelector`\n                        var sortIndex = sortedIndex(selectedLength, n);\n                        attributes.splice(sortIndex, 0, nodeAttrs);\n                        selectedLength.splice(sortIndex, 0, n);\n                    }\n                } else {\n                    nodesAttrs[nodeId] = {\n                        attributes: nodeAttrs,\n                        selectedLength: unique ? -1 : n,\n                        node: node,\n                        array: false\n                    };\n                }\n            }\n        }\n\n        for (i = 0, n = mergeIds.length; i < n; i++) {\n            nodeId = mergeIds[i];\n            nodeAttrs = nodesAttrs[nodeId];\n            nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n        }\n\n        return nodesAttrs;\n    },\n\n    getEventTarget: function(evt, opt = {}) {\n        const { target, type, clientX = 0, clientY = 0 } = evt;\n        if (\n            // Explicitly defined `fromPoint` option\n            opt.fromPoint ||\n            // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n            // It holds the element when a touchstart triggered.\n            type === 'touchmove' || type === 'touchend' ||\n            // Pointermove/Pointerup event with the pointer captured\n            ('pointerId' in evt && target.hasPointerCapture(evt.pointerId))\n        ) {\n            return document.elementFromPoint(clientX, clientY);\n        }\n\n        return target;\n    },\n\n    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n    // unless `attrs` parameter was passed.\n    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n\n        opt || (opt = {});\n        opt.rootBBox || (opt.rootBBox = Rect());\n        opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n        // Cache table for query results and bounding box calculation.\n        // Note that `selectorCache` needs to be invalidated for all\n        // `updateAttributes` calls, as the selectors might pointing\n        // to nodes designated by an attribute or elements dynamically\n        // created.\n        var selectorCache = {};\n        var bboxCache = {};\n        var relativeItems = [];\n        var relativeRefItems = [];\n        var item, node, nodeAttrs, nodeData, processedAttrs;\n\n        var roAttrs = opt.roAttributes;\n        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n        // `nodesAttrs` are different from all attributes, when\n        // rendering only  attributes sent to this method.\n        var nodesAllAttrs = (roAttrs)\n            ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors)\n            : nodesAttrs;\n\n        for (var nodeId in nodesAttrs) {\n            nodeData = nodesAttrs[nodeId];\n            nodeAttrs = nodeData.attributes;\n            node = nodeData.node;\n            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) {\n                // Set all the normal attributes right on the SVG/HTML element.\n                this.setNodeAttributes(node, processedAttrs.normal);\n\n            } else {\n\n                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n                var refSelector = (nodeAllAttrs && (nodeAttrs.ref === undefined))\n                    ? nodeAllAttrs.ref\n                    : nodeAttrs.ref;\n\n                var refNode;\n                if (refSelector) {\n                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n                    if (!refNode) {\n                        throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n                    }\n                } else {\n                    refNode = null;\n                }\n\n                item = {\n                    node: node,\n                    refNode: refNode,\n                    processedAttributes: processedAttrs,\n                    allAttributes: nodeAllAttrs\n                };\n\n                if (refNode) {\n                    // If an element in the list is positioned relative to this one, then\n                    // we want to insert this one before it in the list.\n                    var itemIndex = relativeRefItems.findIndex(function(item) {\n                        return item.refNode === node;\n                    });\n\n                    if (itemIndex > -1) {\n                        relativeRefItems.splice(itemIndex, 0, item);\n                    } else {\n                        relativeRefItems.push(item);\n                    }\n                } else {\n                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n                    // The order of no-ref-items is not specified/important.\n                    relativeItems.push(item);\n                }\n            }\n        }\n\n        relativeItems.push(...relativeRefItems);\n\n        for (let i = 0, n = relativeItems.length; i < n; i++) {\n            item = relativeItems[i];\n            node = item.node;\n            refNode = item.refNode;\n\n            // Find the reference element bounding box. If no reference was provided, we\n            // use the optional bounding box.\n            const refNodeId = refNode ? V.ensureId(refNode) : '';\n            let refBBox = bboxCache[refNodeId];\n            if (!refBBox) {\n                // Get the bounding box of the reference element using to the common ancestor\n                // transformation space.\n                //\n                // @example 1\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                //     <rect @selector=\"a\"/>\n                // </g>\n                //\n                // In this case, the reference bounding box can not be affected\n                // by the `transform` attribute of the `<g>` element,\n                // because the exact transformation will be applied to the `a` element\n                // as well as to the `b` element.\n                //\n                // @example 2\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                // </g>\n                // <rect @selector=\"a\"/>\n                //\n                // In this case, the reference bounding box have to be affected by the\n                // `transform` attribute of the `<g>` element, because the `a` element\n                // is not descendant of the `<g>` element and will not be affected\n                // by the transformation.\n                refBBox = bboxCache[refNodeId] = (refNode)\n                    ? V(refNode).getBBox({ target: getCommonAncestorNode(node, refNode) })\n                    : opt.rootBBox;\n            }\n\n            if (roAttrs) {\n                // if there was a special attribute affecting the position amongst passed-in attributes\n                // we have to merge it with the rest of the element's attributes as they are necessary\n                // to update the position relatively (i.e `ref-x` && 'ref-dx')\n                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\n            } else {\n                processedAttrs = item.processedAttributes;\n            }\n\n            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n        }\n    },\n\n    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n\n        processedAttrs.set || (processedAttrs.set = {});\n        processedAttrs.position || (processedAttrs.position = {});\n        processedAttrs.offset || (processedAttrs.offset = {});\n\n        assign(processedAttrs.set, roProcessedAttrs.set);\n        assign(processedAttrs.position, roProcessedAttrs.position);\n        assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n        // Handle also the special transform property.\n        var transform = processedAttrs.normal && processedAttrs.normal.transform;\n        if (transform !== undefined && roProcessedAttrs.normal) {\n            roProcessedAttrs.normal.transform = transform;\n        }\n        processedAttrs.normal = roProcessedAttrs.normal;\n    },\n\n    // Lifecycle methods\n\n    // Called when the view is attached to the DOM,\n    // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n    // or `paper.options.viewport` returning `true` (isInitialMount === false).\n    onMount(isInitialMount) {\n        if (isInitialMount) return;\n        this.mountTools();\n        HighlighterView.mount(this);\n    },\n\n    // Called when the view is detached from the DOM,\n    // as result of `paper.options.viewport` returning `false`.\n    onDetach() {\n        this.unmountTools();\n        HighlighterView.unmount(this);\n    },\n\n    // Called when the view is removed from the DOM\n    // as result of `cell.remove()`.\n    onRemove: function() {\n        this.removeTools();\n        this.removeHighlighters();\n    },\n\n    _toolsView: null,\n\n    hasTools: function(name) {\n        var toolsView = this._toolsView;\n        if (!toolsView) return false;\n        if (!name) return true;\n        return (toolsView.getName() === name);\n    },\n\n    addTools: function(toolsView) {\n\n        this.removeTools();\n\n        if (toolsView) {\n            this._toolsView = toolsView;\n            toolsView.configure({ relatedView: this });\n            toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n        }\n        return this;\n    },\n\n    unmountTools() {\n        const toolsView = this._toolsView;\n        if (toolsView) toolsView.unmount();\n        return this;\n    },\n\n    mountTools() {\n        const toolsView = this._toolsView;\n        // Prevent unnecessary re-appending of the tools.\n        if (toolsView && !toolsView.isMounted()) toolsView.mount();\n        return this;\n    },\n\n    updateTools: function(opt) {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.update(opt);\n        return this;\n    },\n\n    removeTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) {\n            toolsView.remove();\n            this._toolsView = null;\n        }\n        return this;\n    },\n\n    hideTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.hide();\n        return this;\n    },\n\n    showTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.show();\n        return this;\n    },\n\n    onToolEvent: function(event) {\n        switch (event) {\n            case 'remove':\n                this.removeTools();\n                break;\n            case 'hide':\n                this.hideTools();\n                break;\n            case 'show':\n                this.showTools();\n                break;\n        }\n    },\n\n    removeHighlighters: function() {\n        HighlighterView.remove(this);\n    },\n\n    updateHighlighters: function(dirty = false) {\n        HighlighterView.update(this, null, dirty);\n    },\n\n    transformHighlighters: function() {\n        HighlighterView.transform(this);\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    preventDefaultInteraction(evt) {\n        this.eventData(evt, { defaultInteractionPrevented: true  });\n    },\n\n    isDefaultInteractionPrevented(evt) {\n        const { defaultInteractionPrevented = false } = this.eventData(evt);\n        return defaultInteractionPrevented;\n    },\n\n    // Interaction is handled by the paper and delegated to the view in interest.\n    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n    // If necessary, real coordinates can be obtained from the `evt` event object.\n\n    // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n    // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n    pointerdblclick: function(evt, x, y) {\n\n        this.notify('cell:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        this.notify('cell:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        this.notify('cell:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        const { model } = this;\n        const { graph } = model;\n        if (graph) {\n            model.startBatch('pointer');\n            this.eventData(evt, { graph });\n        }\n\n        this.notify('cell:pointerdown', evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        this.notify('cell:pointermove', evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const { graph } = this.eventData(evt);\n\n        this.notify('cell:pointerup', evt, x, y);\n\n        if (graph) {\n            // we don't want to trigger event on model as model doesn't\n            // need to be member of collection anymore (remove)\n            graph.stopBatch('pointer', { cell: this.model });\n        }\n    },\n\n    mouseover: function(evt) {\n\n        this.notify('cell:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        this.notify('cell:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        this.notify('cell:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        this.notify('cell:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        this.notify('cell:mousewheel', evt, x, y, delta);\n    },\n\n    onevent: function(evt, eventName, x, y) {\n\n        this.notify(eventName, evt, x, y);\n    },\n\n    onmagnet: function() {\n\n        // noop\n    },\n\n    magnetpointerdblclick: function() {\n\n        // noop\n    },\n\n    magnetcontextmenu: function() {\n\n        // noop\n    },\n\n    checkMouseleave(evt) {\n        const { paper, model } = this;\n        if (paper.isAsync()) {\n            // Make sure the source/target views are updated before this view.\n            // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n            // The connected cells could be links as well. In that case, we would\n            // need to recursively go through all the connected links and update\n            // their source/target views as well.\n            if (model.isLink()) {\n                // The `this.sourceView` and `this.targetView` might not be updated yet.\n                // We need to find the view by the model.\n                const sourceElement = model.getSourceElement();\n                if (sourceElement) {\n                    const sourceView = paper.findViewByModel(sourceElement);\n                    if (sourceView) {\n                        paper.dumpView(sourceView);\n                        paper.checkViewVisibility(sourceView);\n                    }\n                }\n                const targetElement = model.getTargetElement();\n                if (targetElement) {\n                    const targetView = paper.findViewByModel(targetElement);\n                    if (targetView) {\n                        paper.dumpView(targetView);\n                        paper.checkViewVisibility(targetView);\n                    }\n                }\n            }\n            // Do the updates of the current view synchronously now\n            paper.dumpView(this);\n            paper.checkViewVisibility(this);\n        }\n        const target = this.getEventTarget(evt, { fromPoint: true });\n        const view = paper.findView(target);\n        if (view === this) return;\n        // Leaving the current view\n        this.mouseleave(evt);\n        if (!view) return;\n        // Entering another view\n        view.mouseenter(evt);\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n    }\n}, {\n\n    Flags,\n\n    Highlighting: HighlightingTypes,\n\n    addPresentationAttributes: function(presentationAttributes) {\n        return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function(a, b) {\n            if (!a || !b) return;\n            if (typeof a === 'string') a = [a];\n            if (typeof b === 'string') b = [b];\n            if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n        });\n    }\n});\n\n// TODO: Move to Vectorizer library.\nfunction getCommonAncestorNode(node1, node2) {\n    let parent = node1;\n    do {\n        if (parent.contains(node2)) return parent;\n        parent = parent.parentNode;\n    } while (parent);\n    return null;\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}