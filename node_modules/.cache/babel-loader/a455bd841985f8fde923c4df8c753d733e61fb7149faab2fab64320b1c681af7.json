{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Backbone from 'backbone';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\nimport { Link } from './Link.mjs';\nimport { Element } from './Element.mjs';\nimport { wrappers, wrapWith } from '../util/wrappers.mjs';\nimport { cloneCells } from '../util/index.mjs';\nconst GraphCells = Backbone.Collection.extend({\n  initialize: function (models, opt) {\n    // Set the optional namespace where all model classes are defined.\n    if (opt.cellNamespace) {\n      this.cellNamespace = opt.cellNamespace;\n    } else {\n      /* eslint-disable no-undef */\n      this.cellNamespace = typeof joint !== 'undefined' && util.has(joint, 'shapes') ? joint.shapes : null;\n      /* eslint-enable no-undef */\n    }\n\n    this.graph = opt.graph;\n  },\n  model: function (attrs, opt) {\n    var collection = opt.collection;\n    var namespace = collection.cellNamespace;\n\n    // Find the model class in the namespace or use the default one.\n    var ModelClass = attrs.type === 'link' ? Link : util.getByPath(namespace, attrs.type, '.') || Element;\n    var cell = new ModelClass(attrs, opt);\n    // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n    // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n    if (!opt.dry) {\n      cell.graph = collection.graph;\n    }\n    return cell;\n  },\n  // `comparator` makes it easy to sort cells based on their `z` index.\n  comparator: function (model) {\n    return model.get('z') || 0;\n  }\n});\nexport const Graph = Backbone.Model.extend({\n  initialize: function (attrs, opt) {\n    opt = opt || {};\n\n    // Passing `cellModel` function in the options object to graph allows for\n    // setting models based on attribute objects. This is especially handy\n    // when processing JSON graphs that are in a different than JointJS format.\n    var cells = new GraphCells([], {\n      model: opt.cellModel,\n      cellNamespace: opt.cellNamespace,\n      graph: this\n    });\n    Backbone.Model.prototype.set.call(this, 'cells', cells);\n\n    // Make all the events fired in the `cells` collection available.\n    // to the outside world.\n    cells.on('all', this.trigger, this);\n\n    // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\n    // they're already in the collection. Therefore, we're triggering sort manually here.\n    this.on('change:z', this._sortOnChangeZ, this);\n\n    // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n    // for fast graph queries. All changes that affect the structure of the graph\n    // must be reflected in the `al` object. This object provides fast answers to\n    // questions such as \"what are the neighbours of this node\" or \"what\n    // are the sibling links of this link\".\n\n    // Outgoing edges per node. Note that we use a hash-table for the list\n    // of outgoing edges for a faster lookup.\n    // [nodeId] -> Object [edgeId] -> true\n    this._out = {};\n    // Ingoing edges per node.\n    // [nodeId] -> Object [edgeId] -> true\n    this._in = {};\n    // `_nodes` is useful for quick lookup of all the elements in the graph, without\n    // having to go through the whole cells array.\n    // [node ID] -> true\n    this._nodes = {};\n    // `_edges` is useful for quick lookup of all the links in the graph, without\n    // having to go through the whole cells array.\n    // [edgeId] -> true\n    this._edges = {};\n    this._batches = {};\n    cells.on('add', this._restructureOnAdd, this);\n    cells.on('remove', this._restructureOnRemove, this);\n    cells.on('reset', this._restructureOnReset, this);\n    cells.on('change:source', this._restructureOnChangeSource, this);\n    cells.on('change:target', this._restructureOnChangeTarget, this);\n    cells.on('remove', this._removeCell, this);\n  },\n  _sortOnChangeZ: function () {\n    this.get('cells').sort();\n  },\n  _restructureOnAdd: function (cell) {\n    if (cell.isLink()) {\n      this._edges[cell.id] = true;\n      var {\n        source,\n        target\n      } = cell.attributes;\n      if (source.id) {\n        (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n      }\n      if (target.id) {\n        (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n      }\n    } else {\n      this._nodes[cell.id] = true;\n    }\n  },\n  _restructureOnRemove: function (cell) {\n    if (cell.isLink()) {\n      delete this._edges[cell.id];\n      var {\n        source,\n        target\n      } = cell.attributes;\n      if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n        delete this._out[source.id][cell.id];\n      }\n      if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n        delete this._in[target.id][cell.id];\n      }\n    } else {\n      delete this._nodes[cell.id];\n    }\n  },\n  _restructureOnReset: function (cells) {\n    // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\n    cells = cells.models;\n    this._out = {};\n    this._in = {};\n    this._nodes = {};\n    this._edges = {};\n    cells.forEach(this._restructureOnAdd, this);\n  },\n  _restructureOnChangeSource: function (link) {\n    var prevSource = link.previous('source');\n    if (prevSource.id && this._out[prevSource.id]) {\n      delete this._out[prevSource.id][link.id];\n    }\n    var source = link.attributes.source;\n    if (source.id) {\n      (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n    }\n  },\n  _restructureOnChangeTarget: function (link) {\n    var prevTarget = link.previous('target');\n    if (prevTarget.id && this._in[prevTarget.id]) {\n      delete this._in[prevTarget.id][link.id];\n    }\n    var target = link.get('target');\n    if (target.id) {\n      (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n    }\n  },\n  // Return all outbound edges for the node. Return value is an object\n  // of the form: [edgeId] -> true\n  getOutboundEdges: function (node) {\n    return this._out && this._out[node] || {};\n  },\n  // Return all inbound edges for the node. Return value is an object\n  // of the form: [edgeId] -> true\n  getInboundEdges: function (node) {\n    return this._in && this._in[node] || {};\n  },\n  toJSON: function () {\n    // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\n    // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n    var json = Backbone.Model.prototype.toJSON.apply(this, arguments);\n    json.cells = this.get('cells').toJSON();\n    return json;\n  },\n  fromJSON: function (json, opt) {\n    if (!json.cells) {\n      throw new Error('Graph JSON must contain cells array.');\n    }\n    return this.set(json, opt);\n  },\n  set: function (key, val, opt) {\n    var attrs;\n\n    // Handle both `key`, value and {key: value} style arguments.\n    if (typeof key === 'object') {\n      attrs = key;\n      opt = val;\n    } else {\n      (attrs = {})[key] = val;\n    }\n\n    // Make sure that `cells` attribute is handled separately via resetCells().\n    if (attrs.hasOwnProperty('cells')) {\n      this.resetCells(attrs.cells, opt);\n      attrs = util.omit(attrs, 'cells');\n    }\n\n    // The rest of the attributes are applied via original set method.\n    return Backbone.Model.prototype.set.call(this, attrs, opt);\n  },\n  clear: function (opt) {\n    opt = util.assign({}, opt, {\n      clear: true\n    });\n    var collection = this.get('cells');\n    if (collection.length === 0) return this;\n    this.startBatch('clear', opt);\n\n    // The elements come after the links.\n    var cells = collection.sortBy(function (cell) {\n      return cell.isLink() ? 1 : 2;\n    });\n    do {\n      // Remove all the cells one by one.\n      // Note that all the links are removed first, so it's\n      // safe to remove the elements without removing the connected\n      // links first.\n      cells.shift().remove(opt);\n    } while (cells.length > 0);\n    this.stopBatch('clear');\n    return this;\n  },\n  _prepareCell: function (cell, opt) {\n    var attrs;\n    if (cell instanceof Backbone.Model) {\n      attrs = cell.attributes;\n      if (!cell.graph && (!opt || !opt.dry)) {\n        // An element can not be member of more than one graph.\n        // A cell stops being the member of the graph after it's explicitly removed.\n        cell.graph = this;\n      }\n    } else {\n      // In case we're dealing with a plain JS object, we have to set the reference\n      // to the `graph` right after the actual model is created. This happens in the `model()` function\n      // of `joint.dia.GraphCells`.\n      attrs = cell;\n    }\n    if (!util.isString(attrs.type)) {\n      throw new TypeError('dia.Graph: cell type must be a string.');\n    }\n    return cell;\n  },\n  minZIndex: function () {\n    var firstCell = this.get('cells').first();\n    return firstCell ? firstCell.get('z') || 0 : 0;\n  },\n  maxZIndex: function () {\n    var lastCell = this.get('cells').last();\n    return lastCell ? lastCell.get('z') || 0 : 0;\n  },\n  addCell: function (cell, opt) {\n    if (Array.isArray(cell)) {\n      return this.addCells(cell, opt);\n    }\n    if (cell instanceof Backbone.Model) {\n      if (!cell.has('z')) {\n        cell.set('z', this.maxZIndex() + 1);\n      }\n    } else if (cell.z === undefined) {\n      cell.z = this.maxZIndex() + 1;\n    }\n    this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n    return this;\n  },\n  addCells: function (cells, opt) {\n    if (cells.length === 0) return this;\n    cells = util.flattenDeep(cells);\n    opt.maxPosition = opt.position = cells.length - 1;\n    this.startBatch('add', opt);\n    cells.forEach(function (cell) {\n      this.addCell(cell, opt);\n      opt.position--;\n    }, this);\n    this.stopBatch('add', opt);\n    return this;\n  },\n  // When adding a lot of cells, it is much more efficient to\n  // reset the entire cells collection in one go.\n  // Useful for bulk operations and optimizations.\n  resetCells: function (cells, opt) {\n    var preparedCells = util.toArray(cells).map(function (cell) {\n      return this._prepareCell(cell, opt);\n    }, this);\n    this.get('cells').reset(preparedCells, opt);\n    return this;\n  },\n  removeCells: function (cells, opt) {\n    if (cells.length) {\n      this.startBatch('remove');\n      util.invoke(cells, 'remove', opt);\n      this.stopBatch('remove');\n    }\n    return this;\n  },\n  _removeCell: function (cell, collection, options) {\n    options = options || {};\n    if (!options.clear) {\n      // Applications might provide a `disconnectLinks` option set to `true` in order to\n      // disconnect links when a cell is removed rather then removing them. The default\n      // is to remove all the associated links.\n      if (options.disconnectLinks) {\n        this.disconnectLinks(cell, options);\n      } else {\n        this.removeLinks(cell, options);\n      }\n    }\n    // Silently remove the cell from the cells collection. Silently, because\n    // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n    // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n    // would be triggered on the graph model.\n    this.get('cells').remove(cell, {\n      silent: true\n    });\n    if (cell.graph === this) {\n      // Remove the element graph reference only if the cell is the member of this graph.\n      cell.graph = null;\n    }\n  },\n  // Get a cell by `id`.\n  getCell: function (id) {\n    return this.get('cells').get(id);\n  },\n  getCells: function () {\n    return this.get('cells').toArray();\n  },\n  getElements: function () {\n    return this.get('cells').filter(cell => cell.isElement());\n  },\n  getLinks: function () {\n    return this.get('cells').filter(cell => cell.isLink());\n  },\n  getFirstCell: function () {\n    return this.get('cells').first();\n  },\n  getLastCell: function () {\n    return this.get('cells').last();\n  },\n  // Get all inbound and outbound links connected to the cell `model`.\n  getConnectedLinks: function (model, opt) {\n    opt = opt || {};\n    var indirect = opt.indirect;\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    }\n\n    // the final array of connected link models\n    var links = [];\n    // a hash table of connected edges of the form: [edgeId] -> true\n    // used for quick lookups to check if we already added a link\n    var edges = {};\n    if (outbound) {\n      addOutbounds(this, model);\n    }\n    if (inbound) {\n      addInbounds(this, model);\n    }\n    function addOutbounds(graph, model) {\n      util.forIn(graph.getOutboundEdges(model.id), function (_, edge) {\n        // skip links that were already added\n        // (those must be self-loop links)\n        // (because they are inbound and outbound edges of the same two elements)\n        if (edges[edge]) return;\n        var link = graph.getCell(edge);\n        links.push(link);\n        edges[edge] = true;\n        if (indirect) {\n          if (inbound) addInbounds(graph, link);\n          if (outbound) addOutbounds(graph, link);\n        }\n      }.bind(graph));\n      if (indirect && model.isLink()) {\n        var outCell = model.getTargetCell();\n        if (outCell && outCell.isLink()) {\n          if (!edges[outCell.id]) {\n            links.push(outCell);\n            addOutbounds(graph, outCell);\n          }\n        }\n      }\n    }\n    function addInbounds(graph, model) {\n      util.forIn(graph.getInboundEdges(model.id), function (_, edge) {\n        // skip links that were already added\n        // (those must be self-loop links)\n        // (because they are inbound and outbound edges of the same two elements)\n        if (edges[edge]) return;\n        var link = graph.getCell(edge);\n        links.push(link);\n        edges[edge] = true;\n        if (indirect) {\n          if (inbound) addInbounds(graph, link);\n          if (outbound) addOutbounds(graph, link);\n        }\n      }.bind(graph));\n      if (indirect && model.isLink()) {\n        var inCell = model.getSourceCell();\n        if (inCell && inCell.isLink()) {\n          if (!edges[inCell.id]) {\n            links.push(inCell);\n            addInbounds(graph, inCell);\n          }\n        }\n      }\n    }\n\n    // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n    if (opt.deep) {\n      var embeddedCells = model.getEmbeddedCells({\n        deep: true\n      });\n\n      // in the first round, we collect all the embedded elements\n      var embeddedElements = {};\n      embeddedCells.forEach(function (cell) {\n        if (cell.isElement()) {\n          embeddedElements[cell.id] = true;\n        }\n      });\n      embeddedCells.forEach(function (cell) {\n        if (cell.isLink()) return;\n        if (outbound) {\n          util.forIn(this.getOutboundEdges(cell.id), function (exists, edge) {\n            if (!edges[edge]) {\n              var edgeCell = this.getCell(edge);\n              var {\n                source,\n                target\n              } = edgeCell.attributes;\n              var sourceId = source.id;\n              var targetId = target.id;\n\n              // if `includeEnclosed` option is falsy, skip enclosed links\n              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n                return;\n              }\n              links.push(this.getCell(edge));\n              edges[edge] = true;\n            }\n          }.bind(this));\n        }\n        if (inbound) {\n          util.forIn(this.getInboundEdges(cell.id), function (exists, edge) {\n            if (!edges[edge]) {\n              var edgeCell = this.getCell(edge);\n              var {\n                source,\n                target\n              } = edgeCell.attributes;\n              var sourceId = source.id;\n              var targetId = target.id;\n\n              // if `includeEnclosed` option is falsy, skip enclosed links\n              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n                return;\n              }\n              links.push(this.getCell(edge));\n              edges[edge] = true;\n            }\n          }.bind(this));\n        }\n      }, this);\n    }\n    return links;\n  },\n  getNeighbors: function (model, opt) {\n    opt || (opt = {});\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    }\n    var neighbors = this.getConnectedLinks(model, opt).reduce(function (res, link) {\n      var {\n        source,\n        target\n      } = link.attributes;\n      var loop = link.hasLoop(opt);\n\n      // Discard if it is a point, or if the neighbor was already added.\n      if (inbound && util.has(source, 'id') && !res[source.id]) {\n        var sourceElement = this.getCell(source.id);\n        if (sourceElement.isElement()) {\n          if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) {\n            res[source.id] = sourceElement;\n          }\n        }\n      }\n\n      // Discard if it is a point, or if the neighbor was already added.\n      if (outbound && util.has(target, 'id') && !res[target.id]) {\n        var targetElement = this.getCell(target.id);\n        if (targetElement.isElement()) {\n          if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) {\n            res[target.id] = targetElement;\n          }\n        }\n      }\n      return res;\n    }.bind(this), {});\n    if (model.isLink()) {\n      if (inbound) {\n        var sourceCell = model.getSourceCell();\n        if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n          neighbors[sourceCell.id] = sourceCell;\n        }\n      }\n      if (outbound) {\n        var targetCell = model.getTargetCell();\n        if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n          neighbors[targetCell.id] = targetCell;\n        }\n      }\n    }\n    return util.toArray(neighbors);\n  },\n  getCommonAncestor: function /* cells */\n  () {\n    var cellsAncestors = Array.from(arguments).map(function (cell) {\n      var ancestors = [];\n      var parentId = cell.get('parent');\n      while (parentId) {\n        ancestors.push(parentId);\n        parentId = this.getCell(parentId).get('parent');\n      }\n      return ancestors;\n    }, this);\n    cellsAncestors = cellsAncestors.sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var commonAncestor = util.toArray(cellsAncestors.shift()).find(function (ancestor) {\n      return cellsAncestors.every(function (cellAncestors) {\n        return cellAncestors.includes(ancestor);\n      });\n    });\n    return this.getCell(commonAncestor);\n  },\n  // Find the whole branch starting at `element`.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n  getSuccessors: function (element, opt) {\n    opt = opt || {};\n    var res = [];\n    // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n    this.search(element, function (el) {\n      if (el !== element) {\n        res.push(el);\n      }\n    }, util.assign({}, opt, {\n      outbound: true\n    }));\n    return res;\n  },\n  cloneCells: cloneCells,\n  // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n  // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n  // Return a map of the form: [original cell ID] -> [clone].\n  cloneSubgraph: function (cells, opt) {\n    var subgraph = this.getSubgraph(cells, opt);\n    return this.cloneCells(subgraph);\n  },\n  // Return `cells` and all the connected links that connect cells in the `cells` array.\n  // If `opt.deep` is `true`, return all the cells including all their embedded cells\n  // and all the links that connect any of the returned cells.\n  // For example, for a single shallow element, the result is that very same element.\n  // For two elements connected with a link: `A --- L ---> B`, the result for\n  // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n  getSubgraph: function (cells, opt) {\n    opt = opt || {};\n    var subgraph = [];\n    // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n    var cellMap = {};\n    var elements = [];\n    var links = [];\n    util.toArray(cells).forEach(function (cell) {\n      if (!cellMap[cell.id]) {\n        subgraph.push(cell);\n        cellMap[cell.id] = cell;\n        if (cell.isLink()) {\n          links.push(cell);\n        } else {\n          elements.push(cell);\n        }\n      }\n      if (opt.deep) {\n        var embeds = cell.getEmbeddedCells({\n          deep: true\n        });\n        embeds.forEach(function (embed) {\n          if (!cellMap[embed.id]) {\n            subgraph.push(embed);\n            cellMap[embed.id] = embed;\n            if (embed.isLink()) {\n              links.push(embed);\n            } else {\n              elements.push(embed);\n            }\n          }\n        });\n      }\n    });\n    links.forEach(function (link) {\n      // For links, return their source & target (if they are elements - not points).\n      var {\n        source,\n        target\n      } = link.attributes;\n      if (source.id && !cellMap[source.id]) {\n        var sourceElement = this.getCell(source.id);\n        subgraph.push(sourceElement);\n        cellMap[sourceElement.id] = sourceElement;\n        elements.push(sourceElement);\n      }\n      if (target.id && !cellMap[target.id]) {\n        var targetElement = this.getCell(target.id);\n        subgraph.push(this.getCell(target.id));\n        cellMap[targetElement.id] = targetElement;\n        elements.push(targetElement);\n      }\n    }, this);\n    elements.forEach(function (element) {\n      // For elements, include their connected links if their source/target is in the subgraph;\n      var links = this.getConnectedLinks(element, opt);\n      links.forEach(function (link) {\n        var {\n          source,\n          target\n        } = link.attributes;\n        if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n          subgraph.push(link);\n          cellMap[link.id] = link;\n        }\n      });\n    }, this);\n    return subgraph;\n  },\n  // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n  getPredecessors: function (element, opt) {\n    opt = opt || {};\n    var res = [];\n    // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n    this.search(element, function (el) {\n      if (el !== element) {\n        res.push(el);\n      }\n    }, util.assign({}, opt, {\n      inbound: true\n    }));\n    return res;\n  },\n  // Perform search on the graph.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n  // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // `iteratee` is a function of the form `function(element) {}`.\n  // If `iteratee` explicitly returns `false`, the searching stops.\n  search: function (element, iteratee, opt) {\n    opt = opt || {};\n    if (opt.breadthFirst) {\n      this.bfs(element, iteratee, opt);\n    } else {\n      this.dfs(element, iteratee, opt);\n    }\n  },\n  // Breadth-first search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n  // `iteratee` is a function of the form `function(element, distance) {}`.\n  // where `element` is the currently visited element and `distance` is the distance of that element\n  // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n  // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n  // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n  // If `iteratee` explicitly returns `false`, the searching stops.\n  bfs: function (element, iteratee, opt = {}) {\n    const visited = {};\n    const distance = {};\n    const queue = [];\n    queue.push(element);\n    distance[element.id] = 0;\n    while (queue.length > 0) {\n      var next = queue.shift();\n      if (visited[next.id]) continue;\n      visited[next.id] = true;\n      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n      const neighbors = this.getNeighbors(next, opt);\n      for (let i = 0, n = neighbors.length; i < n; i++) {\n        const neighbor = neighbors[i];\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.push(neighbor);\n      }\n    }\n  },\n  // Depth-first search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n  // `iteratee` is a function of the form `function(element, distance) {}`.\n  // If `iteratee` explicitly returns `false`, the search stops.\n  dfs: function (element, iteratee, opt = {}) {\n    const visited = {};\n    const distance = {};\n    const queue = [];\n    queue.push(element);\n    distance[element.id] = 0;\n    while (queue.length > 0) {\n      const next = queue.pop();\n      if (visited[next.id]) continue;\n      visited[next.id] = true;\n      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n      const neighbors = this.getNeighbors(next, opt);\n      const lastIndex = queue.length;\n      for (let i = 0, n = neighbors.length; i < n; i++) {\n        const neighbor = neighbors[i];\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.splice(lastIndex, 0, neighbor);\n      }\n    }\n  },\n  // Get all the roots of the graph. Time complexity: O(|V|).\n  getSources: function () {\n    var sources = [];\n    util.forIn(this._nodes, function (exists, node) {\n      if (!this._in[node] || util.isEmpty(this._in[node])) {\n        sources.push(this.getCell(node));\n      }\n    }.bind(this));\n    return sources;\n  },\n  // Get all the leafs of the graph. Time complexity: O(|V|).\n  getSinks: function () {\n    var sinks = [];\n    util.forIn(this._nodes, function (exists, node) {\n      if (!this._out[node] || util.isEmpty(this._out[node])) {\n        sinks.push(this.getCell(node));\n      }\n    }.bind(this));\n    return sinks;\n  },\n  // Return `true` if `element` is a root. Time complexity: O(1).\n  isSource: function (element) {\n    return !this._in[element.id] || util.isEmpty(this._in[element.id]);\n  },\n  // Return `true` if `element` is a leaf. Time complexity: O(1).\n  isSink: function (element) {\n    return !this._out[element.id] || util.isEmpty(this._out[element.id]);\n  },\n  // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n  isSuccessor: function (elementA, elementB) {\n    var isSuccessor = false;\n    this.search(elementA, function (element) {\n      if (element === elementB && element !== elementA) {\n        isSuccessor = true;\n        return false;\n      }\n    }, {\n      outbound: true\n    });\n    return isSuccessor;\n  },\n  // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n  isPredecessor: function (elementA, elementB) {\n    var isPredecessor = false;\n    this.search(elementA, function (element) {\n      if (element === elementB && element !== elementA) {\n        isPredecessor = true;\n        return false;\n      }\n    }, {\n      inbound: true\n    });\n    return isPredecessor;\n  },\n  // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n  // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n  // for more details.\n  // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n  // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n  isNeighbor: function (elementA, elementB, opt) {\n    opt = opt || {};\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    }\n    var isNeighbor = false;\n    this.getConnectedLinks(elementA, opt).forEach(function (link) {\n      var {\n        source,\n        target\n      } = link.attributes;\n\n      // Discard if it is a point.\n      if (inbound && util.has(source, 'id') && source.id === elementB.id) {\n        isNeighbor = true;\n        return false;\n      }\n\n      // Discard if it is a point, or if the neighbor was already added.\n      if (outbound && util.has(target, 'id') && target.id === elementB.id) {\n        isNeighbor = true;\n        return false;\n      }\n    });\n    return isNeighbor;\n  },\n  // Disconnect links connected to the cell `model`.\n  disconnectLinks: function (model, opt) {\n    this.getConnectedLinks(model).forEach(function (link) {\n      link.set(link.attributes.source.id === model.id ? 'source' : 'target', {\n        x: 0,\n        y: 0\n      }, opt);\n    });\n  },\n  // Remove links connected to the cell `model` completely.\n  removeLinks: function (model, opt) {\n    util.invoke(this.getConnectedLinks(model), 'remove', opt);\n  },\n  // Find all elements at given point\n  findModelsFromPoint: function (p) {\n    return this.getElements().filter(el => el.getBBox({\n      rotate: true\n    }).containsPoint(p));\n  },\n  // Find all elements in given area\n  findModelsInArea: function (rect, opt = {}) {\n    const r = new g.Rect(rect);\n    const {\n      strict = false\n    } = opt;\n    const method = strict ? 'containsRect' : 'intersect';\n    return this.getElements().filter(el => r[method](el.getBBox({\n      rotate: true\n    })));\n  },\n  // Find all elements under the given element.\n  findModelsUnderElement: function (element, opt = {}) {\n    const {\n      searchBy = 'bbox'\n    } = opt;\n    const bbox = element.getBBox().rotateAroundCenter(element.angle());\n    const elements = searchBy === 'bbox' ? this.findModelsInArea(bbox) : this.findModelsFromPoint(util.getRectPoint(bbox, searchBy));\n    // don't account element itself or any of its descendants\n    return elements.filter(el => element.id !== el.id && !el.isEmbeddedIn(element));\n  },\n  // Return bounding box of all elements.\n  getBBox: function () {\n    return this.getCellsBBox(this.getCells());\n  },\n  // Return the bounding box of all cells in array provided.\n  getCellsBBox: function (cells, opt = {}) {\n    const {\n      rotate = true\n    } = opt;\n    return util.toArray(cells).reduce(function (memo, cell) {\n      const rect = cell.getBBox({\n        rotate\n      });\n      if (!rect) return memo;\n      if (memo) {\n        return memo.union(rect);\n      }\n      return rect;\n    }, null);\n  },\n  translate: function (dx, dy, opt) {\n    // Don't translate cells that are embedded in any other cell.\n    var cells = this.getCells().filter(function (cell) {\n      return !cell.isEmbedded();\n    });\n    util.invoke(cells, 'translate', dx, dy, opt);\n    return this;\n  },\n  resize: function (width, height, opt) {\n    return this.resizeCells(width, height, this.getCells(), opt);\n  },\n  resizeCells: function (width, height, cells, opt) {\n    // `getBBox` method returns `null` if no elements provided.\n    // i.e. cells can be an array of links\n    var bbox = this.getCellsBBox(cells);\n    if (bbox) {\n      var sx = Math.max(width / bbox.width, 0);\n      var sy = Math.max(height / bbox.height, 0);\n      util.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n    }\n    return this;\n  },\n  startBatch: function (name, data) {\n    data = data || {};\n    this._batches[name] = (this._batches[name] || 0) + 1;\n    return this.trigger('batch:start', util.assign({}, data, {\n      batchName: name\n    }));\n  },\n  stopBatch: function (name, data) {\n    data = data || {};\n    this._batches[name] = (this._batches[name] || 0) - 1;\n    return this.trigger('batch:stop', util.assign({}, data, {\n      batchName: name\n    }));\n  },\n  hasActiveBatch: function (name) {\n    const batches = this._batches;\n    let names;\n    if (arguments.length === 0) {\n      names = Object.keys(batches);\n    } else if (Array.isArray(name)) {\n      names = name;\n    } else {\n      names = [name];\n    }\n    return names.some(batch => batches[batch] > 0);\n  }\n}, {\n  validations: {\n    multiLinks: function (graph, link) {\n      // Do not allow multiple links to have the same source and target.\n      var {\n        source,\n        target\n      } = link.attributes;\n      if (source.id && target.id) {\n        var sourceModel = link.getSourceCell();\n        if (sourceModel) {\n          var connectedLinks = graph.getConnectedLinks(sourceModel, {\n            outbound: true\n          });\n          var sameLinks = connectedLinks.filter(function (_link) {\n            var {\n              source: _source,\n              target: _target\n            } = _link.attributes;\n            return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);\n          });\n          if (sameLinks.length > 1) {\n            return false;\n          }\n        }\n      }\n      return true;\n    },\n    linkPinning: function (_graph, link) {\n      var {\n        source,\n        target\n      } = link.attributes;\n      return source.id && target.id;\n    }\n  }\n});\nwrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);","map":{"version":3,"names":["Backbone","util","g","Link","Element","wrappers","wrapWith","cloneCells","GraphCells","Collection","extend","initialize","models","opt","cellNamespace","joint","has","shapes","graph","model","attrs","collection","namespace","ModelClass","type","getByPath","cell","dry","comparator","get","Graph","Model","cells","cellModel","prototype","set","call","on","trigger","_sortOnChangeZ","_out","_in","_nodes","_edges","_batches","_restructureOnAdd","_restructureOnRemove","_restructureOnReset","_restructureOnChangeSource","_restructureOnChangeTarget","_removeCell","sort","isLink","id","source","target","attributes","forEach","link","prevSource","previous","prevTarget","getOutboundEdges","node","getInboundEdges","toJSON","json","apply","arguments","fromJSON","Error","key","val","hasOwnProperty","resetCells","omit","clear","assign","length","startBatch","sortBy","shift","remove","stopBatch","_prepareCell","isString","TypeError","minZIndex","firstCell","first","maxZIndex","lastCell","last","addCell","Array","isArray","addCells","z","undefined","add","flattenDeep","maxPosition","position","preparedCells","toArray","map","reset","removeCells","invoke","options","disconnectLinks","removeLinks","silent","getCell","getCells","getElements","filter","isElement","getLinks","getFirstCell","getLastCell","getConnectedLinks","indirect","inbound","outbound","links","edges","addOutbounds","addInbounds","forIn","_","edge","push","bind","outCell","getTargetCell","inCell","getSourceCell","deep","embeddedCells","getEmbeddedCells","embeddedElements","exists","edgeCell","sourceId","targetId","includeEnclosed","getNeighbors","neighbors","reduce","res","loop","hasLoop","sourceElement","isEmbeddedIn","targetElement","sourceCell","targetCell","getCommonAncestor","cellsAncestors","from","ancestors","parentId","a","b","commonAncestor","find","ancestor","every","cellAncestors","includes","getSuccessors","element","search","el","cloneSubgraph","subgraph","getSubgraph","cellMap","elements","embeds","embed","getPredecessors","iteratee","breadthFirst","bfs","dfs","visited","distance","queue","next","i","n","neighbor","pop","lastIndex","splice","getSources","sources","isEmpty","getSinks","sinks","isSource","isSink","isSuccessor","elementA","elementB","isPredecessor","isNeighbor","x","y","findModelsFromPoint","p","getBBox","rotate","containsPoint","findModelsInArea","rect","r","Rect","strict","method","findModelsUnderElement","searchBy","bbox","rotateAroundCenter","angle","getRectPoint","getCellsBBox","memo","union","translate","dx","dy","isEmbedded","resize","width","height","resizeCells","sx","Math","max","sy","origin","name","data","batchName","hasActiveBatch","batches","names","Object","keys","some","batch","validations","multiLinks","sourceModel","connectedLinks","sameLinks","_link","_source","_target","port","linkPinning","_graph"],"sources":["/Users/lijiaxin/Documents/workspace/hydsoft-oms-frontend/node_modules/jointjs/src/dia/Graph.mjs"],"sourcesContent":["import Backbone from 'backbone';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nimport { Link } from './Link.mjs';\nimport { Element } from './Element.mjs';\nimport { wrappers, wrapWith } from '../util/wrappers.mjs';\nimport { cloneCells } from '../util/index.mjs';\n\nconst GraphCells = Backbone.Collection.extend({\n\n    initialize: function(models, opt) {\n\n        // Set the optional namespace where all model classes are defined.\n        if (opt.cellNamespace) {\n            this.cellNamespace = opt.cellNamespace;\n        } else {\n            /* eslint-disable no-undef */\n            this.cellNamespace = typeof joint !== 'undefined' && util.has(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n\n        this.graph = opt.graph;\n    },\n\n    model: function(attrs, opt) {\n\n        var collection = opt.collection;\n        var namespace = collection.cellNamespace;\n\n        // Find the model class in the namespace or use the default one.\n        var ModelClass = (attrs.type === 'link')\n            ? Link\n            : util.getByPath(namespace, attrs.type, '.') || Element;\n\n        var cell = new ModelClass(attrs, opt);\n        // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n        // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n        if (!opt.dry) {\n            cell.graph = collection.graph;\n        }\n\n        return cell;\n    },\n\n    // `comparator` makes it easy to sort cells based on their `z` index.\n    comparator: function(model) {\n\n        return model.get('z') || 0;\n    }\n});\n\n\nexport const Graph = Backbone.Model.extend({\n\n    initialize: function(attrs, opt) {\n\n        opt = opt || {};\n\n        // Passing `cellModel` function in the options object to graph allows for\n        // setting models based on attribute objects. This is especially handy\n        // when processing JSON graphs that are in a different than JointJS format.\n        var cells = new GraphCells([], {\n            model: opt.cellModel,\n            cellNamespace: opt.cellNamespace,\n            graph: this\n        });\n        Backbone.Model.prototype.set.call(this, 'cells', cells);\n\n        // Make all the events fired in the `cells` collection available.\n        // to the outside world.\n        cells.on('all', this.trigger, this);\n\n        // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\n        // they're already in the collection. Therefore, we're triggering sort manually here.\n        this.on('change:z', this._sortOnChangeZ, this);\n\n        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n        // for fast graph queries. All changes that affect the structure of the graph\n        // must be reflected in the `al` object. This object provides fast answers to\n        // questions such as \"what are the neighbours of this node\" or \"what\n        // are the sibling links of this link\".\n\n        // Outgoing edges per node. Note that we use a hash-table for the list\n        // of outgoing edges for a faster lookup.\n        // [nodeId] -> Object [edgeId] -> true\n        this._out = {};\n        // Ingoing edges per node.\n        // [nodeId] -> Object [edgeId] -> true\n        this._in = {};\n        // `_nodes` is useful for quick lookup of all the elements in the graph, without\n        // having to go through the whole cells array.\n        // [node ID] -> true\n        this._nodes = {};\n        // `_edges` is useful for quick lookup of all the links in the graph, without\n        // having to go through the whole cells array.\n        // [edgeId] -> true\n        this._edges = {};\n\n        this._batches = {};\n\n        cells.on('add', this._restructureOnAdd, this);\n        cells.on('remove', this._restructureOnRemove, this);\n        cells.on('reset', this._restructureOnReset, this);\n        cells.on('change:source', this._restructureOnChangeSource, this);\n        cells.on('change:target', this._restructureOnChangeTarget, this);\n        cells.on('remove', this._removeCell, this);\n    },\n\n    _sortOnChangeZ: function() {\n\n        this.get('cells').sort();\n    },\n\n    _restructureOnAdd: function(cell) {\n\n        if (cell.isLink()) {\n            this._edges[cell.id] = true;\n            var { source, target } = cell.attributes;\n            if (source.id) {\n                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n            }\n            if (target.id) {\n                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n            }\n        } else {\n            this._nodes[cell.id] = true;\n        }\n    },\n\n    _restructureOnRemove: function(cell) {\n\n        if (cell.isLink()) {\n            delete this._edges[cell.id];\n            var { source, target } = cell.attributes;\n            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n                delete this._out[source.id][cell.id];\n            }\n            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n                delete this._in[target.id][cell.id];\n            }\n        } else {\n            delete this._nodes[cell.id];\n        }\n    },\n\n    _restructureOnReset: function(cells) {\n\n        // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\n        cells = cells.models;\n\n        this._out = {};\n        this._in = {};\n        this._nodes = {};\n        this._edges = {};\n\n        cells.forEach(this._restructureOnAdd, this);\n    },\n\n    _restructureOnChangeSource: function(link) {\n\n        var prevSource = link.previous('source');\n        if (prevSource.id && this._out[prevSource.id]) {\n            delete this._out[prevSource.id][link.id];\n        }\n        var source = link.attributes.source;\n        if (source.id) {\n            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n        }\n    },\n\n    _restructureOnChangeTarget: function(link) {\n\n        var prevTarget = link.previous('target');\n        if (prevTarget.id && this._in[prevTarget.id]) {\n            delete this._in[prevTarget.id][link.id];\n        }\n        var target = link.get('target');\n        if (target.id) {\n            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n        }\n    },\n\n    // Return all outbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getOutboundEdges: function(node) {\n\n        return (this._out && this._out[node]) || {};\n    },\n\n    // Return all inbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getInboundEdges: function(node) {\n\n        return (this._in && this._in[node]) || {};\n    },\n\n    toJSON: function() {\n\n        // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\n        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n        var json = Backbone.Model.prototype.toJSON.apply(this, arguments);\n        json.cells = this.get('cells').toJSON();\n        return json;\n    },\n\n    fromJSON: function(json, opt) {\n\n        if (!json.cells) {\n\n            throw new Error('Graph JSON must contain cells array.');\n        }\n\n        return this.set(json, opt);\n    },\n\n    set: function(key, val, opt) {\n\n        var attrs;\n\n        // Handle both `key`, value and {key: value} style arguments.\n        if (typeof key === 'object') {\n            attrs = key;\n            opt = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        // Make sure that `cells` attribute is handled separately via resetCells().\n        if (attrs.hasOwnProperty('cells')) {\n            this.resetCells(attrs.cells, opt);\n            attrs = util.omit(attrs, 'cells');\n        }\n\n        // The rest of the attributes are applied via original set method.\n        return Backbone.Model.prototype.set.call(this, attrs, opt);\n    },\n\n    clear: function(opt) {\n\n        opt = util.assign({}, opt, { clear: true });\n\n        var collection = this.get('cells');\n\n        if (collection.length === 0) return this;\n\n        this.startBatch('clear', opt);\n\n        // The elements come after the links.\n        var cells = collection.sortBy(function(cell) {\n            return cell.isLink() ? 1 : 2;\n        });\n\n        do {\n\n            // Remove all the cells one by one.\n            // Note that all the links are removed first, so it's\n            // safe to remove the elements without removing the connected\n            // links first.\n            cells.shift().remove(opt);\n\n        } while (cells.length > 0);\n\n        this.stopBatch('clear');\n\n        return this;\n    },\n\n    _prepareCell: function(cell, opt) {\n\n        var attrs;\n        if (cell instanceof Backbone.Model) {\n            attrs = cell.attributes;\n            if (!cell.graph && (!opt || !opt.dry)) {\n                // An element can not be member of more than one graph.\n                // A cell stops being the member of the graph after it's explicitly removed.\n                cell.graph = this;\n            }\n        } else {\n            // In case we're dealing with a plain JS object, we have to set the reference\n            // to the `graph` right after the actual model is created. This happens in the `model()` function\n            // of `joint.dia.GraphCells`.\n            attrs = cell;\n        }\n\n        if (!util.isString(attrs.type)) {\n            throw new TypeError('dia.Graph: cell type must be a string.');\n        }\n\n        return cell;\n    },\n\n    minZIndex: function() {\n\n        var firstCell = this.get('cells').first();\n        return firstCell ? (firstCell.get('z') || 0) : 0;\n    },\n\n    maxZIndex: function() {\n\n        var lastCell = this.get('cells').last();\n        return lastCell ? (lastCell.get('z') || 0) : 0;\n    },\n\n    addCell: function(cell, opt) {\n\n        if (Array.isArray(cell)) {\n\n            return this.addCells(cell, opt);\n        }\n\n        if (cell instanceof Backbone.Model) {\n\n            if (!cell.has('z')) {\n                cell.set('z', this.maxZIndex() + 1);\n            }\n\n        } else if (cell.z === undefined) {\n\n            cell.z = this.maxZIndex() + 1;\n        }\n\n        this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n\n        return this;\n    },\n\n    addCells: function(cells, opt) {\n\n        if (cells.length === 0) return this;\n\n        cells = util.flattenDeep(cells);\n        opt.maxPosition = opt.position = cells.length - 1;\n\n        this.startBatch('add', opt);\n        cells.forEach(function(cell) {\n            this.addCell(cell, opt);\n            opt.position--;\n        }, this);\n        this.stopBatch('add', opt);\n\n        return this;\n    },\n\n    // When adding a lot of cells, it is much more efficient to\n    // reset the entire cells collection in one go.\n    // Useful for bulk operations and optimizations.\n    resetCells: function(cells, opt) {\n\n        var preparedCells = util.toArray(cells).map(function(cell) {\n            return this._prepareCell(cell, opt);\n        }, this);\n        this.get('cells').reset(preparedCells, opt);\n\n        return this;\n    },\n\n    removeCells: function(cells, opt) {\n\n        if (cells.length) {\n\n            this.startBatch('remove');\n            util.invoke(cells, 'remove', opt);\n            this.stopBatch('remove');\n        }\n\n        return this;\n    },\n\n    _removeCell: function(cell, collection, options) {\n\n        options = options || {};\n\n        if (!options.clear) {\n            // Applications might provide a `disconnectLinks` option set to `true` in order to\n            // disconnect links when a cell is removed rather then removing them. The default\n            // is to remove all the associated links.\n            if (options.disconnectLinks) {\n\n                this.disconnectLinks(cell, options);\n\n            } else {\n\n                this.removeLinks(cell, options);\n            }\n        }\n        // Silently remove the cell from the cells collection. Silently, because\n        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n        // would be triggered on the graph model.\n        this.get('cells').remove(cell, { silent: true });\n\n        if (cell.graph === this) {\n            // Remove the element graph reference only if the cell is the member of this graph.\n            cell.graph = null;\n        }\n    },\n\n    // Get a cell by `id`.\n    getCell: function(id) {\n\n        return this.get('cells').get(id);\n    },\n\n    getCells: function() {\n\n        return this.get('cells').toArray();\n    },\n\n    getElements: function() {\n\n        return this.get('cells').filter(cell => cell.isElement());\n    },\n\n    getLinks: function() {\n\n        return this.get('cells').filter(cell => cell.isLink());\n    },\n\n    getFirstCell: function() {\n\n        return this.get('cells').first();\n    },\n\n    getLastCell: function() {\n\n        return this.get('cells').last();\n    },\n\n    // Get all inbound and outbound links connected to the cell `model`.\n    getConnectedLinks: function(model, opt) {\n\n        opt = opt || {};\n\n        var indirect = opt.indirect;\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        // the final array of connected link models\n        var links = [];\n        // a hash table of connected edges of the form: [edgeId] -> true\n        // used for quick lookups to check if we already added a link\n        var edges = {};\n\n        if (outbound) {\n            addOutbounds(this, model);\n        }\n        if (inbound) {\n            addInbounds(this, model);\n        }\n\n        function addOutbounds(graph, model) {\n            util.forIn(graph.getOutboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var outCell = model.getTargetCell();\n                if (outCell && outCell.isLink()) {\n                    if (!edges[outCell.id]) {\n                        links.push(outCell);\n                        addOutbounds(graph, outCell);\n                    }\n                }\n            }\n        }\n\n        function addInbounds(graph, model) {\n            util.forIn(graph.getInboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var inCell = model.getSourceCell();\n                if (inCell && inCell.isLink()) {\n                    if (!edges[inCell.id]) {\n                        links.push(inCell);\n                        addInbounds(graph, inCell);\n                    }\n                }\n            }\n        }\n\n        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n        if (opt.deep) {\n\n            var embeddedCells = model.getEmbeddedCells({ deep: true });\n\n            // in the first round, we collect all the embedded elements\n            var embeddedElements = {};\n            embeddedCells.forEach(function(cell) {\n                if (cell.isElement()) {\n                    embeddedElements[cell.id] = true;\n                }\n            });\n\n            embeddedCells.forEach(function(cell) {\n                if (cell.isLink()) return;\n                if (outbound) {\n                    util.forIn(this.getOutboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n                if (inbound) {\n                    util.forIn(this.getInboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n            }, this);\n        }\n\n        return links;\n    },\n\n    getNeighbors: function(model, opt) {\n\n        opt || (opt = {});\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if (inbound === undefined && outbound === undefined) {\n            inbound = outbound = true;\n        }\n\n        var neighbors = this.getConnectedLinks(model, opt).reduce(function(res, link) {\n\n            var { source, target } = link.attributes;\n            var loop = link.hasLoop(opt);\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (inbound && util.has(source, 'id') && !res[source.id]) {\n\n                var sourceElement = this.getCell(source.id);\n                if (sourceElement.isElement()) {\n                    if (loop || (sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model)))) {\n                        res[source.id] = sourceElement;\n                    }\n                }\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && util.has(target, 'id') && !res[target.id]) {\n\n                var targetElement = this.getCell(target.id);\n                if (targetElement.isElement()) {\n                    if (loop || (targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model)))) {\n                        res[target.id] = targetElement;\n                    }\n                }\n            }\n\n            return res;\n        }.bind(this), {});\n\n        if (model.isLink()) {\n            if (inbound) {\n                var sourceCell = model.getSourceCell();\n                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n                    neighbors[sourceCell.id] = sourceCell;\n                }\n            }\n            if (outbound) {\n                var targetCell = model.getTargetCell();\n                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n                    neighbors[targetCell.id] = targetCell;\n                }\n            }\n        }\n\n        return util.toArray(neighbors);\n    },\n\n    getCommonAncestor: function(/* cells */) {\n\n        var cellsAncestors = Array.from(arguments).map(function(cell) {\n\n            var ancestors = [];\n            var parentId = cell.get('parent');\n\n            while (parentId) {\n\n                ancestors.push(parentId);\n                parentId = this.getCell(parentId).get('parent');\n            }\n\n            return ancestors;\n\n        }, this);\n\n        cellsAncestors = cellsAncestors.sort(function(a, b) {\n            return a.length - b.length;\n        });\n\n        var commonAncestor = util.toArray(cellsAncestors.shift()).find(function(ancestor) {\n            return cellsAncestors.every(function(cellAncestors) {\n                return cellAncestors.includes(ancestor);\n            });\n        });\n\n        return this.getCell(commonAncestor);\n    },\n\n    // Find the whole branch starting at `element`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getSuccessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, util.assign({}, opt, { outbound: true }));\n        return res;\n    },\n\n    cloneCells: cloneCells,\n    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n    // Return a map of the form: [original cell ID] -> [clone].\n    cloneSubgraph: function(cells, opt) {\n\n        var subgraph = this.getSubgraph(cells, opt);\n        return this.cloneCells(subgraph);\n    },\n\n    // Return `cells` and all the connected links that connect cells in the `cells` array.\n    // If `opt.deep` is `true`, return all the cells including all their embedded cells\n    // and all the links that connect any of the returned cells.\n    // For example, for a single shallow element, the result is that very same element.\n    // For two elements connected with a link: `A --- L ---> B`, the result for\n    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n    getSubgraph: function(cells, opt) {\n\n        opt = opt || {};\n\n        var subgraph = [];\n        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n        var cellMap = {};\n        var elements = [];\n        var links = [];\n\n        util.toArray(cells).forEach(function(cell) {\n            if (!cellMap[cell.id]) {\n                subgraph.push(cell);\n                cellMap[cell.id] = cell;\n                if (cell.isLink()) {\n                    links.push(cell);\n                } else {\n                    elements.push(cell);\n                }\n            }\n\n            if (opt.deep) {\n                var embeds = cell.getEmbeddedCells({ deep: true });\n                embeds.forEach(function(embed) {\n                    if (!cellMap[embed.id]) {\n                        subgraph.push(embed);\n                        cellMap[embed.id] = embed;\n                        if (embed.isLink()) {\n                            links.push(embed);\n                        } else {\n                            elements.push(embed);\n                        }\n                    }\n                });\n            }\n        });\n\n        links.forEach(function(link) {\n            // For links, return their source & target (if they are elements - not points).\n            var { source, target } = link.attributes;\n            if (source.id && !cellMap[source.id]) {\n                var sourceElement = this.getCell(source.id);\n                subgraph.push(sourceElement);\n                cellMap[sourceElement.id] = sourceElement;\n                elements.push(sourceElement);\n            }\n            if (target.id && !cellMap[target.id]) {\n                var targetElement = this.getCell(target.id);\n                subgraph.push(this.getCell(target.id));\n                cellMap[targetElement.id] = targetElement;\n                elements.push(targetElement);\n            }\n        }, this);\n\n        elements.forEach(function(element) {\n            // For elements, include their connected links if their source/target is in the subgraph;\n            var links = this.getConnectedLinks(element, opt);\n            links.forEach(function(link) {\n                var { source, target } = link.attributes;\n                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n                    subgraph.push(link);\n                    cellMap[link.id] = link;\n                }\n            });\n        }, this);\n\n        return subgraph;\n    },\n\n    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getPredecessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, util.assign({}, opt, { inbound: true }));\n        return res;\n    },\n\n    // Perform search on the graph.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // `iteratee` is a function of the form `function(element) {}`.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    search: function(element, iteratee, opt) {\n\n        opt = opt || {};\n        if (opt.breadthFirst) {\n            this.bfs(element, iteratee, opt);\n        } else {\n            this.dfs(element, iteratee, opt);\n        }\n    },\n\n    // Breadth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // where `element` is the currently visited element and `distance` is the distance of that element\n    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    bfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            var next = queue.shift();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.push(neighbor);\n            }\n        }\n    },\n\n    // Depth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // If `iteratee` explicitly returns `false`, the search stops.\n    dfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            const next = queue.pop();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            const lastIndex = queue.length;\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.splice(lastIndex, 0, neighbor);\n            }\n        }\n    },\n\n    // Get all the roots of the graph. Time complexity: O(|V|).\n    getSources: function() {\n\n        var sources = [];\n        util.forIn(this._nodes, function(exists, node) {\n            if (!this._in[node] || util.isEmpty(this._in[node])) {\n                sources.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sources;\n    },\n\n    // Get all the leafs of the graph. Time complexity: O(|V|).\n    getSinks: function() {\n\n        var sinks = [];\n        util.forIn(this._nodes, function(exists, node) {\n            if (!this._out[node] || util.isEmpty(this._out[node])) {\n                sinks.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sinks;\n    },\n\n    // Return `true` if `element` is a root. Time complexity: O(1).\n    isSource: function(element) {\n\n        return !this._in[element.id] || util.isEmpty(this._in[element.id]);\n    },\n\n    // Return `true` if `element` is a leaf. Time complexity: O(1).\n    isSink: function(element) {\n\n        return !this._out[element.id] || util.isEmpty(this._out[element.id]);\n    },\n\n    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n    isSuccessor: function(elementA, elementB) {\n\n        var isSuccessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isSuccessor = true;\n                return false;\n            }\n        }, { outbound: true });\n        return isSuccessor;\n    },\n\n    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n    isPredecessor: function(elementA, elementB) {\n\n        var isPredecessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isPredecessor = true;\n                return false;\n            }\n        }, { inbound: true });\n        return isPredecessor;\n    },\n\n    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n    // for more details.\n    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n    isNeighbor: function(elementA, elementB, opt) {\n\n        opt = opt || {};\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        var isNeighbor = false;\n\n        this.getConnectedLinks(elementA, opt).forEach(function(link) {\n\n            var { source, target } = link.attributes;\n\n            // Discard if it is a point.\n            if (inbound && util.has(source, 'id') && (source.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && util.has(target, 'id') && (target.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n        });\n\n        return isNeighbor;\n    },\n\n    // Disconnect links connected to the cell `model`.\n    disconnectLinks: function(model, opt) {\n\n        this.getConnectedLinks(model).forEach(function(link) {\n\n            link.set((link.attributes.source.id === model.id ? 'source' : 'target'), { x: 0, y: 0 }, opt);\n        });\n    },\n\n    // Remove links connected to the cell `model` completely.\n    removeLinks: function(model, opt) {\n\n        util.invoke(this.getConnectedLinks(model), 'remove', opt);\n    },\n\n    // Find all elements at given point\n    findModelsFromPoint: function(p) {\n        return this.getElements().filter(el => el.getBBox({ rotate: true }).containsPoint(p));\n    },\n\n    // Find all elements in given area\n    findModelsInArea: function(rect, opt = {}) {\n        const r = new g.Rect(rect);\n        const { strict = false } = opt;\n        const method = strict ? 'containsRect' : 'intersect';\n        return this.getElements().filter(el => r[method](el.getBBox({ rotate: true })));\n    },\n\n    // Find all elements under the given element.\n    findModelsUnderElement: function(element, opt = {}) {\n        const { searchBy = 'bbox' } = opt;\n        const bbox = element.getBBox().rotateAroundCenter(element.angle());\n        const elements = (searchBy === 'bbox')\n            ? this.findModelsInArea(bbox)\n            : this.findModelsFromPoint(util.getRectPoint(bbox, searchBy));\n        // don't account element itself or any of its descendants\n        return elements.filter(el => element.id !== el.id && !el.isEmbeddedIn(element));\n    },\n\n    // Return bounding box of all elements.\n    getBBox: function() {\n\n        return this.getCellsBBox(this.getCells());\n    },\n\n    // Return the bounding box of all cells in array provided.\n    getCellsBBox: function(cells, opt = {}) {\n        const { rotate = true } = opt;\n        return util.toArray(cells).reduce(function(memo, cell) {\n            const rect = cell.getBBox({ rotate });\n            if (!rect) return memo;\n            if (memo) {\n                return memo.union(rect);\n            }\n            return rect;\n        }, null);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        // Don't translate cells that are embedded in any other cell.\n        var cells = this.getCells().filter(function(cell) {\n            return !cell.isEmbedded();\n        });\n\n        util.invoke(cells, 'translate', dx, dy, opt);\n\n        return this;\n    },\n\n    resize: function(width, height, opt) {\n\n        return this.resizeCells(width, height, this.getCells(), opt);\n    },\n\n    resizeCells: function(width, height, cells, opt) {\n\n        // `getBBox` method returns `null` if no elements provided.\n        // i.e. cells can be an array of links\n        var bbox = this.getCellsBBox(cells);\n        if (bbox) {\n            var sx = Math.max(width / bbox.width, 0);\n            var sy = Math.max(height / bbox.height, 0);\n            util.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n        }\n\n        return this;\n    },\n\n    startBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) + 1;\n\n        return this.trigger('batch:start', util.assign({}, data, { batchName: name }));\n    },\n\n    stopBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) - 1;\n\n        return this.trigger('batch:stop', util.assign({}, data, { batchName: name }));\n    },\n\n    hasActiveBatch: function(name) {\n\n        const batches = this._batches;\n        let names;\n\n        if (arguments.length === 0) {\n            names = Object.keys(batches);\n        } else if (Array.isArray(name)) {\n            names = name;\n        } else {\n            names = [name];\n        }\n\n        return names.some((batch) => batches[batch] > 0);\n    }\n\n}, {\n\n    validations: {\n\n        multiLinks: function(graph, link) {\n\n            // Do not allow multiple links to have the same source and target.\n            var { source, target } = link.attributes;\n\n            if (source.id && target.id) {\n\n                var sourceModel = link.getSourceCell();\n                if (sourceModel) {\n\n                    var connectedLinks = graph.getConnectedLinks(sourceModel, { outbound: true });\n                    var sameLinks = connectedLinks.filter(function(_link) {\n\n                        var { source: _source, target: _target } = _link.attributes;\n                        return _source && _source.id === source.id &&\n                            (!_source.port || (_source.port === source.port)) &&\n                            _target && _target.id === target.id &&\n                            (!_target.port || (_target.port === target.port));\n\n                    });\n\n                    if (sameLinks.length > 1) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        },\n\n        linkPinning: function(_graph, link) {\n            var { source, target } = link.attributes;\n            return source.id && target.id;\n        }\n    }\n\n});\n\nwrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}