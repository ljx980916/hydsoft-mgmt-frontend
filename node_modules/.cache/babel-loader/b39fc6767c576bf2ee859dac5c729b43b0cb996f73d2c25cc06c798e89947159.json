{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport V from '../V/index.mjs';\nimport { isNumber, assign, nextFrame, isObject, cancelFrame, defaults, defaultsDeep, addClassNamePrefix, normalizeSides, isFunction, isPlainObject, getByPath, sortElements, isString, guid, normalizeEvent, normalizeWheel, cap, debounce, omit, result, merge, camelCase, cloneDeep, invoke, hashCode, filter as _filter, parseDOMJSON, toArray, has } from '../util/index.mjs';\nimport { Rect, Point, toRad } from '../g/index.mjs';\nimport { View, views } from '../mvc/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { ElementView } from './ElementView.mjs';\nimport { LinkView } from './LinkView.mjs';\nimport { Link } from './Link.mjs';\nimport { Cell } from './Cell.mjs';\nimport { Graph } from './Graph.mjs';\nimport { LayersNames, PaperLayer } from './PaperLayer.mjs';\nimport * as highlighters from '../highlighters/index.mjs';\nimport * as linkAnchors from '../linkAnchors/index.mjs';\nimport * as connectionPoints from '../connectionPoints/index.mjs';\nimport * as anchors from '../anchors/index.mjs';\nimport $ from 'jquery';\nimport Backbone from 'backbone';\nconst sortingTypes = {\n  NONE: 'sorting-none',\n  APPROX: 'sorting-approximate',\n  EXACT: 'sorting-exact'\n};\nconst WHEEL_CAP = 50;\nconst WHEEL_WAIT_MS = 20;\nconst MOUNT_BATCH_SIZE = 1000;\nconst UPDATE_BATCH_SIZE = Infinity;\nconst MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\nconst HighlightingTypes = CellView.Highlighting;\nconst defaultHighlighting = {\n  [HighlightingTypes.DEFAULT]: {\n    name: 'stroke',\n    options: {\n      padding: 3\n    }\n  },\n  [HighlightingTypes.MAGNET_AVAILABILITY]: {\n    name: 'addClass',\n    options: {\n      className: 'available-magnet'\n    }\n  },\n  [HighlightingTypes.ELEMENT_AVAILABILITY]: {\n    name: 'addClass',\n    options: {\n      className: 'available-cell'\n    }\n  }\n};\nconst defaultLayers = [{\n  name: LayersNames.BACK\n}, {\n  name: LayersNames.CELLS\n}, {\n  name: LayersNames.LABELS\n}, {\n  name: LayersNames.FRONT\n}, {\n  name: LayersNames.TOOLS\n}];\nexport const Paper = View.extend({\n  className: 'paper',\n  options: {\n    width: 800,\n    height: 600,\n    origin: {\n      x: 0,\n      y: 0\n    },\n    // x,y coordinates in top-left corner\n    gridSize: 1,\n    // Whether or not to draw the grid lines on the paper's DOM element.\n    // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n    drawGrid: false,\n    // If not set, the size of the visual grid is the same as the `gridSize`.\n    drawGridSize: null,\n    // Whether or not to draw the background on the paper's DOM element.\n    // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n    background: false,\n    perpendicularLinks: false,\n    elementView: ElementView,\n    linkView: LinkView,\n    snapLabels: false,\n    // false, true\n    snapLinks: false,\n    // false, true, { radius: value }\n    snapLinksSelf: false,\n    // false, true, { radius: value }\n\n    // Should the link labels be rendered into its own layer?\n    // `false` - the labels are part of the links\n    // `true` - the labels are appended to LayersName.LABELS\n    // [LayersName] - the labels are appended to the layer specified\n    labelsLayer: false,\n    // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n    multiLinks: true,\n    // For adding custom guard logic.\n    guard: function (evt, view) {\n      // FALSE means the event isn't guarded.\n      return false;\n    },\n    highlighting: defaultHighlighting,\n    // Prevent the default context menu from being displayed.\n    preventContextMenu: true,\n    // Prevent the default action for blank:pointer<action>.\n    preventDefaultBlankAction: true,\n    // Prevent the default action for cell:pointer<action>.\n    preventDefaultViewAction: true,\n    // Restrict the translation of elements by given bounding box.\n    // Option accepts a boolean:\n    //  true - the translation is restricted to the paper area\n    //  false - no restrictions\n    // A method:\n    // restrictTranslate: function(elementView) {\n    //     var parentId = elementView.model.get('parent');\n    //     return parentId && this.model.getCell(parentId).getBBox();\n    // },\n    // Or a bounding box:\n    // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n    restrictTranslate: false,\n    // Marks all available magnets with 'available-magnet' class name and all available cells with\n    // 'available-cell' class name. Marks them when dragging a link is started and unmark\n    // when the dragging is stopped.\n    markAvailable: false,\n    // Defines what link model is added to the graph after an user clicks on an active magnet.\n    // Value could be the Backbone.model or a function returning the Backbone.model\n    // defaultLink: function(elementView, magnet) { return condition ? new customLink1() : new customLink2() }\n    defaultLink: new Link(),\n    // A connector that is used by links with no connector defined on the model.\n    // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n    defaultConnector: {\n      name: 'normal'\n    },\n    // A router that is used by links with no router defined on the model.\n    // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n    defaultRouter: {\n      name: 'normal'\n    },\n    defaultAnchor: {\n      name: 'center'\n    },\n    defaultLinkAnchor: {\n      name: 'connectionRatio'\n    },\n    defaultConnectionPoint: {\n      name: 'bbox'\n    },\n    /* CONNECTING */\n\n    connectionStrategy: null,\n    // Check whether to add a new link to the graph when user clicks on an a magnet.\n    validateMagnet: function (_cellView, magnet, _evt) {\n      return magnet.getAttribute('magnet') !== 'passive';\n    },\n    // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n    // being changed.\n    validateConnection: function (cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n      return (end === 'target' ? cellViewT : cellViewS) instanceof ElementView;\n    },\n    /* EMBEDDING */\n\n    // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n    // all links and elements are visible taken the level of embedding into account.\n    embeddingMode: false,\n    // Check whether to allow or disallow the element embedding while an element being translated.\n    validateEmbedding: function (childView, parentView) {\n      // by default all elements can be in relation child-parent\n      return true;\n    },\n    // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n    validateUnembedding: function (childView) {\n      // by default all elements can become roots\n      return true;\n    },\n    // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n    // The cell with the highest z-index (visually on the top) will be chosen.\n    findParentBy: 'bbox',\n    // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n    // If enabled only the element on the very front is taken into account for the embedding.\n    // If disabled the elements under the dragged view are tested one by one\n    // (from front to back) until a valid parent found.\n    frontParentOnly: true,\n    // Interactive flags. See online docs for the complete list of interactive flags.\n    interactive: {\n      labelMove: false\n    },\n    // When set to true the links can be pinned to the paper.\n    // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n    linkPinning: true,\n    // Custom validation after an interaction with a link ends.\n    // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n    // (linkView, paper) => boolean\n    allowLink: null,\n    // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n    clickThreshold: 0,\n    // Number of required mousemove events before the first pointermove event will be triggered.\n    moveThreshold: 0,\n    // Number of required mousemove events before a link is created out of the magnet.\n    // Or string `onleave` so the link is created when the pointer leaves the magnet\n    magnetThreshold: 0,\n    // Rendering Options\n\n    sorting: sortingTypes.EXACT,\n    frozen: false,\n    autoFreeze: false,\n    // no docs yet\n    onViewUpdate: function (view, flag, priority, opt, paper) {\n      // Do not update connected links when:\n      // 1. the view was just inserted (added to the graph and rendered)\n      // 2. the view was just mounted (added back to the paper by viewport function)\n      // 3. the change was marked as `isolate`.\n      // 4. the view model was just removed from the graph\n      if (flag & (view.FLAG_INSERT | view.FLAG_REMOVE) || opt.mounting || opt.isolate) return;\n      paper.requestConnectedLinksUpdate(view, priority, opt);\n    },\n    // no docs yet\n    onViewPostponed: function (view, flag, paper) {\n      return paper.forcePostponedViewUpdate(view, flag);\n    },\n    beforeRender: null,\n    // function(opt, paper) { },\n\n    afterRender: null,\n    // function(stats, opt, paper) {\n\n    viewport: null,\n    // Default namespaces\n\n    cellViewNamespace: null,\n    routerNamespace: null,\n    connectorNamespace: null,\n    highlighterNamespace: highlighters,\n    anchorNamespace: anchors,\n    linkAnchorNamespace: linkAnchors,\n    connectionPointNamespace: connectionPoints,\n    overflow: false\n  },\n  events: {\n    'dblclick': 'pointerdblclick',\n    'dbltap': 'pointerdblclick',\n    'contextmenu': 'contextmenu',\n    'mousedown': 'pointerdown',\n    'touchstart': 'pointerdown',\n    'mouseover': 'mouseover',\n    'mouseout': 'mouseout',\n    'mouseenter': 'mouseenter',\n    'mouseleave': 'mouseleave',\n    'wheel': 'mousewheel',\n    'mouseenter .joint-cell': 'mouseenter',\n    'mouseleave .joint-cell': 'mouseleave',\n    'mouseenter .joint-tools': 'mouseenter',\n    'mouseleave .joint-tools': 'mouseleave',\n    'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n    'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n    'mousedown .joint-link .label': 'onlabel',\n    // interaction with link label\n    'touchstart .joint-link .label': 'onlabel',\n    'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n  },\n\n  documentEvents: {\n    'mousemove': 'pointermove',\n    'touchmove': 'pointermove',\n    'mouseup': 'pointerup',\n    'touchend': 'pointerup',\n    'touchcancel': 'pointerup'\n  },\n  svg: null,\n  viewport: null,\n  defs: null,\n  tools: null,\n  $background: null,\n  layers: null,\n  $grid: null,\n  $document: null,\n  // For storing the current transformation matrix (CTM) of the paper's viewport.\n  _viewportMatrix: null,\n  // For verifying whether the CTM is up-to-date. The viewport transform attribute\n  // could have been manipulated directly.\n  _viewportTransformString: null,\n  // Updates data (priorities, unmounted views etc.)\n  _updates: null,\n  // Paper Layers\n  _layers: null,\n  SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n  UPDATE_DELAYING_BATCHES: ['translate'],\n  // If you interact with these elements,\n  // the default interaction such as `element move` is prevented.\n  FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'],\n  // If you interact with these elements, the events are not propagated to the paper\n  // i.e. paper events such as `element:pointerdown` are not triggered.\n  GUARDED_TAG_NAMES: [\n  // Guard <select> for consistency. When you click on it:\n  // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n  // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n  //          on close. However, if you open and then close by clicking elsewhere on the page,\n  //           no other event is triggered.\n  // Safari: when you open it, it triggers `pointerdown`. That's it.\n  'SELECT'],\n  MIN_SCALE: 1e-6,\n  init: function () {\n    const {\n      options,\n      el\n    } = this;\n    if (!options.cellViewNamespace) {\n      /* eslint-disable no-undef */\n      options.cellViewNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;\n      /* eslint-enable no-undef */\n    }\n\n    const model = this.model = options.model || new Graph();\n\n    // Layers (SVGGroups)\n    this._layers = {};\n    this.setGrid(options.drawGrid);\n    this.cloneOptions();\n    this.render();\n    this._setDimensions();\n    this.startListening();\n\n    // Hash of all cell views.\n    this._views = {};\n\n    // Mouse wheel events buffer\n    this._mw_evt_buffer = {\n      event: null,\n      deltas: []\n    };\n\n    // Reference to the paper owner document\n    this.$document = $(el.ownerDocument);\n    // Render existing cells in the graph\n    this.resetViews(model.attributes.cells.models);\n    // Start the Rendering Loop\n    if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();\n  },\n  _resetUpdates: function () {\n    return this._updates = {\n      id: null,\n      priorities: [{}, {}, {}],\n      unmountedCids: [],\n      mountedCids: [],\n      unmounted: {},\n      mounted: {},\n      count: 0,\n      keyFrozen: false,\n      freezeKey: null,\n      sort: false,\n      disabled: false,\n      idle: false\n    };\n  },\n  startListening: function () {\n    var model = this.model;\n    this.listenTo(model, 'add', this.onCellAdded).listenTo(model, 'remove', this.onCellRemoved).listenTo(model, 'change', this.onCellChange).listenTo(model, 'reset', this.onGraphReset).listenTo(model, 'sort', this.onGraphSort).listenTo(model, 'batch:stop', this.onGraphBatchStop);\n    this.on('cell:highlight', this.onCellHighlight).on('cell:unhighlight', this.onCellUnhighlight).on('scale translate', this.update);\n  },\n  onCellAdded: function (cell, _, opt) {\n    var position = opt.position;\n    if (this.isAsync() || !isNumber(position)) {\n      this.renderView(cell, opt);\n    } else {\n      if (opt.maxPosition === position) this.freeze({\n        key: 'addCells'\n      });\n      this.renderView(cell, opt);\n      if (position === 0) this.unfreeze({\n        key: 'addCells'\n      });\n    }\n  },\n  onCellRemoved: function (cell, _, opt) {\n    const view = this.findViewByModel(cell);\n    if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);\n  },\n  onCellChange: function (cell, opt) {\n    if (cell === this.model.attributes.cells) return;\n    if (cell.hasChanged('z') && this.options.sorting === sortingTypes.APPROX) {\n      const view = this.findViewByModel(cell);\n      if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);\n    }\n  },\n  onGraphReset: function (collection, opt) {\n    this.resetLayers();\n    this.resetViews(collection.models, opt);\n  },\n  onGraphSort: function () {\n    if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n    this.sortViews();\n  },\n  onGraphBatchStop: function (data) {\n    if (this.isFrozen()) return;\n    var name = data && data.batchName;\n    var graph = this.model;\n    if (!this.isAsync()) {\n      var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n      if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n        this.updateViews(data);\n      }\n    }\n    var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n    if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {\n      this.sortViews();\n    }\n  },\n  cloneOptions: function () {\n    const {\n      options\n    } = this;\n    const {\n      defaultConnector,\n      defaultRouter,\n      defaultConnectionPoint,\n      defaultAnchor,\n      defaultLinkAnchor,\n      origin,\n      highlighting,\n      cellViewNamespace,\n      interactive\n    } = options;\n\n    // Default cellView namespace for ES5\n    /* eslint-disable no-undef */\n    if (!cellViewNamespace && typeof joint !== 'undefined' && has(joint, 'shapes')) {\n      options.cellViewNamespace = joint.shapes;\n    }\n    /* eslint-enable no-undef */\n\n    // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n    // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n    if (!isFunction(defaultConnector)) {\n      options.defaultConnector = cloneDeep(defaultConnector);\n    }\n    if (!isFunction(defaultRouter)) {\n      options.defaultRouter = cloneDeep(defaultRouter);\n    }\n    if (!isFunction(defaultConnectionPoint)) {\n      options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);\n    }\n    if (!isFunction(defaultAnchor)) {\n      options.defaultAnchor = cloneDeep(defaultAnchor);\n    }\n    if (!isFunction(defaultLinkAnchor)) {\n      options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);\n    }\n    if (isPlainObject(interactive)) {\n      options.interactive = assign({}, interactive);\n    }\n    if (isPlainObject(highlighting)) {\n      // Return the default highlighting options into the user specified options.\n      options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);\n    }\n    options.origin = assign({}, origin);\n  },\n  children: function () {\n    var ns = V.namespace;\n    return [{\n      namespaceURI: ns.xhtml,\n      tagName: 'div',\n      className: addClassNamePrefix('paper-background'),\n      selector: 'background'\n    }, {\n      namespaceURI: ns.xhtml,\n      tagName: 'div',\n      className: addClassNamePrefix('paper-grid'),\n      selector: 'grid'\n    }, {\n      namespaceURI: ns.svg,\n      tagName: 'svg',\n      attributes: {\n        'width': '100%',\n        'height': '100%',\n        'xmlns:xlink': ns.xlink\n      },\n      selector: 'svg',\n      children: [{\n        // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n        // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n        tagName: 'defs',\n        selector: 'defs'\n      }, {\n        tagName: 'g',\n        className: addClassNamePrefix('layers'),\n        selector: 'layers'\n      }]\n    }];\n  },\n  hasLayerView(layerName) {\n    return layerName in this._layers;\n  },\n  getLayerView(layerName) {\n    const {\n      _layers\n    } = this;\n    if (layerName in _layers) return _layers[layerName];\n    throw new Error(`dia.Paper: Unknown layer \"${layerName}\"`);\n  },\n  getLayerNode(layerName) {\n    return this.getLayerView(layerName).el;\n  },\n  render: function () {\n    this.renderChildren();\n    const {\n      childNodes,\n      options\n    } = this;\n    const {\n      svg,\n      defs,\n      layers,\n      background,\n      grid\n    } = childNodes;\n    svg.style.overflow = options.overflow ? 'visible' : 'hidden';\n    this.svg = svg;\n    this.defs = defs;\n    this.layers = layers;\n    this.$background = $(background);\n    this.$grid = $(grid);\n    this.renderLayers();\n    V.ensureId(svg);\n    if (options.background) {\n      this.drawBackground(options.background);\n    }\n    if (options.drawGrid) {\n      this.drawGrid();\n    }\n    return this;\n  },\n  renderLayers: function (layers = defaultLayers) {\n    this.removeLayers();\n    // TODO: Layers to be read from the graph `layers` attribute\n    layers.forEach(({\n      name,\n      sorted\n    }) => {\n      const layerView = new PaperLayer({\n        name\n      });\n      this.layers.appendChild(layerView.el);\n      this._layers[name] = layerView;\n    });\n    // Throws an exception if doesn't exist\n    const cellsLayerView = this.getLayerView(LayersNames.CELLS);\n    const toolsLayerView = this.getLayerView(LayersNames.TOOLS);\n    const labelsLayerView = this.getLayerView(LayersNames.LABELS);\n    // backwards compatibility\n    this.tools = toolsLayerView.el;\n    this.cells = this.viewport = cellsLayerView.el;\n    // user-select: none;\n    cellsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n    labelsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n  },\n  removeLayers: function () {\n    const {\n      _layers\n    } = this;\n    Object.keys(_layers).forEach(name => {\n      _layers[name].remove();\n      delete _layers[name];\n    });\n  },\n  resetLayers: function () {\n    const {\n      _layers\n    } = this;\n    Object.keys(_layers).forEach(name => {\n      _layers[name].removePivots();\n    });\n  },\n  update: function () {\n    if (this.options.drawGrid) {\n      this.drawGrid();\n    }\n    if (this._background) {\n      this.updateBackgroundImage(this._background);\n    }\n    return this;\n  },\n  matrix: function (ctm) {\n    var viewport = this.layers;\n\n    // Getter:\n    if (ctm === undefined) {\n      var transformString = viewport.getAttribute('transform');\n      if ((this._viewportTransformString || null) === transformString) {\n        // It's ok to return the cached matrix. The transform attribute has not changed since\n        // the matrix was stored.\n        ctm = this._viewportMatrix;\n      } else {\n        // The viewport transform attribute has changed. Measure the matrix and cache again.\n        ctm = viewport.getCTM();\n        this._viewportMatrix = ctm;\n        this._viewportTransformString = transformString;\n      }\n\n      // Clone the cached current transformation matrix.\n      // If no matrix previously stored the identity matrix is returned.\n      return V.createSVGMatrix(ctm);\n    }\n\n    // Setter:\n    ctm = V.createSVGMatrix(ctm);\n    var ctmString = V.matrixToTransformString(ctm);\n    viewport.setAttribute('transform', ctmString);\n    this._viewportMatrix = ctm;\n    this._viewportTransformString = viewport.getAttribute('transform');\n    return this;\n  },\n  clientMatrix: function () {\n    return V.createSVGMatrix(this.cells.getScreenCTM());\n  },\n  requestConnectedLinksUpdate: function (view, priority, opt) {\n    if (view instanceof CellView) {\n      var model = view.model;\n      var links = this.model.getConnectedLinks(model);\n      for (var j = 0, n = links.length; j < n; j++) {\n        var link = links[j];\n        var linkView = this.findViewByModel(link);\n        if (!linkView) continue;\n        var flagLabels = ['UPDATE'];\n        if (link.getTargetCell() === model) flagLabels.push('TARGET');\n        if (link.getSourceCell() === model) flagLabels.push('SOURCE');\n        var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n        this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n      }\n    }\n  },\n  forcePostponedViewUpdate: function (view, flag) {\n    if (!view || !(view instanceof CellView)) return false;\n    var model = view.model;\n    if (model.isElement()) return false;\n    if ((flag & view.getFlag(['SOURCE', 'TARGET'])) === 0) {\n      var dumpOptions = {\n        silent: true\n      };\n      // LinkView is waiting for the target or the source cellView to be rendered\n      // This can happen when the cells are not in the viewport.\n      var sourceFlag = 0;\n      var sourceView = this.findViewByModel(model.getSourceCell());\n      if (sourceView && !this.isViewMounted(sourceView)) {\n        sourceFlag = this.dumpView(sourceView, dumpOptions);\n        view.updateEndMagnet('source');\n      }\n      var targetFlag = 0;\n      var targetView = this.findViewByModel(model.getTargetCell());\n      if (targetView && !this.isViewMounted(targetView)) {\n        targetFlag = this.dumpView(targetView, dumpOptions);\n        view.updateEndMagnet('target');\n      }\n      if (sourceFlag === 0 && targetFlag === 0) {\n        // If leftover flag is 0, all view updates were done.\n        return !this.dumpView(view, dumpOptions);\n      }\n    }\n    return false;\n  },\n  requestViewUpdate: function (view, flag, priority, opt) {\n    opt || (opt = {});\n    this.scheduleViewUpdate(view, flag, priority, opt);\n    var isAsync = this.isAsync();\n    if (this.isFrozen() || isAsync && opt.async !== false) return;\n    if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n    var stats = this.updateViews(opt);\n    if (isAsync) this.notifyAfterRender(stats, opt);\n  },\n  scheduleViewUpdate: function (view, type, priority, opt) {\n    const {\n      _updates: updates,\n      options\n    } = this;\n    if (updates.idle) {\n      if (options.autoFreeze) {\n        updates.idle = false;\n        this.unfreeze();\n      }\n    }\n    const {\n      FLAG_REMOVE,\n      FLAG_INSERT,\n      UPDATE_PRIORITY,\n      cid\n    } = view;\n    let priorityUpdates = updates.priorities[priority];\n    if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n    // Move higher priority updates to this priority\n    if (priority > UPDATE_PRIORITY) {\n      // Not the default priority for this view. It's most likely a link view\n      // connected to another link view, which triggered the update.\n      // TODO: If there is an update scheduled with a lower priority already, we should\n      // change the requested priority to the lowest one. Does not seem to be critical\n      // right now, as it \"only\" results in multiple updates on the same view.\n      for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n        const prevPriorityUpdates = updates.priorities[i];\n        if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n        priorityUpdates[cid] |= prevPriorityUpdates[cid];\n        delete prevPriorityUpdates[cid];\n      }\n    }\n    let currentType = priorityUpdates[cid] || 0;\n    // Prevent cycling\n    if ((currentType & type) === type) return;\n    if (!currentType) updates.count++;\n    if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n      // When a view is removed we need to remove the insert flag as this is a reinsert\n      priorityUpdates[cid] ^= FLAG_INSERT;\n    } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n      // When a view is added we need to remove the remove flag as this is view was previously removed\n      priorityUpdates[cid] ^= FLAG_REMOVE;\n    }\n    priorityUpdates[cid] |= type;\n    const viewUpdateFn = options.onViewUpdate;\n    if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n  },\n  dumpViewUpdate: function (view) {\n    if (!view) return 0;\n    var updates = this._updates;\n    var cid = view.cid;\n    var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n    var flag = this.registerMountedView(view) | priorityUpdates[cid];\n    delete priorityUpdates[cid];\n    return flag;\n  },\n  dumpView: function (view, opt = {}) {\n    const flag = this.dumpViewUpdate(view);\n    if (!flag) return 0;\n    const shouldNotify = !opt.silent;\n    if (shouldNotify) this.notifyBeforeRender(opt);\n    const leftover = this.updateView(view, flag, opt);\n    if (shouldNotify) {\n      const stats = {\n        updated: 1,\n        priority: view.UPDATE_PRIORITY\n      };\n      this.notifyAfterRender(stats, opt);\n    }\n    return leftover;\n  },\n  updateView: function (view, flag, opt) {\n    if (!view) return 0;\n    const {\n      FLAG_REMOVE,\n      FLAG_INSERT,\n      FLAG_INIT,\n      model\n    } = view;\n    if (view instanceof CellView) {\n      if (flag & FLAG_REMOVE) {\n        this.removeView(model);\n        return 0;\n      }\n      if (flag & FLAG_INSERT) {\n        const isInitialInsert = !!(flag & FLAG_INIT);\n        if (isInitialInsert) {\n          flag ^= FLAG_INIT;\n        }\n        this.insertView(view, isInitialInsert);\n        flag ^= FLAG_INSERT;\n      }\n    }\n    if (!flag) return 0;\n    return view.confirmUpdate(flag, opt || {});\n  },\n  requireView: function (model, opt) {\n    var view = this.findViewByModel(model);\n    if (!view) return null;\n    this.dumpView(view, opt);\n    return view;\n  },\n  registerUnmountedView: function (view) {\n    var cid = view.cid;\n    var updates = this._updates;\n    if (cid in updates.unmounted) return 0;\n    var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n    updates.unmountedCids.push(cid);\n    delete updates.mounted[cid];\n    return flag;\n  },\n  registerMountedView: function (view) {\n    var cid = view.cid;\n    var updates = this._updates;\n    if (cid in updates.mounted) return 0;\n    updates.mounted[cid] = true;\n    updates.mountedCids.push(cid);\n    var flag = updates.unmounted[cid] || 0;\n    delete updates.unmounted[cid];\n    return flag;\n  },\n  isViewMounted: function (view) {\n    if (!view) return false;\n    var cid = view.cid;\n    var updates = this._updates;\n    return cid in updates.mounted;\n  },\n  dumpViews: function (opt) {\n    var passingOpt = defaults({}, opt, {\n      viewport: null\n    });\n    this.checkViewport(passingOpt);\n    this.updateViews(passingOpt);\n  },\n  // Synchronous views update\n  updateViews: function (opt) {\n    this.notifyBeforeRender(opt);\n    let batchStats;\n    let updateCount = 0;\n    let batchCount = 0;\n    let priority = MIN_PRIORITY;\n    do {\n      batchCount++;\n      batchStats = this.updateViewsBatch(opt);\n      updateCount += batchStats.updated;\n      priority = Math.min(batchStats.priority, priority);\n    } while (!batchStats.empty);\n    const stats = {\n      updated: updateCount,\n      batches: batchCount,\n      priority\n    };\n    this.notifyAfterRender(stats, opt);\n    return stats;\n  },\n  hasScheduledUpdates: function () {\n    const priorities = this._updates.priorities;\n    const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n    let i = priorityIndexes.length;\n    while (i > 0 && i--) {\n      // a faster way how to check if an object is empty\n      for (let _key in priorities[priorityIndexes[i]]) return true;\n    }\n    return false;\n  },\n  updateViewsAsync: function (opt, data) {\n    opt || (opt = {});\n    data || (data = {\n      processed: 0,\n      priority: MIN_PRIORITY\n    });\n    const {\n      _updates: updates,\n      options\n    } = this;\n    const id = updates.id;\n    if (id) {\n      cancelFrame(id);\n      if (data.processed === 0 && this.hasScheduledUpdates()) {\n        this.notifyBeforeRender(opt);\n      }\n      const stats = this.updateViewsBatch(opt);\n      const passingOpt = defaults({}, opt, {\n        mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n        unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n      });\n      const checkStats = this.checkViewport(passingOpt);\n      const unmountCount = checkStats.unmounted;\n      const mountCount = checkStats.mounted;\n      let processed = data.processed;\n      const total = updates.count;\n      if (stats.updated > 0) {\n        // Some updates have been just processed\n        processed += stats.updated + stats.unmounted;\n        stats.processed = processed;\n        data.priority = Math.min(stats.priority, data.priority);\n        if (stats.empty && mountCount === 0) {\n          stats.unmounted += unmountCount;\n          stats.mounted += mountCount;\n          stats.priority = data.priority;\n          this.notifyAfterRender(stats, opt);\n          data.processed = 0;\n          data.priority = MIN_PRIORITY;\n          updates.count = 0;\n        } else {\n          data.processed = processed;\n        }\n      } else {\n        if (!updates.idle) {\n          if (options.autoFreeze) {\n            this.freeze();\n            updates.idle = true;\n            this.trigger('render:idle', opt);\n          }\n        }\n      }\n      // Progress callback\n      const progressFn = opt.progress;\n      if (total && typeof progressFn === 'function') {\n        progressFn.call(this, stats.empty, processed, total, stats, this);\n      }\n      // The current frame could have been canceled in a callback\n      if (updates.id !== id) return;\n    }\n    if (updates.disabled) {\n      throw new Error('dia.Paper: can not unfreeze the paper after it was removed');\n    }\n    updates.id = nextFrame(this.updateViewsAsync, this, opt, data);\n  },\n  notifyBeforeRender: function (opt = {}) {\n    let beforeFn = opt.beforeRender;\n    if (typeof beforeFn !== 'function') {\n      beforeFn = this.options.beforeRender;\n      if (typeof beforeFn !== 'function') return;\n    }\n    beforeFn.call(this, opt, this);\n  },\n  notifyAfterRender: function (stats, opt = {}) {\n    let afterFn = opt.afterRender;\n    if (typeof afterFn !== 'function') {\n      afterFn = this.options.afterRender;\n    }\n    if (typeof afterFn === 'function') {\n      afterFn.call(this, stats, opt, this);\n    }\n    this.trigger('render:done', stats, opt);\n  },\n  updateViewsBatch: function (opt) {\n    opt || (opt = {});\n    var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n    var updates = this._updates;\n    var updateCount = 0;\n    var postponeCount = 0;\n    var unmountCount = 0;\n    var mountCount = 0;\n    var maxPriority = MIN_PRIORITY;\n    var empty = true;\n    var options = this.options;\n    var priorities = updates.priorities;\n    var viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n    if (typeof viewportFn !== 'function') viewportFn = null;\n    var postponeViewFn = options.onViewPostponed;\n    if (typeof postponeViewFn !== 'function') postponeViewFn = null;\n    var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n    main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n      var priority = +priorityIndexes[i];\n      var priorityUpdates = priorities[priority];\n      for (var cid in priorityUpdates) {\n        if (updateCount >= batchSize) {\n          empty = false;\n          break main;\n        }\n        var view = views[cid];\n        if (!view) {\n          // This should not occur\n          delete priorityUpdates[cid];\n          continue;\n        }\n        var currentFlag = priorityUpdates[cid];\n        if ((currentFlag & view.FLAG_REMOVE) === 0) {\n          // We should never check a view for viewport if we are about to remove the view\n          var isDetached = (cid in updates.unmounted);\n          if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n            // Unmount View\n            if (!isDetached) {\n              this.registerUnmountedView(view);\n              this.detachView(view);\n            }\n            updates.unmounted[cid] |= currentFlag;\n            delete priorityUpdates[cid];\n            unmountCount++;\n            continue;\n          }\n          // Mount View\n          if (isDetached) {\n            currentFlag |= view.FLAG_INSERT;\n            mountCount++;\n          }\n          currentFlag |= this.registerMountedView(view);\n        }\n        var leftoverFlag = this.updateView(view, currentFlag, opt);\n        if (leftoverFlag > 0) {\n          // View update has not finished completely\n          priorityUpdates[cid] = leftoverFlag;\n          if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n            postponeCount++;\n            empty = false;\n            continue;\n          }\n        }\n        if (maxPriority > priority) maxPriority = priority;\n        updateCount++;\n        delete priorityUpdates[cid];\n      }\n    }\n    return {\n      priority: maxPriority,\n      updated: updateCount,\n      postponed: postponeCount,\n      unmounted: unmountCount,\n      mounted: mountCount,\n      empty: empty\n    };\n  },\n  getUnmountedViews: function () {\n    const updates = this._updates;\n    const unmountedCids = Object.keys(updates.unmounted);\n    const n = unmountedCids.length;\n    const unmountedViews = new Array(n);\n    for (var i = 0; i < n; i++) {\n      unmountedViews[i] = views[unmountedCids[i]];\n    }\n    return unmountedViews;\n  },\n  getMountedViews: function () {\n    const updates = this._updates;\n    const mountedCids = Object.keys(updates.mounted);\n    const n = mountedCids.length;\n    const mountedViews = new Array(n);\n    for (var i = 0; i < n; i++) {\n      mountedViews[i] = views[mountedCids[i]];\n    }\n    return mountedViews;\n  },\n  checkUnmountedViews: function (viewportFn, opt) {\n    opt || (opt = {});\n    var mountCount = 0;\n    if (typeof viewportFn !== 'function') viewportFn = null;\n    var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n    var updates = this._updates;\n    var unmountedCids = updates.unmountedCids;\n    var unmounted = updates.unmounted;\n    for (var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++) {\n      var cid = unmountedCids[i];\n      if (!(cid in unmounted)) continue;\n      var view = views[cid];\n      if (!view) continue;\n      if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n        // Push at the end of all unmounted ids, so this can be check later again\n        unmountedCids.push(cid);\n        continue;\n      }\n      mountCount++;\n      var flag = this.registerMountedView(view);\n      if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, {\n        mounting: true\n      });\n    }\n    // Get rid of views, that have been mounted\n    unmountedCids.splice(0, i);\n    return mountCount;\n  },\n  checkMountedViews: function (viewportFn, opt) {\n    opt || (opt = {});\n    var unmountCount = 0;\n    if (typeof viewportFn !== 'function') return unmountCount;\n    var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n    var updates = this._updates;\n    var mountedCids = updates.mountedCids;\n    var mounted = updates.mounted;\n    for (var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++) {\n      var cid = mountedCids[i];\n      if (!(cid in mounted)) continue;\n      var view = views[cid];\n      if (!view) continue;\n      if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n        // Push at the end of all mounted ids, so this can be check later again\n        mountedCids.push(cid);\n        continue;\n      }\n      unmountCount++;\n      var flag = this.registerUnmountedView(view);\n      if (flag) this.detachView(view);\n    }\n    // Get rid of views, that have been unmounted\n    mountedCids.splice(0, i);\n    return unmountCount;\n  },\n  checkViewVisibility: function (cellView, opt = {}) {\n    let viewportFn = 'viewport' in opt ? opt.viewport : this.options.viewport;\n    if (typeof viewportFn !== 'function') viewportFn = null;\n    const updates = this._updates;\n    const {\n      mounted,\n      unmounted\n    } = updates;\n    const visible = !cellView.DETACHABLE || !viewportFn || viewportFn.call(this, cellView, false, this);\n    let isUnmounted = false;\n    let isMounted = false;\n    if (cellView.cid in mounted && !visible) {\n      const flag = this.registerUnmountedView(cellView);\n      if (flag) this.detachView(cellView);\n      const i = updates.mountedCids.indexOf(cellView.cid);\n      updates.mountedCids.splice(i, 1);\n      isUnmounted = true;\n    }\n    if (!isUnmounted && cellView.cid in unmounted && visible) {\n      const i = updates.unmountedCids.indexOf(cellView.cid);\n      updates.unmountedCids.splice(i, 1);\n      var flag = this.registerMountedView(cellView);\n      if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {\n        mounting: true\n      });\n      isMounted = true;\n    }\n    return {\n      mounted: isMounted ? 1 : 0,\n      unmounted: isUnmounted ? 1 : 0\n    };\n  },\n  checkViewport: function (opt) {\n    var passingOpt = defaults({}, opt, {\n      mountBatchSize: Infinity,\n      unmountBatchSize: Infinity\n    });\n    var viewportFn = 'viewport' in passingOpt ? passingOpt.viewport : this.options.viewport;\n    var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n    if (unmountedCount > 0) {\n      // Do not check views, that have been just unmounted and pushed at the end of the cids array\n      var unmountedCids = this._updates.unmountedCids;\n      passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n    }\n    var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n    return {\n      mounted: mountedCount,\n      unmounted: unmountedCount\n    };\n  },\n  freeze: function (opt) {\n    opt || (opt = {});\n    var updates = this._updates;\n    var key = opt.key;\n    var isFrozen = this.options.frozen;\n    var freezeKey = updates.freezeKey;\n    if (key && key !== freezeKey) {\n      // key passed, but the paper is already freezed with another key\n      if (isFrozen && freezeKey) return;\n      updates.freezeKey = key;\n      updates.keyFrozen = isFrozen;\n    }\n    this.options.frozen = true;\n    var id = updates.id;\n    updates.id = null;\n    if (this.isAsync() && id) cancelFrame(id);\n  },\n  unfreeze: function (opt) {\n    opt || (opt = {});\n    var updates = this._updates;\n    var key = opt.key;\n    var freezeKey = updates.freezeKey;\n    // key passed, but the paper is already freezed with another key\n    if (key && freezeKey && key !== freezeKey) return;\n    updates.freezeKey = null;\n    // key passed, but the paper is already freezed\n    if (key && key === freezeKey && updates.keyFrozen) return;\n    if (this.isAsync()) {\n      this.freeze();\n      this.updateViewsAsync(opt);\n    } else {\n      this.updateViews(opt);\n    }\n    this.options.frozen = updates.keyFrozen = false;\n    if (updates.sort) {\n      this.sortViews();\n      updates.sort = false;\n    }\n  },\n  isAsync: function () {\n    return !!this.options.async;\n  },\n  isFrozen: function () {\n    return !!this.options.frozen;\n  },\n  isExactSorting: function () {\n    return this.options.sorting === sortingTypes.EXACT;\n  },\n  onRemove: function () {\n    this.freeze();\n    this._updates.disabled = true;\n    //clean up all DOM elements/views to prevent memory leaks\n    this.removeLayers();\n    this.removeViews();\n  },\n  getComputedSize: function () {\n    var options = this.options;\n    var w = options.width;\n    var h = options.height;\n    if (!isNumber(w)) w = this.el.clientWidth;\n    if (!isNumber(h)) h = this.el.clientHeight;\n    return {\n      width: w,\n      height: h\n    };\n  },\n  setDimensions: function (width, height) {\n    const {\n      options\n    } = this;\n    const {\n      width: currentWidth,\n      height: currentHeight\n    } = options;\n    let w = width === undefined ? currentWidth : width;\n    let h = height === undefined ? currentHeight : height;\n    if (currentWidth === w && currentHeight === h) return;\n    options.width = w;\n    options.height = h;\n    this._setDimensions();\n    const computedSize = this.getComputedSize();\n    this.trigger('resize', computedSize.width, computedSize.height);\n  },\n  _setDimensions: function () {\n    const {\n      options\n    } = this;\n    let w = options.width;\n    let h = options.height;\n    if (isNumber(w)) w = Math.round(w);\n    if (isNumber(h)) h = Math.round(h);\n    this.$el.css({\n      width: w === null ? '' : w,\n      height: h === null ? '' : h\n    });\n  },\n  setOrigin: function (ox, oy) {\n    return this.translate(ox || 0, oy || 0);\n  },\n  // Expand/shrink the paper to fit the content.\n  // Alternatively signature function(opt)\n  fitToContent: function (gridWidth, gridHeight, padding, opt) {\n    if (isObject(gridWidth)) {\n      // first parameter is an option object\n      opt = gridWidth;\n    } else {\n      // Support for a deprecated signature\n      opt = assign({\n        gridWidth,\n        gridHeight,\n        padding\n      }, opt);\n    }\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.getFitToContentArea(opt);\n    const {\n      sx,\n      sy\n    } = this.scale();\n    this.setOrigin(-x * sx, -y * sy);\n    this.setDimensions(width * sx, height * sy);\n    return new Rect(x, y, width, height);\n  },\n  getFitToContentArea: function (opt = {}) {\n    // Calculate the paper size to accommodate all the graph's elements.\n\n    const gridWidth = opt.gridWidth || 1;\n    const gridHeight = opt.gridHeight || 1;\n    const padding = normalizeSides(opt.padding || 0);\n    const minWidth = Math.max(opt.minWidth || 0, gridWidth);\n    const minHeight = Math.max(opt.minHeight || 0, gridHeight);\n    const maxWidth = opt.maxWidth || Number.MAX_VALUE;\n    const maxHeight = opt.maxHeight || Number.MAX_VALUE;\n    const newOrigin = opt.allowNewOrigin;\n    const area = 'contentArea' in opt ? new Rect(opt.contentArea) : this.getContentArea(opt);\n    const {\n      sx,\n      sy\n    } = this.scale();\n    area.x *= sx;\n    area.y *= sy;\n    area.width *= sx;\n    area.height *= sy;\n    let calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n    let calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n    if (!opt.allowNegativeBottomRight) {\n      calcWidth = Math.max(calcWidth, 1);\n      calcHeight = Math.max(calcHeight, 1);\n    }\n    calcWidth *= gridWidth;\n    calcHeight *= gridHeight;\n    let tx = 0;\n    if (newOrigin === 'negative' && area.x < 0 || newOrigin === 'positive' && area.x >= 0 || newOrigin === 'any') {\n      tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n      tx += padding.left;\n      calcWidth += tx;\n    }\n    let ty = 0;\n    if (newOrigin === 'negative' && area.y < 0 || newOrigin === 'positive' && area.y >= 0 || newOrigin === 'any') {\n      ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n      ty += padding.top;\n      calcHeight += ty;\n    }\n    calcWidth += padding.right;\n    calcHeight += padding.bottom;\n\n    // Make sure the resulting width and height are greater than minimum.\n    calcWidth = Math.max(calcWidth, minWidth);\n    calcHeight = Math.max(calcHeight, minHeight);\n\n    // Make sure the resulting width and height are lesser than maximum.\n    calcWidth = Math.min(calcWidth, maxWidth);\n    calcHeight = Math.min(calcHeight, maxHeight);\n    return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n  },\n  transformToFitContent: function (opt) {\n    opt || (opt = {});\n    let contentBBox, contentLocalOrigin;\n    if ('contentArea' in opt) {\n      const contentArea = opt.contentArea;\n      contentBBox = this.localToPaperRect(contentArea);\n      contentLocalOrigin = new Point(contentArea);\n    } else {\n      contentBBox = this.getContentBBox(opt);\n      contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n    }\n    if (!contentBBox.width || !contentBBox.height) return;\n    defaults(opt, {\n      padding: 0,\n      preserveAspectRatio: true,\n      scaleGrid: null,\n      minScale: 0,\n      maxScale: Number.MAX_VALUE,\n      verticalAlign: 'top',\n      horizontalAlign: 'left'\n      //minScaleX\n      //minScaleY\n      //maxScaleX\n      //maxScaleY\n      //fittingBBox\n    });\n\n    const padding = normalizeSides(opt.padding);\n    const minScaleX = opt.minScaleX || opt.minScale;\n    const maxScaleX = opt.maxScaleX || opt.maxScale;\n    const minScaleY = opt.minScaleY || opt.minScale;\n    const maxScaleY = opt.maxScaleY || opt.maxScale;\n    let fittingBBox;\n    if (opt.fittingBBox) {\n      fittingBBox = opt.fittingBBox;\n    } else {\n      const currentTranslate = this.translate();\n      const computedSize = this.getComputedSize();\n      fittingBBox = {\n        x: currentTranslate.tx,\n        y: currentTranslate.ty,\n        width: computedSize.width,\n        height: computedSize.height\n      };\n    }\n    fittingBBox = new Rect(fittingBBox).moveAndExpand({\n      x: padding.left,\n      y: padding.top,\n      width: -padding.left - padding.right,\n      height: -padding.top - padding.bottom\n    });\n    const currentScale = this.scale();\n    let newSx = fittingBBox.width / contentBBox.width * currentScale.sx;\n    let newSy = fittingBBox.height / contentBBox.height * currentScale.sy;\n    if (opt.preserveAspectRatio) {\n      newSx = newSy = Math.min(newSx, newSy);\n    }\n\n    // snap scale to a grid\n    if (opt.scaleGrid) {\n      const gridSize = opt.scaleGrid;\n      newSx = gridSize * Math.floor(newSx / gridSize);\n      newSy = gridSize * Math.floor(newSy / gridSize);\n    }\n\n    // scale min/max boundaries\n    newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n    newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n    const scaleDiff = {\n      x: newSx / currentScale.sx,\n      y: newSy / currentScale.sy\n    };\n    const origin = this.options.origin;\n    let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - origin.x;\n    let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - origin.y;\n    switch (opt.verticalAlign) {\n      case 'middle':\n        newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n        break;\n      case 'bottom':\n        newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n        break;\n      case 'top':\n      default:\n        break;\n    }\n    switch (opt.horizontalAlign) {\n      case 'middle':\n        newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n        break;\n      case 'right':\n        newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n        break;\n      case 'left':\n      default:\n        break;\n    }\n    this.scale(newSx, newSy);\n    this.translate(newOx, newOy);\n  },\n  scaleContentToFit: function (opt) {\n    this.transformToFitContent(opt);\n  },\n  // Return the dimensions of the content area in local units (without transformations).\n  getContentArea: function (opt) {\n    if (opt && opt.useModelGeometry) {\n      return this.model.getBBox() || new Rect();\n    }\n    return V(this.cells).getBBox();\n  },\n  // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n  getContentBBox: function (opt) {\n    return this.localToPaperRect(this.getContentArea(opt));\n  },\n  // Returns a geometry rectangle representing the entire\n  // paper area (coordinates from the left paper border to the right one\n  // and the top border to the bottom one).\n  getArea: function () {\n    return this.paperToLocalRect(this.getComputedSize());\n  },\n  getRestrictedArea: function (...args) {\n    const {\n      restrictTranslate\n    } = this.options;\n    let restrictedArea;\n    if (isFunction(restrictTranslate)) {\n      // A method returning a bounding box\n      restrictedArea = restrictTranslate.apply(this, args);\n    } else if (restrictTranslate === true) {\n      // The paper area\n      restrictedArea = this.getArea();\n    } else if (!restrictTranslate) {\n      // falsy value\n      restrictedArea = null;\n    } else {\n      // any other value\n      restrictedArea = new Rect(restrictTranslate);\n    }\n    return restrictedArea;\n  },\n  createViewForModel: function (cell) {\n    const {\n      options\n    } = this;\n    // A class taken from the paper options.\n    var optionalViewClass;\n\n    // A default basic class (either dia.ElementView or dia.LinkView)\n    var defaultViewClass;\n\n    // A special class defined for this model in the corresponding namespace.\n    // e.g. joint.shapes.basic.Rect searches for joint.shapes.basic.RectView\n    var namespace = options.cellViewNamespace;\n    var type = cell.get('type') + 'View';\n    var namespaceViewClass = getByPath(namespace, type, '.');\n    if (cell.isLink()) {\n      optionalViewClass = options.linkView;\n      defaultViewClass = LinkView;\n    } else {\n      optionalViewClass = options.elementView;\n      defaultViewClass = ElementView;\n    }\n\n    // a) the paper options view is a class (deprecated)\n    //  1. search the namespace for a view\n    //  2. if no view was found, use view from the paper options\n    // b) the paper options view is a function\n    //  1. call the function from the paper options\n    //  2. if no view was return, search the namespace for a view\n    //  3. if no view was found, use the default\n    var ViewClass = optionalViewClass.prototype instanceof Backbone.View ? namespaceViewClass || optionalViewClass : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n    return new ViewClass({\n      model: cell,\n      interactive: options.interactive,\n      labelsLayer: options.labelsLayer === true ? LayersNames.LABELS : options.labelsLayer\n    });\n  },\n  removeView: function (cell) {\n    const {\n      id\n    } = cell;\n    const {\n      _views,\n      _updates\n    } = this;\n    const view = _views[id];\n    if (view) {\n      var {\n        cid\n      } = view;\n      const {\n        mounted,\n        unmounted\n      } = _updates;\n      view.remove();\n      delete _views[id];\n      delete mounted[cid];\n      delete unmounted[cid];\n    }\n    return view;\n  },\n  renderView: function (cell, opt) {\n    const {\n      id\n    } = cell;\n    const views = this._views;\n    let view, flag;\n    let create = true;\n    if (id in views) {\n      view = views[id];\n      if (view.model === cell) {\n        flag = view.FLAG_INSERT;\n        create = false;\n      } else {\n        // The view for this `id` already exist.\n        // The cell is a new instance of the model with identical id\n        // We simply remove the existing view and create a new one\n        this.removeView(cell);\n      }\n    }\n    if (create) {\n      view = views[id] = this.createViewForModel(cell);\n      view.paper = this;\n      flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag(result(view, 'initFlag'));\n    }\n    this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n    return view;\n  },\n  onImageDragStart: function () {\n    // This is the only way to prevent image dragging in Firefox that works.\n    // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n    return false;\n  },\n  resetViews: function (cells, opt) {\n    opt || (opt = {});\n    cells || (cells = []);\n    this._resetUpdates();\n    // clearing views removes any event listeners\n    this.removeViews();\n    // Allows to unfreeze normally while in the idle state using autoFreeze option\n    const key = this.options.autoFreeze ? null : 'reset';\n    this.freeze({\n      key\n    });\n    for (var i = 0, n = cells.length; i < n; i++) {\n      this.renderView(cells[i], opt);\n    }\n    this.unfreeze({\n      key\n    });\n    this.sortViews();\n  },\n  removeViews: function () {\n    invoke(this._views, 'remove');\n    this._views = {};\n  },\n  sortViews: function () {\n    if (!this.isExactSorting()) {\n      // noop\n      return;\n    }\n    if (this.isFrozen()) {\n      // sort views once unfrozen\n      this._updates.sort = true;\n      return;\n    }\n    this.sortViewsExact();\n  },\n  sortViewsExact: function () {\n    // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n    // associated model `z` attribute.\n\n    var $cells = $(this.cells).children('[model-id]');\n    var cells = this.model.get('cells');\n    sortElements($cells, function (a, b) {\n      var cellA = cells.get(a.getAttribute('model-id'));\n      var cellB = cells.get(b.getAttribute('model-id'));\n      var zA = cellA.attributes.z || 0;\n      var zB = cellB.attributes.z || 0;\n      return zA === zB ? 0 : zA < zB ? -1 : 1;\n    });\n  },\n  insertView: function (view, isInitialInsert) {\n    const layerView = this.getLayerView(LayersNames.CELLS);\n    const {\n      el,\n      model\n    } = view;\n    switch (this.options.sorting) {\n      case sortingTypes.APPROX:\n        layerView.insertSortedNode(el, model.get('z'));\n        break;\n      case sortingTypes.EXACT:\n      default:\n        layerView.insertNode(el);\n        break;\n    }\n    view.onMount(isInitialInsert);\n  },\n  detachView(view) {\n    view.unmount();\n    view.onDetach();\n  },\n  scale: function (sx, sy, ox, oy) {\n    // getter\n    if (sx === undefined) {\n      return V.matrixToScale(this.matrix());\n    }\n\n    // setter\n    if (sy === undefined) {\n      sy = sx;\n    }\n    if (ox === undefined) {\n      ox = 0;\n      oy = 0;\n    }\n    var translate = this.translate();\n    if (ox || oy || translate.tx || translate.ty) {\n      var newTx = translate.tx - ox * (sx - 1);\n      var newTy = translate.ty - oy * (sy - 1);\n      this.translate(newTx, newTy);\n    }\n    sx = Math.max(sx || 0, this.MIN_SCALE);\n    sy = Math.max(sy || 0, this.MIN_SCALE);\n    var ctm = this.matrix();\n    ctm.a = sx;\n    ctm.d = sy;\n    this.matrix(ctm);\n    this.trigger('scale', sx, sy, ox, oy);\n    return this;\n  },\n  // Experimental - do not use in production.\n  rotate: function (angle, cx, cy) {\n    // getter\n    if (angle === undefined) {\n      return V.matrixToRotate(this.matrix());\n    }\n\n    // setter\n\n    // If the origin is not set explicitely, rotate around the center. Note that\n    // we must use the plain bounding box (`this.el.getBBox()` instead of the one that gives us\n    // the real bounding box (`bbox()`) including transformations).\n    if (cx === undefined) {\n      var bbox = this.cells.getBBox();\n      cx = bbox.width / 2;\n      cy = bbox.height / 2;\n    }\n    var ctm = this.matrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);\n    this.matrix(ctm);\n    return this;\n  },\n  translate: function (tx, ty) {\n    // getter\n    if (tx === undefined) {\n      return V.matrixToTranslate(this.matrix());\n    }\n    const {\n      options\n    } = this;\n    const {\n      origin,\n      drawGrid\n    } = options;\n\n    // setter\n    tx || (tx = 0);\n    ty || (ty = 0);\n    const ctm = this.matrix();\n    if (ctm.e === tx && ctm.f === ty) return this;\n    ctm.e = tx;\n    ctm.f = ty;\n    this.matrix(ctm);\n    const {\n      tx: ox,\n      ty: oy\n    } = this.translate();\n    origin.x = ox;\n    origin.y = oy;\n    this.trigger('translate', ox, oy);\n    if (drawGrid) {\n      this.drawGrid();\n    }\n    return this;\n  },\n  // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n  // be a selector or a jQuery object.\n  findView: function ($el) {\n    var el = isString($el) ? this.cells.querySelector($el) : $el instanceof $ ? $el[0] : $el;\n    var id = this.findAttribute('model-id', el);\n    if (id) return this._views[id];\n    return undefined;\n  },\n  // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n  findViewByModel: function (cell) {\n    var id = isString(cell) || isNumber(cell) ? cell : cell && cell.id;\n    return this._views[id];\n  },\n  // Find all views at given point\n  findViewsFromPoint: function (p) {\n    p = new Point(p);\n    var views = this.model.getElements().map(this.findViewByModel, this);\n    return views.filter(function (view) {\n      return view && view.vel.getBBox({\n        target: this.cells\n      }).containsPoint(p);\n    }, this);\n  },\n  // Find all views in given area\n  findViewsInArea: function (rect, opt) {\n    opt = defaults(opt || {}, {\n      strict: false\n    });\n    rect = new Rect(rect);\n    var views = this.model.getElements().map(this.findViewByModel, this);\n    var method = opt.strict ? 'containsRect' : 'intersect';\n    return views.filter(function (view) {\n      return view && rect[method](view.vel.getBBox({\n        target: this.cells\n      }));\n    }, this);\n  },\n  removeTools: function () {\n    this.dispatchToolsEvent('remove');\n    return this;\n  },\n  hideTools: function () {\n    this.dispatchToolsEvent('hide');\n    return this;\n  },\n  showTools: function () {\n    this.dispatchToolsEvent('show');\n    return this;\n  },\n  dispatchToolsEvent: function (event, ...args) {\n    if (typeof event !== 'string') return;\n    this.trigger('tools:event', event, ...args);\n  },\n  getModelById: function (id) {\n    return this.model.getCell(id);\n  },\n  snapToGrid: function (x, y) {\n    // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n    // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n    return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n  },\n  localToPaperPoint: function (x, y) {\n    // allow `x` to be a point and `y` undefined\n    var localPoint = new Point(x, y);\n    var paperPoint = V.transformPoint(localPoint, this.matrix());\n    return paperPoint;\n  },\n  localToPaperRect: function (x, y, width, height) {\n    // allow `x` to be a rectangle and rest arguments undefined\n    var localRect = new Rect(x, y, width, height);\n    var paperRect = V.transformRect(localRect, this.matrix());\n    return paperRect;\n  },\n  paperToLocalPoint: function (x, y) {\n    // allow `x` to be a point and `y` undefined\n    var paperPoint = new Point(x, y);\n    var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\n    return localPoint;\n  },\n  paperToLocalRect: function (x, y, width, height) {\n    // allow `x` to be a rectangle and rest arguments undefined\n    var paperRect = new Rect(x, y, width, height);\n    var localRect = V.transformRect(paperRect, this.matrix().inverse());\n    return localRect;\n  },\n  localToClientPoint: function (x, y) {\n    // allow `x` to be a point and `y` undefined\n    var localPoint = new Point(x, y);\n    var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\n    return clientPoint;\n  },\n  localToClientRect: function (x, y, width, height) {\n    // allow `x` to be a point and `y` undefined\n    var localRect = new Rect(x, y, width, height);\n    var clientRect = V.transformRect(localRect, this.clientMatrix());\n    return clientRect;\n  },\n  // Transform client coordinates to the paper local coordinates.\n  // Useful when you have a mouse event object and you'd like to get coordinates\n  // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n  // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n  clientToLocalPoint: function (x, y) {\n    // allow `x` to be a point and `y` undefined\n    var clientPoint = new Point(x, y);\n    var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\n    return localPoint;\n  },\n  clientToLocalRect: function (x, y, width, height) {\n    // allow `x` to be a point and `y` undefined\n    var clientRect = new Rect(x, y, width, height);\n    var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\n    return localRect;\n  },\n  localToPagePoint: function (x, y) {\n    return this.localToPaperPoint(x, y).offset(this.pageOffset());\n  },\n  localToPageRect: function (x, y, width, height) {\n    return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n  },\n  pageToLocalPoint: function (x, y) {\n    var pagePoint = new Point(x, y);\n    var paperPoint = pagePoint.difference(this.pageOffset());\n    return this.paperToLocalPoint(paperPoint);\n  },\n  pageToLocalRect: function (x, y, width, height) {\n    var pageOffset = this.pageOffset();\n    var paperRect = new Rect(x, y, width, height);\n    paperRect.x -= pageOffset.x;\n    paperRect.y -= pageOffset.y;\n    return this.paperToLocalRect(paperRect);\n  },\n  clientOffset: function () {\n    var clientRect = this.svg.getBoundingClientRect();\n    return new Point(clientRect.left, clientRect.top);\n  },\n  pageOffset: function () {\n    return this.clientOffset().offset(window.scrollX, window.scrollY);\n  },\n  linkAllowed: function (linkView) {\n    if (!(linkView instanceof LinkView)) {\n      throw new Error('Must provide a linkView.');\n    }\n    var link = linkView.model;\n    var paperOptions = this.options;\n    var graph = this.model;\n    var ns = graph.constructor.validations;\n    if (!paperOptions.multiLinks) {\n      if (!ns.multiLinks.call(this, graph, link)) return false;\n    }\n    if (!paperOptions.linkPinning) {\n      // Link pinning is not allowed and the link is not connected to the target.\n      if (!ns.linkPinning.call(this, graph, link)) return false;\n    }\n    if (typeof paperOptions.allowLink === 'function') {\n      if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n    }\n    return true;\n  },\n  getDefaultLink: function (cellView, magnet) {\n    return isFunction(this.options.defaultLink)\n    // default link is a function producing link model\n    ? this.options.defaultLink.call(this, cellView, magnet)\n    // default link is the Backbone model\n    : this.options.defaultLink.clone();\n  },\n  // Cell highlighting.\n  // ------------------\n\n  resolveHighlighter: function (opt = {}) {\n    let {\n      highlighter: highlighterDef,\n      type\n    } = opt;\n    const {\n      highlighting,\n      highlighterNamespace\n    } = this.options;\n\n    /*\n        Expecting opt.highlighter to have the following structure:\n        {\n            name: 'highlighter-name',\n            options: {\n                some: 'value'\n            }\n        }\n    */\n    if (highlighterDef === undefined) {\n      // Is highlighting disabled?\n      if (!highlighting) return false;\n      // check for built-in types\n      if (type) {\n        highlighterDef = highlighting[type];\n        // Is a specific type highlight disabled?\n        if (highlighterDef === false) return false;\n      }\n      if (!highlighterDef) {\n        // Type not defined use default highlight\n        highlighterDef = highlighting['default'];\n      }\n    }\n\n    // Do nothing if opt.highlighter is falsy.\n    // This allows the case to not highlight cell(s) in certain cases.\n    // For example, if you want to NOT highlight when embedding elements\n    // or use a custom highlighter.\n    if (!highlighterDef) return false;\n\n    // Allow specifying a highlighter by name.\n    if (isString(highlighterDef)) {\n      highlighterDef = {\n        name: highlighterDef\n      };\n    }\n    const name = highlighterDef.name;\n    const highlighter = highlighterNamespace[name];\n\n    // Highlighter validation\n    if (!highlighter) {\n      throw new Error('Unknown highlighter (\"' + name + '\")');\n    }\n    if (typeof highlighter.highlight !== 'function') {\n      throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n    }\n    if (typeof highlighter.unhighlight !== 'function') {\n      throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n    }\n    return {\n      highlighter,\n      options: highlighterDef.options || {},\n      name\n    };\n  },\n  onCellHighlight: function (cellView, magnetEl, opt) {\n    const highlighterDescriptor = this.resolveHighlighter(opt);\n    if (!highlighterDescriptor) return;\n    const {\n      highlighter,\n      options\n    } = highlighterDescriptor;\n    highlighter.highlight(cellView, magnetEl, options);\n  },\n  onCellUnhighlight: function (cellView, magnetEl, opt) {\n    const highlighterDescriptor = this.resolveHighlighter(opt);\n    if (!highlighterDescriptor) return;\n    const {\n      highlighter,\n      options\n    } = highlighterDescriptor;\n    highlighter.unhighlight(cellView, magnetEl, options);\n  },\n  // Interaction.\n  // ------------\n\n  pointerdblclick: function (evt) {\n    evt.preventDefault();\n\n    // magnetpointerdblclick can stop propagation\n\n    evt = normalizeEvent(evt);\n    var view = this.findView(evt.target);\n    if (this.guard(evt, view)) return;\n    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n    if (view) {\n      view.pointerdblclick(evt, localPoint.x, localPoint.y);\n    } else {\n      this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n    }\n  },\n  pointerclick: function (evt) {\n    // magnetpointerclick can stop propagation\n\n    var data = this.eventData(evt);\n    // Trigger event only if mouse has not moved.\n    if (data.mousemoved <= this.options.clickThreshold) {\n      evt = normalizeEvent(evt);\n      var view = this.findView(evt.target);\n      if (this.guard(evt, view)) return;\n      var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n      if (view) {\n        view.pointerclick(evt, localPoint.x, localPoint.y);\n      } else {\n        this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n      }\n    }\n  },\n  contextmenu: function (evt) {\n    if (this.options.preventContextMenu) evt.preventDefault();\n    if (this.contextMenuFired) {\n      this.contextMenuFired = false;\n      return;\n    }\n    evt = normalizeEvent(evt);\n    this.contextMenuTrigger(evt);\n  },\n  contextMenuTrigger: function (evt) {\n    var view = this.findView(evt.target);\n    if (this.guard(evt, view)) return;\n    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n    if (view) {\n      view.contextmenu(evt, localPoint.x, localPoint.y);\n    } else {\n      this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n    }\n  },\n  pointerdown: function (evt) {\n    evt = normalizeEvent(evt);\n    const {\n      target,\n      button\n    } = evt;\n    const view = this.findView(target);\n    const isContextMenu = button === 2;\n    if (view) {\n      if (!isContextMenu && this.guard(evt, view)) return;\n      const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n      if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n        // If the target is a form element, we do not want to prevent the default action.\n        // For example, we want to be able to select text in a text input or\n        // to be able to click on a checkbox.\n        evt.preventDefault();\n      }\n      if (isTargetFormNode) {\n        // If the target is a form element, we do not want to start dragging the element.\n        // For example, we want to be able to select text by dragging the mouse.\n        view.preventDefaultInteraction(evt);\n      }\n      const rootViewEl = view.el;\n\n      // Custom event\n      const eventNode = target.closest('[event]');\n      if (eventNode && rootViewEl !== eventNode && view.el.contains(eventNode)) {\n        const eventEvt = normalizeEvent($.Event(evt.originalEvent, {\n          data: evt.data,\n          // Originally the event listener was attached to the event element.\n          currentTarget: eventNode\n        }));\n        this.onevent(eventEvt);\n        if (eventEvt.isDefaultPrevented()) {\n          evt.preventDefault();\n        }\n        // `onevent` can stop propagation\n        if (eventEvt.isPropagationStopped()) return;\n        evt.data = eventEvt.data;\n      }\n\n      // Element magnet\n      const magnetNode = target.closest('[magnet]');\n      if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n        const magnetEvt = normalizeEvent($.Event(evt.originalEvent, {\n          data: evt.data,\n          // Originally the event listener was attached to the magnet element.\n          currentTarget: magnetNode\n        }));\n        this.onmagnet(magnetEvt);\n        if (magnetEvt.isDefaultPrevented()) {\n          evt.preventDefault();\n        }\n        // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n        if (magnetEvt.isPropagationStopped()) {\n          // `magnet:pointermove` and `magnet:pointerup` events must be fired\n          if (isContextMenu) return;\n          this.delegateDragEvents(view, magnetEvt.data);\n          return;\n        }\n        evt.data = magnetEvt.data;\n      }\n    }\n    if (isContextMenu) {\n      this.contextMenuFired = true;\n      const contextmenuEvt = $.Event(evt.originalEvent, {\n        type: 'contextmenu',\n        data: evt.data\n      });\n      this.contextMenuTrigger(contextmenuEvt);\n    } else {\n      const localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n      if (view) {\n        view.pointerdown(evt, localPoint.x, localPoint.y);\n      } else {\n        if (this.options.preventDefaultBlankAction) {\n          evt.preventDefault();\n        }\n        this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n      }\n      this.delegateDragEvents(view, evt.data);\n    }\n  },\n  pointermove: function (evt) {\n    // mouse moved counter\n    var data = this.eventData(evt);\n    if (!data.mousemoved) {\n      data.mousemoved = 0;\n      // Make sure that events like `mouseenter` and `mouseleave` are\n      // not triggered while the user is dragging a cellView.\n      this.undelegateEvents();\n      // Note: the events are undelegated after the first `pointermove` event.\n      // Not on `pointerdown` to make sure that `dbltap` is recognized.\n    }\n\n    var mousemoved = ++data.mousemoved;\n    if (mousemoved <= this.options.moveThreshold) return;\n    evt = normalizeEvent(evt);\n    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n    var view = data.sourceView;\n    if (view) {\n      view.pointermove(evt, localPoint.x, localPoint.y);\n    } else {\n      this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n    }\n    this.eventData(evt, data);\n  },\n  pointerup: function (evt) {\n    this.undelegateDocumentEvents();\n    var normalizedEvt = normalizeEvent(evt);\n    var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n    var view = this.eventData(evt).sourceView;\n    if (view) {\n      view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n    } else {\n      this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n    }\n    if (!normalizedEvt.isPropagationStopped()) {\n      this.pointerclick($.Event(evt.originalEvent, {\n        type: 'click',\n        data: evt.data\n      }));\n    }\n    this.delegateEvents();\n  },\n  mouseover: function (evt) {\n    evt = normalizeEvent(evt);\n    var view = this.findView(evt.target);\n    if (this.guard(evt, view)) return;\n    if (view) {\n      view.mouseover(evt);\n    } else {\n      if (this.el === evt.target) return; // prevent border of paper from triggering this\n      this.trigger('blank:mouseover', evt);\n    }\n  },\n  mouseout: function (evt) {\n    evt = normalizeEvent(evt);\n    var view = this.findView(evt.target);\n    if (this.guard(evt, view)) return;\n    if (view) {\n      view.mouseout(evt);\n    } else {\n      if (this.el === evt.target) return; // prevent border of paper from triggering this\n      this.trigger('blank:mouseout', evt);\n    }\n  },\n  mouseenter: function (evt) {\n    evt = normalizeEvent(evt);\n    const {\n      target,\n      // The EventTarget the pointing device entered to\n      relatedTarget,\n      // The EventTarget the pointing device exited from\n      currentTarget // The EventTarget on which the event listener was registered\n    } = evt;\n    const view = this.findView(target);\n    if (this.guard(evt, view)) return;\n    const relatedView = this.findView(relatedTarget);\n    if (view) {\n      if (relatedView === view) {\n        // Mouse left a cell tool\n        return;\n      }\n      view.mouseenter(evt);\n      if (this.el.contains(relatedTarget)) {\n        // The pointer remains inside the paper.\n        return;\n      }\n    }\n    if (relatedView) {\n      return;\n    }\n    // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n    // (mouseenter method would be fired twice)\n    if (currentTarget === this.el) {\n      // `paper` (more descriptive), not `blank`\n      this.trigger('paper:mouseenter', evt);\n    }\n  },\n  mouseleave: function (evt) {\n    evt = normalizeEvent(evt);\n    const {\n      target,\n      // The EventTarget the pointing device exited from\n      relatedTarget,\n      // The EventTarget the pointing device entered to\n      currentTarget // The EventTarget on which the event listener was registered\n    } = evt;\n    const view = this.findView(target);\n    if (this.guard(evt, view)) return;\n    const relatedView = this.findView(relatedTarget);\n    if (view) {\n      if (relatedView === view) {\n        // Mouse entered a cell tool\n        return;\n      }\n      view.mouseleave(evt);\n      if (this.el.contains(relatedTarget)) {\n        // The pointer has exited a cellView. The pointer is still inside of the paper.\n        return;\n      }\n    }\n    if (relatedView) {\n      // The pointer has entered a new cellView\n      return;\n    }\n    // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n    // (mouseleave method would be fired twice)\n    if (currentTarget === this.el) {\n      // There is no cellView under the pointer, nor the blank area of the paper\n      this.trigger('paper:mouseleave', evt);\n    }\n  },\n  _processMouseWheelEvtBuf: debounce(function () {\n    const {\n      event,\n      deltas\n    } = this._mw_evt_buffer;\n    const deltaY = deltas.reduce((acc, deltaY) => acc + cap(deltaY, WHEEL_CAP), 0);\n    const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n    const {\n      x,\n      y\n    } = this.clientToLocalPoint(event.clientX, event.clientY);\n    this.trigger('paper:pinch', event, x, y, scale);\n    this._mw_evt_buffer = {\n      event: null,\n      deltas: []\n    };\n  }, WHEEL_WAIT_MS, {\n    maxWait: WHEEL_WAIT_MS\n  }),\n  mousewheel: function (evt) {\n    evt = normalizeEvent(evt);\n    const view = this.findView(evt.target);\n    if (this.guard(evt, view)) return;\n    const originalEvent = evt.originalEvent;\n    const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n    const {\n      deltaX,\n      deltaY\n    } = normalizeWheel(originalEvent);\n    const pinchHandlers = this._events['paper:pinch'];\n\n    // Touchpad devices will send a fake CTRL press when a pinch is performed\n    //\n    // We also check if there are any subscribers to paper:pinch event. If there are none,\n    // just skip the entire block of code (we don't want to blindly call\n    // .preventDefault() if we really don't have to).\n    if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n      // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n      originalEvent.preventDefault();\n      this._mw_evt_buffer.event = originalEvent;\n      this._mw_evt_buffer.deltas.push(deltaY);\n      this._processMouseWheelEvtBuf();\n    } else {\n      const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n      if (view) {\n        view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n      } else {\n        this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n      }\n      this.trigger('paper:pan', evt, deltaX, deltaY);\n    }\n  },\n  onevent: function (evt) {\n    var eventNode = evt.currentTarget;\n    var eventName = eventNode.getAttribute('event');\n    if (eventName) {\n      var view = this.findView(eventNode);\n      if (view) {\n        evt = normalizeEvent(evt);\n        if (this.guard(evt, view)) return;\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        view.onevent(evt, eventName, localPoint.x, localPoint.y);\n      }\n    }\n  },\n  magnetEvent: function (evt, handler) {\n    var magnetNode = evt.currentTarget;\n    var magnetValue = magnetNode.getAttribute('magnet');\n    if (magnetValue) {\n      var view = this.findView(magnetNode);\n      if (view) {\n        evt = normalizeEvent(evt);\n        if (this.guard(evt, view)) return;\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n      }\n    }\n  },\n  onmagnet: function (evt) {\n    if (evt.button === 2) {\n      this.contextMenuFired = true;\n      this.magnetContextMenuFired = true;\n      const contextmenuEvt = $.Event(evt.originalEvent, {\n        type: 'contextmenu',\n        data: evt.data,\n        currentTarget: evt.currentTarget\n      });\n      this.magnetContextMenuTrigger(contextmenuEvt);\n      if (contextmenuEvt.isPropagationStopped()) {\n        evt.stopPropagation();\n      }\n    } else {\n      this.magnetEvent(evt, function (view, evt, _, x, y) {\n        view.onmagnet(evt, x, y);\n      });\n    }\n  },\n  magnetpointerdblclick: function (evt) {\n    this.magnetEvent(evt, function (view, evt, magnet, x, y) {\n      view.magnetpointerdblclick(evt, magnet, x, y);\n    });\n  },\n  magnetcontextmenu: function (evt) {\n    if (this.options.preventContextMenu) evt.preventDefault();\n    if (this.magnetContextMenuFired) {\n      this.magnetContextMenuFired = false;\n      return;\n    }\n    this.magnetContextMenuTrigger(evt);\n  },\n  magnetContextMenuTrigger: function (evt) {\n    this.magnetEvent(evt, function (view, evt, magnet, x, y) {\n      view.magnetcontextmenu(evt, magnet, x, y);\n    });\n  },\n  onlabel: function (evt) {\n    var labelNode = evt.currentTarget;\n    var view = this.findView(labelNode);\n    if (view) {\n      evt = normalizeEvent(evt);\n      if (this.guard(evt, view)) return;\n      var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n      view.onlabel(evt, localPoint.x, localPoint.y);\n    }\n  },\n  getPointerArgs(evt) {\n    const normalizedEvt = normalizeEvent(evt);\n    const {\n      x,\n      y\n    } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n    return [normalizedEvt, x, y];\n  },\n  delegateDragEvents: function (view, data) {\n    data || (data = {});\n    this.eventData({\n      data: data\n    }, {\n      sourceView: view || null,\n      mousemoved: 0\n    });\n    this.delegateDocumentEvents(null, data);\n  },\n  // Guard the specified event. If the event should be ignored, guard returns `true`.\n  // Otherwise, it returns `false`.\n  guard: function (evt, view) {\n    if (evt.type === 'mousedown' && evt.button === 2) {\n      // handled as `contextmenu` type\n      return true;\n    }\n    if (this.options.guard && this.options.guard(evt, view)) {\n      return true;\n    }\n    if (evt.data && evt.data.guarded !== undefined) {\n      return evt.data.guarded;\n    }\n    const {\n      target\n    } = evt;\n    if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n      return true;\n    }\n    if (view && view.model && view.model instanceof Cell) {\n      return false;\n    }\n    if (this.svg === target || this.el === target || $.contains(this.svg, target)) {\n      return false;\n    }\n    return true; // Event guarded. Paper should not react on it in any way.\n  },\n\n  setGridSize: function (gridSize) {\n    const {\n      options\n    } = this;\n    options.gridSize = gridSize;\n    if (options.drawGrid && !options.drawGridSize) {\n      // Do not redraw the grid if the `drawGridSize` is set.\n      this.drawGrid();\n    }\n    return this;\n  },\n  clearGrid: function () {\n    if (this.$grid) {\n      this.$grid.css('backgroundImage', 'none');\n    }\n    return this;\n  },\n  _getGridRefs: function () {\n    if (!this._gridCache) {\n      this._gridCache = {\n        root: V('svg', {\n          width: '100%',\n          height: '100%'\n        }, V('defs')),\n        patterns: {},\n        add: function (id, vel) {\n          V(this.root.node.childNodes[0]).append(vel);\n          this.patterns[id] = vel;\n          this.root.append(V('rect', {\n            width: '100%',\n            height: '100%',\n            fill: 'url(#' + id + ')'\n          }));\n        },\n        get: function (id) {\n          return this.patterns[id];\n        },\n        exist: function (id) {\n          return this.patterns[id] !== undefined;\n        }\n      };\n    }\n    return this._gridCache;\n  },\n  setGrid: function (drawGrid) {\n    this.clearGrid();\n    this._gridCache = null;\n    this._gridSettings = [];\n    var optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n    optionsList.forEach(function (item) {\n      this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(item));\n    }, this);\n    return this;\n  },\n  _resolveDrawGridOption: function (opt) {\n    var namespace = this.constructor.gridPatterns;\n    if (isString(opt) && Array.isArray(namespace[opt])) {\n      return namespace[opt].map(function (item) {\n        return assign({}, item);\n      });\n    }\n    var options = opt || {\n      args: [{}]\n    };\n    var isArray = Array.isArray(options);\n    var name = options.name;\n    if (!isArray && !name && !options.markup) {\n      name = 'dot';\n    }\n    if (name && Array.isArray(namespace[name])) {\n      var pattern = namespace[name].map(function (item) {\n        return assign({}, item);\n      });\n      var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n      defaults(args[0], omit(opt, 'args'));\n      for (var i = 0; i < args.length; i++) {\n        if (pattern[i]) {\n          assign(pattern[i], args[i]);\n        }\n      }\n      return pattern;\n    }\n    return isArray ? options : [options];\n  },\n  drawGrid: function (opt) {\n    const gridSize = this.options.drawGridSize || this.options.gridSize;\n    if (gridSize <= 1) {\n      return this.clearGrid();\n    }\n    var localOptions = Array.isArray(opt) ? opt : [opt];\n    var ctm = this.matrix();\n    var refs = this._getGridRefs();\n    this._gridSettings.forEach(function (gridLayerSetting, index) {\n      var id = 'pattern_' + index;\n      var options = merge(gridLayerSetting, localOptions[index], {\n        sx: ctm.a || 1,\n        sy: ctm.d || 1,\n        ox: ctm.e || 0,\n        oy: ctm.f || 0\n      });\n      options.width = gridSize * (ctm.a || 1) * (options.scaleFactor || 1);\n      options.height = gridSize * (ctm.d || 1) * (options.scaleFactor || 1);\n      if (!refs.exist(id)) {\n        refs.add(id, V('pattern', {\n          id: id,\n          patternUnits: 'userSpaceOnUse'\n        }, V(options.markup)));\n      }\n      var patternDefVel = refs.get(id);\n      if (isFunction(options.update)) {\n        options.update(patternDefVel.node.childNodes[0], options);\n      }\n      var x = options.ox % options.width;\n      if (x < 0) x += options.width;\n      var y = options.oy % options.height;\n      if (y < 0) y += options.height;\n      patternDefVel.attr({\n        x: x,\n        y: y,\n        width: options.width,\n        height: options.height\n      });\n    });\n    var patternUri = new XMLSerializer().serializeToString(refs.root.node);\n    patternUri = 'url(data:image/svg+xml;base64,' + btoa(patternUri) + ')';\n    this.$grid.css('backgroundImage', patternUri);\n    return this;\n  },\n  updateBackgroundImage: function (opt) {\n    opt = opt || {};\n    var backgroundPosition = opt.position || 'center';\n    var backgroundSize = opt.size || 'auto auto';\n    var currentScale = this.scale();\n    var currentTranslate = this.translate();\n\n    // backgroundPosition\n    if (isObject(backgroundPosition)) {\n      var x = currentTranslate.tx + currentScale.sx * (backgroundPosition.x || 0);\n      var y = currentTranslate.ty + currentScale.sy * (backgroundPosition.y || 0);\n      backgroundPosition = x + 'px ' + y + 'px';\n    }\n\n    // backgroundSize\n    if (isObject(backgroundSize)) {\n      backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n      backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n    }\n    this.$background.css({\n      backgroundSize: backgroundSize,\n      backgroundPosition: backgroundPosition\n    });\n  },\n  drawBackgroundImage: function (img, opt) {\n    // Clear the background image if no image provided\n    if (!(img instanceof HTMLImageElement)) {\n      this.$background.css('backgroundImage', '');\n      return;\n    }\n    if (!this._background || this._background.id !== opt.id) {\n      // Draw only the last image requested (see drawBackground())\n      return;\n    }\n    opt = opt || {};\n    var backgroundImage;\n    var backgroundSize = opt.size;\n    var backgroundRepeat = opt.repeat || 'no-repeat';\n    var backgroundOpacity = opt.opacity || 1;\n    var backgroundQuality = Math.abs(opt.quality) || 1;\n    var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];\n    if (isFunction(backgroundPattern)) {\n      // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n      img.width *= backgroundQuality;\n      img.height *= backgroundQuality;\n      var canvas = backgroundPattern(img, opt);\n      if (!(canvas instanceof HTMLCanvasElement)) {\n        throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n      }\n      backgroundImage = canvas.toDataURL('image/png');\n      backgroundRepeat = 'repeat';\n      if (isObject(backgroundSize)) {\n        // recalculate the tile size if an object passed in\n        backgroundSize.width *= canvas.width / img.width;\n        backgroundSize.height *= canvas.height / img.height;\n      } else if (backgroundSize === undefined) {\n        // calculate the tile size if no provided\n        opt.size = {\n          width: canvas.width / backgroundQuality,\n          height: canvas.height / backgroundQuality\n        };\n      }\n    } else {\n      // backgroundRepeat:\n      // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n      backgroundImage = img.src;\n      if (backgroundSize === undefined) {\n        // pass the image size for  the backgroundSize if no size provided\n        opt.size = {\n          width: img.width,\n          height: img.height\n        };\n      }\n    }\n    this.$background.css({\n      opacity: backgroundOpacity,\n      backgroundRepeat: backgroundRepeat,\n      backgroundImage: 'url(' + backgroundImage + ')'\n    });\n    this.updateBackgroundImage(opt);\n  },\n  updateBackgroundColor: function (color) {\n    this.$el.css('backgroundColor', color || '');\n  },\n  drawBackground: function (opt) {\n    opt = opt || {};\n    this.updateBackgroundColor(opt.color);\n    if (opt.image) {\n      opt = this._background = cloneDeep(opt);\n      guid(opt);\n      var img = document.createElement('img');\n      img.onload = this.drawBackgroundImage.bind(this, img, opt);\n      img.src = opt.image;\n    } else {\n      this.drawBackgroundImage(null);\n      this._background = null;\n    }\n    return this;\n  },\n  setInteractivity: function (value) {\n    this.options.interactive = value;\n    invoke(this._views, 'setInteractivity', value);\n  },\n  // Paper definitions.\n  // ------------------\n\n  isDefined: function (defId) {\n    return !!this.svg.getElementById(defId);\n  },\n  defineFilter: function (filter) {\n    if (!isObject(filter)) {\n      throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n    }\n    var filterId = filter.id;\n    var name = filter.name;\n    // Generate a hash code from the stringified filter definition. This gives us\n    // a unique filter ID for different definitions.\n    if (!filterId) {\n      filterId = name + this.svg.id + hashCode(JSON.stringify(filter));\n    }\n    // If the filter already exists in the document,\n    // we're done and we can just use it (reference it using `url()`).\n    // If not, create one.\n    if (!this.isDefined(filterId)) {\n      var namespace = _filter;\n      var filterSVGString = namespace[name] && namespace[name](filter.args || {});\n      if (!filterSVGString) {\n        throw new Error('Non-existing filter ' + name);\n      }\n\n      // Set the filter area to be 3x the bounding box of the cell\n      // and center the filter around the cell.\n      var filterAttrs = assign({\n        filterUnits: 'objectBoundingBox',\n        x: -1,\n        y: -1,\n        width: 3,\n        height: 3\n      }, filter.attrs, {\n        id: filterId\n      });\n      V(filterSVGString, filterAttrs).appendTo(this.defs);\n    }\n    return filterId;\n  },\n  defineGradient: function (gradient) {\n    if (!isObject(gradient)) {\n      throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n    }\n    const {\n      svg,\n      defs\n    } = this;\n    const {\n      type,\n      // Generate a hash code from the stringified filter definition. This gives us\n      // a unique filter ID for different definitions.\n      id = type + svg.id + hashCode(JSON.stringify(gradient)),\n      stops,\n      attrs = {}\n    } = gradient;\n    // If the gradient already exists in the document,\n    // we're done and we can just use it (reference it using `url()`).\n    if (this.isDefined(id)) return id;\n    // If not, create one.\n    const stopVEls = toArray(stops).map(({\n      offset,\n      color,\n      opacity\n    }) => {\n      return V('stop').attr({\n        'offset': offset,\n        'stop-color': color,\n        'stop-opacity': Number.isFinite(opacity) ? opacity : 1\n      });\n    });\n    const gradientVEl = V(type, attrs, stopVEls);\n    gradientVEl.id = id;\n    gradientVEl.appendTo(defs);\n    return id;\n  },\n  definePattern: function (pattern) {\n    if (!isObject(pattern)) {\n      throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');\n    }\n    const {\n      svg,\n      defs\n    } = this;\n    const {\n      // Generate a hash code from the stringified filter definition. This gives us\n      // a unique filter ID for different definitions.\n      id = svg.id + hashCode(JSON.stringify(pattern)),\n      markup,\n      attrs = {}\n    } = pattern;\n    if (!markup) {\n      throw new TypeError('dia.Paper: definePattern() requires markup.');\n    }\n    // If the gradient already exists in the document,\n    // we're done and we can just use it (reference it using `url()`).\n    if (this.isDefined(id)) return id;\n    // If not, create one.\n    const patternVEl = V('pattern', {\n      patternUnits: 'userSpaceOnUse'\n    });\n    patternVEl.id = id;\n    patternVEl.attr(attrs);\n    if (typeof markup === 'string') {\n      patternVEl.append(V(markup));\n    } else {\n      const {\n        fragment\n      } = parseDOMJSON(markup);\n      patternVEl.append(fragment);\n    }\n    patternVEl.appendTo(defs);\n    return id;\n  },\n  defineMarker: function (marker) {\n    if (!isObject(marker)) {\n      throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');\n    }\n    const {\n      svg,\n      defs\n    } = this;\n    const {\n      // Generate a hash code from the stringified filter definition. This gives us\n      // a unique filter ID for different definitions.\n      id = svg.id + hashCode(JSON.stringify(marker)),\n      // user-provided markup\n      // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)\n      markup,\n      // user-provided attributes\n      // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)\n      // note: `transform` attrs are ignored by browsers\n      attrs = {},\n      // deprecated - use `attrs/markerUnits` instead (which has higher priority)\n      markerUnits = 'userSpaceOnUse'\n    } = marker;\n    // If the marker already exists in the document,\n    // we're done and we can just use it (reference it using `url()`).\n    if (this.isDefined(id)) return id;\n    // If not, create one.\n    const markerVEl = V('marker', {\n      orient: 'auto',\n      overflow: 'visible',\n      markerUnits: markerUnits\n    });\n    markerVEl.id = id;\n    markerVEl.attr(attrs);\n    let markerContentVEl;\n    if (markup) {\n      let markupVEl;\n      if (typeof markup === 'string') {\n        // Marker object has a `markup` property of type string.\n        // - Construct V from the provided string.\n        markupVEl = V(markup);\n        // `markupVEl` is now either a single VEl, or an array of VEls.\n        // - Coerce it to an array.\n        markupVEl = Array.isArray(markupVEl) ? markupVEl : [markupVEl];\n      } else {\n        // Marker object has a `markup` property of type object.\n        // - Construct V from the object by parsing it as DOM JSON.\n        const {\n          fragment\n        } = parseDOMJSON(markup);\n        markupVEl = V(fragment).children();\n      }\n      // `markupVEl` is an array with one or more VEls inside.\n      // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n      if (markupVEl.length > 1) {\n        markerContentVEl = V('g').append(markupVEl);\n      } else {\n        markerContentVEl = markupVEl[0];\n      }\n    } else {\n      // Marker object is a flat structure.\n      // - Construct a new V of type `marker.type`.\n      const {\n        type = 'path'\n      } = marker;\n      markerContentVEl = V(type);\n    }\n    // `markerContentVEl` is a single VEl.\n    // Assign additional attributes to it (= context attributes + marker attributes):\n    // - Attribute values are taken from non-special properties of `marker`.\n    const markerAttrs = omit(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');\n    const markerAttrsKeys = Object.keys(markerAttrs);\n    markerAttrsKeys.forEach(key => {\n      const value = markerAttrs[key];\n      const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n      if (markupValue == null) {\n        // Default logic:\n        markerContentVEl.attr(key, value);\n      } else {\n        // Properties with special logic should be added as cases to this switch block:\n        switch (key) {\n          case 'transform':\n            // - Prepend `transform` to existing value.\n            markerContentVEl.attr(key, value + ' ' + markupValue);\n            break;\n        }\n      }\n    });\n    markerContentVEl.appendTo(markerVEl);\n    markerVEl.appendTo(defs);\n    return id;\n  }\n}, {\n  sorting: sortingTypes,\n  Layers: LayersNames,\n  backgroundPatterns: {\n    flipXy: function (img) {\n      // d b\n      // q p\n\n      var canvas = document.createElement('canvas');\n      var imgWidth = img.width;\n      var imgHeight = img.height;\n      canvas.width = 2 * imgWidth;\n      canvas.height = 2 * imgHeight;\n      var ctx = canvas.getContext('2d');\n      // top-left image\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      // xy-flipped bottom-right image\n      ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      // x-flipped top-right image\n      ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      // y-flipped bottom-left image\n      ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      return canvas;\n    },\n    flipX: function (img) {\n      // d b\n      // d b\n\n      var canvas = document.createElement('canvas');\n      var imgWidth = img.width;\n      var imgHeight = img.height;\n      canvas.width = imgWidth * 2;\n      canvas.height = imgHeight;\n      var ctx = canvas.getContext('2d');\n      // left image\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      // flipped right image\n      ctx.translate(2 * imgWidth, 0);\n      ctx.scale(-1, 1);\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      return canvas;\n    },\n    flipY: function (img) {\n      // d d\n      // q q\n\n      var canvas = document.createElement('canvas');\n      var imgWidth = img.width;\n      var imgHeight = img.height;\n      canvas.width = imgWidth;\n      canvas.height = imgHeight * 2;\n      var ctx = canvas.getContext('2d');\n      // top image\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      // flipped bottom image\n      ctx.translate(0, 2 * imgHeight);\n      ctx.scale(1, -1);\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      return canvas;\n    },\n    watermark: function (img, opt) {\n      //   d\n      // d\n\n      opt = opt || {};\n      var imgWidth = img.width;\n      var imgHeight = img.height;\n      var canvas = document.createElement('canvas');\n      canvas.width = imgWidth * 3;\n      canvas.height = imgHeight * 3;\n      var ctx = canvas.getContext('2d');\n      var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n      var radians = toRad(angle);\n      var stepX = canvas.width / 4;\n      var stepY = canvas.height / 4;\n      for (var i = 0; i < 4; i++) {\n        for (var j = 0; j < 4; j++) {\n          if ((i + j) % 2 > 0) {\n            // reset the current transformations\n            ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n            ctx.rotate(radians);\n            ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n          }\n        }\n      }\n      return canvas;\n    }\n  },\n  gridPatterns: {\n    dot: [{\n      color: '#AAAAAA',\n      thickness: 1,\n      markup: 'rect',\n      update: function (el, opt) {\n        V(el).attr({\n          width: opt.thickness * opt.sx,\n          height: opt.thickness * opt.sy,\n          fill: opt.color\n        });\n      }\n    }],\n    fixedDot: [{\n      color: '#AAAAAA',\n      thickness: 1,\n      markup: 'rect',\n      update: function (el, opt) {\n        var size = opt.sx <= 1 ? opt.thickness * opt.sx : opt.thickness;\n        V(el).attr({\n          width: size,\n          height: size,\n          fill: opt.color\n        });\n      }\n    }],\n    mesh: [{\n      color: '#AAAAAA',\n      thickness: 1,\n      markup: 'path',\n      update: function (el, opt) {\n        var d;\n        var width = opt.width;\n        var height = opt.height;\n        var thickness = opt.thickness;\n        if (width - thickness >= 0 && height - thickness >= 0) {\n          d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n        } else {\n          d = 'M 0 0 0 0';\n        }\n        V(el).attr({\n          'd': d,\n          stroke: opt.color,\n          'stroke-width': opt.thickness\n        });\n      }\n    }],\n    doubleMesh: [{\n      color: '#AAAAAA',\n      thickness: 1,\n      markup: 'path',\n      update: function (el, opt) {\n        var d;\n        var width = opt.width;\n        var height = opt.height;\n        var thickness = opt.thickness;\n        if (width - thickness >= 0 && height - thickness >= 0) {\n          d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n        } else {\n          d = 'M 0 0 0 0';\n        }\n        V(el).attr({\n          'd': d,\n          stroke: opt.color,\n          'stroke-width': opt.thickness\n        });\n      }\n    }, {\n      color: '#000000',\n      thickness: 3,\n      scaleFactor: 4,\n      markup: 'path',\n      update: function (el, opt) {\n        var d;\n        var width = opt.width;\n        var height = opt.height;\n        var thickness = opt.thickness;\n        if (width - thickness >= 0 && height - thickness >= 0) {\n          d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n        } else {\n          d = 'M 0 0 0 0';\n        }\n        V(el).attr({\n          'd': d,\n          stroke: opt.color,\n          'stroke-width': opt.thickness\n        });\n      }\n    }]\n  }\n});","map":{"version":3,"names":["V","isNumber","assign","nextFrame","isObject","cancelFrame","defaults","defaultsDeep","addClassNamePrefix","normalizeSides","isFunction","isPlainObject","getByPath","sortElements","isString","guid","normalizeEvent","normalizeWheel","cap","debounce","omit","result","merge","camelCase","cloneDeep","invoke","hashCode","filter","_filter","parseDOMJSON","toArray","has","Rect","Point","toRad","View","views","CellView","ElementView","LinkView","Link","Cell","Graph","LayersNames","PaperLayer","highlighters","linkAnchors","connectionPoints","anchors","$","Backbone","sortingTypes","NONE","APPROX","EXACT","WHEEL_CAP","WHEEL_WAIT_MS","MOUNT_BATCH_SIZE","UPDATE_BATCH_SIZE","Infinity","MIN_PRIORITY","HighlightingTypes","Highlighting","defaultHighlighting","DEFAULT","name","options","padding","MAGNET_AVAILABILITY","className","ELEMENT_AVAILABILITY","defaultLayers","BACK","CELLS","LABELS","FRONT","TOOLS","Paper","extend","width","height","origin","x","y","gridSize","drawGrid","drawGridSize","background","perpendicularLinks","elementView","linkView","snapLabels","snapLinks","snapLinksSelf","labelsLayer","multiLinks","guard","evt","view","highlighting","preventContextMenu","preventDefaultBlankAction","preventDefaultViewAction","restrictTranslate","markAvailable","defaultLink","defaultConnector","defaultRouter","defaultAnchor","defaultLinkAnchor","defaultConnectionPoint","connectionStrategy","validateMagnet","_cellView","magnet","_evt","getAttribute","validateConnection","cellViewS","_magnetS","cellViewT","_magnetT","end","_linkView","embeddingMode","validateEmbedding","childView","parentView","validateUnembedding","findParentBy","frontParentOnly","interactive","labelMove","linkPinning","allowLink","clickThreshold","moveThreshold","magnetThreshold","sorting","frozen","autoFreeze","onViewUpdate","flag","priority","opt","paper","FLAG_INSERT","FLAG_REMOVE","mounting","isolate","requestConnectedLinksUpdate","onViewPostponed","forcePostponedViewUpdate","beforeRender","afterRender","viewport","cellViewNamespace","routerNamespace","connectorNamespace","highlighterNamespace","anchorNamespace","linkAnchorNamespace","connectionPointNamespace","overflow","events","documentEvents","svg","defs","tools","$background","layers","$grid","$document","_viewportMatrix","_viewportTransformString","_updates","_layers","SORT_DELAYING_BATCHES","UPDATE_DELAYING_BATCHES","FORM_CONTROL_TAG_NAMES","GUARDED_TAG_NAMES","MIN_SCALE","init","el","joint","shapes","model","setGrid","cloneOptions","render","_setDimensions","startListening","_views","_mw_evt_buffer","event","deltas","ownerDocument","resetViews","attributes","cells","models","isFrozen","isAsync","updateViewsAsync","_resetUpdates","id","priorities","unmountedCids","mountedCids","unmounted","mounted","count","keyFrozen","freezeKey","sort","disabled","idle","listenTo","onCellAdded","onCellRemoved","onCellChange","onGraphReset","onGraphSort","onGraphBatchStop","on","onCellHighlight","onCellUnhighlight","update","cell","_","position","renderView","maxPosition","freeze","key","unfreeze","findViewByModel","requestViewUpdate","UPDATE_PRIORITY","hasChanged","collection","resetLayers","hasActiveBatch","sortViews","data","batchName","graph","updateDelayingBatches","includes","updateViews","sortDelayingBatches","children","ns","namespace","namespaceURI","xhtml","tagName","selector","xlink","hasLayerView","layerName","getLayerView","Error","getLayerNode","renderChildren","childNodes","grid","style","renderLayers","ensureId","drawBackground","removeLayers","forEach","sorted","layerView","appendChild","cellsLayerView","toolsLayerView","labelsLayerView","vel","addClass","Object","keys","remove","removePivots","_background","updateBackgroundImage","matrix","ctm","undefined","transformString","getCTM","createSVGMatrix","ctmString","matrixToTransformString","setAttribute","clientMatrix","getScreenCTM","links","getConnectedLinks","j","n","length","link","flagLabels","getTargetCell","push","getSourceCell","nextPriority","Math","max","scheduleViewUpdate","getFlag","isElement","dumpOptions","silent","sourceFlag","sourceView","isViewMounted","dumpView","updateEndMagnet","targetFlag","targetView","async","stats","notifyAfterRender","type","updates","cid","priorityUpdates","i","prevPriorityUpdates","currentType","viewUpdateFn","call","dumpViewUpdate","registerMountedView","shouldNotify","notifyBeforeRender","leftover","updateView","updated","FLAG_INIT","removeView","isInitialInsert","insertView","confirmUpdate","requireView","registerUnmountedView","dumpViews","passingOpt","checkViewport","batchStats","updateCount","batchCount","updateViewsBatch","min","empty","batches","hasScheduledUpdates","priorityIndexes","_key","processed","mountBatchSize","unmountBatchSize","checkStats","unmountCount","mountCount","total","trigger","progressFn","progress","beforeFn","afterFn","batchSize","postponeCount","maxPriority","viewportFn","postponeViewFn","main","currentFlag","isDetached","DETACHABLE","detachView","leftoverFlag","postponed","getUnmountedViews","unmountedViews","Array","getMountedViews","mountedViews","checkUnmountedViews","splice","checkMountedViews","checkViewVisibility","cellView","visible","isUnmounted","isMounted","indexOf","unmountedCount","mountedCount","isExactSorting","onRemove","removeViews","getComputedSize","w","h","clientWidth","clientHeight","setDimensions","currentWidth","currentHeight","computedSize","round","$el","css","setOrigin","ox","oy","translate","fitToContent","gridWidth","gridHeight","getFitToContentArea","sx","sy","scale","minWidth","minHeight","maxWidth","Number","MAX_VALUE","maxHeight","newOrigin","allowNewOrigin","area","contentArea","getContentArea","calcWidth","ceil","calcHeight","allowNegativeBottomRight","tx","left","ty","top","right","bottom","transformToFitContent","contentBBox","contentLocalOrigin","localToPaperRect","getContentBBox","paperToLocalPoint","preserveAspectRatio","scaleGrid","minScale","maxScale","verticalAlign","horizontalAlign","minScaleX","maxScaleX","minScaleY","maxScaleY","fittingBBox","currentTranslate","moveAndExpand","currentScale","newSx","newSy","floor","scaleDiff","newOx","newOy","scaleContentToFit","useModelGeometry","getBBox","getArea","paperToLocalRect","getRestrictedArea","args","restrictedArea","apply","createViewForModel","optionalViewClass","defaultViewClass","get","namespaceViewClass","isLink","ViewClass","prototype","create","onImageDragStart","sortViewsExact","$cells","a","b","cellA","cellB","zA","z","zB","insertSortedNode","insertNode","onMount","unmount","onDetach","matrixToScale","newTx","newTy","d","rotate","angle","cx","cy","matrixToRotate","bbox","matrixToTranslate","e","f","findView","querySelector","findAttribute","findViewsFromPoint","p","getElements","map","target","containsPoint","findViewsInArea","rect","strict","method","removeTools","dispatchToolsEvent","hideTools","showTools","getModelById","getCell","snapToGrid","clientToLocalPoint","localToPaperPoint","localPoint","paperPoint","transformPoint","localRect","paperRect","transformRect","inverse","localToClientPoint","clientPoint","localToClientRect","clientRect","clientToLocalRect","localToPagePoint","offset","pageOffset","localToPageRect","pageToLocalPoint","pagePoint","difference","pageToLocalRect","clientOffset","getBoundingClientRect","window","scrollX","scrollY","linkAllowed","paperOptions","constructor","validations","getDefaultLink","clone","resolveHighlighter","highlighter","highlighterDef","highlight","unhighlight","magnetEl","highlighterDescriptor","pointerdblclick","preventDefault","clientX","clientY","pointerclick","eventData","mousemoved","contextmenu","contextMenuFired","contextMenuTrigger","pointerdown","button","isContextMenu","isTargetFormNode","preventDefaultInteraction","rootViewEl","eventNode","closest","contains","eventEvt","Event","originalEvent","currentTarget","onevent","isDefaultPrevented","isPropagationStopped","magnetNode","magnetEvt","onmagnet","delegateDragEvents","contextmenuEvt","pointermove","undelegateEvents","pointerup","undelegateDocumentEvents","normalizedEvt","delegateEvents","mouseover","mouseout","mouseenter","relatedTarget","relatedView","mouseleave","_processMouseWheelEvtBuf","deltaY","reduce","acc","pow","maxWait","mousewheel","deltaX","pinchHandlers","_events","ctrlKey","delta","wheelDelta","eventName","magnetEvent","handler","magnetValue","magnetContextMenuFired","magnetContextMenuTrigger","stopPropagation","magnetpointerdblclick","magnetcontextmenu","onlabel","labelNode","getPointerArgs","delegateDocumentEvents","guarded","setGridSize","clearGrid","_getGridRefs","_gridCache","root","patterns","add","node","append","fill","exist","_gridSettings","optionsList","isArray","item","_resolveDrawGridOption","gridPatterns","markup","pattern","localOptions","refs","gridLayerSetting","index","scaleFactor","patternUnits","patternDefVel","attr","patternUri","XMLSerializer","serializeToString","btoa","backgroundPosition","backgroundSize","size","drawBackgroundImage","img","HTMLImageElement","backgroundImage","backgroundRepeat","repeat","backgroundOpacity","opacity","backgroundQuality","abs","quality","backgroundPattern","backgroundPatterns","canvas","HTMLCanvasElement","toDataURL","src","updateBackgroundColor","color","image","document","createElement","onload","bind","setInteractivity","value","isDefined","defId","getElementById","defineFilter","TypeError","filterId","JSON","stringify","filterSVGString","filterAttrs","filterUnits","attrs","appendTo","defineGradient","gradient","stops","stopVEls","isFinite","gradientVEl","definePattern","patternVEl","fragment","defineMarker","marker","markerUnits","markerVEl","orient","markerContentVEl","markupVEl","markerAttrs","markerAttrsKeys","markupValue","Layers","flipXy","imgWidth","imgHeight","ctx","getContext","drawImage","setTransform","flipX","flipY","watermark","watermarkAngle","radians","stepX","stepY","dot","thickness","fixedDot","mesh","join","stroke","doubleMesh"],"sources":["/Users/lijiaxin/Documents/workspace/hydsoft-oms-frontend/node_modules/jointjs/src/dia/Paper.mjs"],"sourcesContent":["import V from '../V/index.mjs';\nimport {\n    isNumber,\n    assign,\n    nextFrame,\n    isObject,\n    cancelFrame,\n    defaults,\n    defaultsDeep,\n    addClassNamePrefix,\n    normalizeSides,\n    isFunction,\n    isPlainObject,\n    getByPath,\n    sortElements,\n    isString,\n    guid,\n    normalizeEvent,\n    normalizeWheel,\n    cap,\n    debounce,\n    omit,\n    result,\n    merge,\n    camelCase,\n    cloneDeep,\n    invoke,\n    hashCode,\n    filter as _filter,\n    parseDOMJSON,\n    toArray,\n    has\n} from '../util/index.mjs';\nimport { Rect, Point, toRad } from '../g/index.mjs';\nimport { View, views } from '../mvc/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { ElementView } from './ElementView.mjs';\nimport { LinkView } from './LinkView.mjs';\nimport { Link } from './Link.mjs';\nimport { Cell } from './Cell.mjs';\nimport { Graph } from './Graph.mjs';\nimport { LayersNames, PaperLayer } from './PaperLayer.mjs';\nimport * as highlighters from '../highlighters/index.mjs';\nimport * as linkAnchors from '../linkAnchors/index.mjs';\nimport * as connectionPoints from '../connectionPoints/index.mjs';\nimport * as anchors from '../anchors/index.mjs';\n\nimport $ from 'jquery';\nimport Backbone from 'backbone';\n\nconst sortingTypes = {\n    NONE: 'sorting-none',\n    APPROX: 'sorting-approximate',\n    EXACT: 'sorting-exact'\n};\n\nconst WHEEL_CAP = 50;\nconst WHEEL_WAIT_MS = 20;\nconst MOUNT_BATCH_SIZE = 1000;\nconst UPDATE_BATCH_SIZE = Infinity;\nconst MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\nconst HighlightingTypes = CellView.Highlighting;\n\nconst defaultHighlighting = {\n    [HighlightingTypes.DEFAULT]: {\n        name: 'stroke',\n        options: {\n            padding: 3\n        }\n    },\n    [HighlightingTypes.MAGNET_AVAILABILITY]: {\n        name: 'addClass',\n        options: {\n            className: 'available-magnet'\n        }\n    },\n    [HighlightingTypes.ELEMENT_AVAILABILITY]: {\n        name: 'addClass',\n        options: {\n            className: 'available-cell'\n        }\n    }\n};\n\nconst defaultLayers = [{\n    name: LayersNames.BACK,\n}, {\n    name: LayersNames.CELLS,\n}, {\n    name: LayersNames.LABELS,\n}, {\n    name: LayersNames.FRONT\n}, {\n    name: LayersNames.TOOLS\n}];\n\nexport const Paper = View.extend({\n\n    className: 'paper',\n\n    options: {\n\n        width: 800,\n        height: 600,\n        origin: { x: 0, y: 0 }, // x,y coordinates in top-left corner\n        gridSize: 1,\n        // Whether or not to draw the grid lines on the paper's DOM element.\n        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n        drawGrid: false,\n        // If not set, the size of the visual grid is the same as the `gridSize`.\n        drawGridSize: null,\n\n        // Whether or not to draw the background on the paper's DOM element.\n        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n        background: false,\n\n        perpendicularLinks: false,\n        elementView: ElementView,\n        linkView: LinkView,\n        snapLabels: false, // false, true\n        snapLinks: false, // false, true, { radius: value }\n        snapLinksSelf: false, // false, true, { radius: value }\n\n        // Should the link labels be rendered into its own layer?\n        // `false` - the labels are part of the links\n        // `true` - the labels are appended to LayersName.LABELS\n        // [LayersName] - the labels are appended to the layer specified\n        labelsLayer: false,\n\n        // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n        multiLinks: true,\n\n        // For adding custom guard logic.\n        guard: function(evt, view) {\n\n            // FALSE means the event isn't guarded.\n            return false;\n        },\n\n        highlighting: defaultHighlighting,\n\n        // Prevent the default context menu from being displayed.\n        preventContextMenu: true,\n\n        // Prevent the default action for blank:pointer<action>.\n        preventDefaultBlankAction: true,\n\n        // Prevent the default action for cell:pointer<action>.\n        preventDefaultViewAction: true,\n\n        // Restrict the translation of elements by given bounding box.\n        // Option accepts a boolean:\n        //  true - the translation is restricted to the paper area\n        //  false - no restrictions\n        // A method:\n        // restrictTranslate: function(elementView) {\n        //     var parentId = elementView.model.get('parent');\n        //     return parentId && this.model.getCell(parentId).getBBox();\n        // },\n        // Or a bounding box:\n        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n        restrictTranslate: false,\n\n        // Marks all available magnets with 'available-magnet' class name and all available cells with\n        // 'available-cell' class name. Marks them when dragging a link is started and unmark\n        // when the dragging is stopped.\n        markAvailable: false,\n\n        // Defines what link model is added to the graph after an user clicks on an active magnet.\n        // Value could be the Backbone.model or a function returning the Backbone.model\n        // defaultLink: function(elementView, magnet) { return condition ? new customLink1() : new customLink2() }\n        defaultLink: new Link,\n\n        // A connector that is used by links with no connector defined on the model.\n        // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n        defaultConnector: { name: 'normal' },\n\n        // A router that is used by links with no router defined on the model.\n        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n        defaultRouter: { name: 'normal' },\n\n        defaultAnchor: { name: 'center' },\n\n        defaultLinkAnchor: { name: 'connectionRatio' },\n\n        defaultConnectionPoint: { name: 'bbox' },\n\n        /* CONNECTING */\n\n        connectionStrategy: null,\n\n        // Check whether to add a new link to the graph when user clicks on an a magnet.\n        validateMagnet: function(_cellView, magnet, _evt) {\n            return magnet.getAttribute('magnet') !== 'passive';\n        },\n\n        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n        // being changed.\n        validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n            return (end === 'target' ? cellViewT : cellViewS) instanceof ElementView;\n        },\n\n        /* EMBEDDING */\n\n        // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n        // all links and elements are visible taken the level of embedding into account.\n        embeddingMode: false,\n\n        // Check whether to allow or disallow the element embedding while an element being translated.\n        validateEmbedding: function(childView, parentView) {\n            // by default all elements can be in relation child-parent\n            return true;\n        },\n\n        // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n        validateUnembedding: function(childView) {\n            // by default all elements can become roots\n            return true;\n        },\n\n        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n        // The cell with the highest z-index (visually on the top) will be chosen.\n        findParentBy: 'bbox', // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n        // If enabled only the element on the very front is taken into account for the embedding.\n        // If disabled the elements under the dragged view are tested one by one\n        // (from front to back) until a valid parent found.\n        frontParentOnly: true,\n\n        // Interactive flags. See online docs for the complete list of interactive flags.\n        interactive: {\n            labelMove: false\n        },\n\n        // When set to true the links can be pinned to the paper.\n        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n        linkPinning: true,\n\n        // Custom validation after an interaction with a link ends.\n        // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n        // (linkView, paper) => boolean\n        allowLink: null,\n\n        // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n        clickThreshold: 0,\n\n        // Number of required mousemove events before the first pointermove event will be triggered.\n        moveThreshold: 0,\n\n        // Number of required mousemove events before a link is created out of the magnet.\n        // Or string `onleave` so the link is created when the pointer leaves the magnet\n        magnetThreshold: 0,\n\n        // Rendering Options\n\n        sorting: sortingTypes.EXACT,\n\n        frozen: false,\n\n        autoFreeze: false,\n\n        // no docs yet\n        onViewUpdate: function(view, flag, priority, opt, paper) {\n            // Do not update connected links when:\n            // 1. the view was just inserted (added to the graph and rendered)\n            // 2. the view was just mounted (added back to the paper by viewport function)\n            // 3. the change was marked as `isolate`.\n            // 4. the view model was just removed from the graph\n            if ((flag & (view.FLAG_INSERT | view.FLAG_REMOVE)) || opt.mounting || opt.isolate) return;\n            paper.requestConnectedLinksUpdate(view, priority, opt);\n        },\n\n        // no docs yet\n        onViewPostponed: function(view, flag, paper) {\n            return paper.forcePostponedViewUpdate(view, flag);\n        },\n\n        beforeRender: null, // function(opt, paper) { },\n\n        afterRender: null, // function(stats, opt, paper) {\n\n        viewport: null,\n\n        // Default namespaces\n\n        cellViewNamespace: null,\n\n        routerNamespace: null,\n\n        connectorNamespace: null,\n\n        highlighterNamespace: highlighters,\n\n        anchorNamespace: anchors,\n\n        linkAnchorNamespace: linkAnchors,\n\n        connectionPointNamespace: connectionPoints,\n\n        overflow: false\n    },\n\n    events: {\n        'dblclick': 'pointerdblclick',\n        'dbltap': 'pointerdblclick',\n        'contextmenu': 'contextmenu',\n        'mousedown': 'pointerdown',\n        'touchstart': 'pointerdown',\n        'mouseover': 'mouseover',\n        'mouseout': 'mouseout',\n        'mouseenter': 'mouseenter',\n        'mouseleave': 'mouseleave',\n        'wheel': 'mousewheel',\n        'mouseenter .joint-cell': 'mouseenter',\n        'mouseleave .joint-cell': 'mouseleave',\n        'mouseenter .joint-tools': 'mouseenter',\n        'mouseleave .joint-tools': 'mouseleave',\n        'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n        'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n        'mousedown .joint-link .label': 'onlabel', // interaction with link label\n        'touchstart .joint-link .label': 'onlabel',\n        'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n    },\n\n    documentEvents: {\n        'mousemove': 'pointermove',\n        'touchmove': 'pointermove',\n        'mouseup': 'pointerup',\n        'touchend': 'pointerup',\n        'touchcancel': 'pointerup'\n    },\n\n    svg: null,\n    viewport: null,\n    defs: null,\n    tools: null,\n    $background: null,\n    layers: null,\n    $grid: null,\n    $document: null,\n\n    // For storing the current transformation matrix (CTM) of the paper's viewport.\n    _viewportMatrix: null,\n    // For verifying whether the CTM is up-to-date. The viewport transform attribute\n    // could have been manipulated directly.\n    _viewportTransformString: null,\n    // Updates data (priorities, unmounted views etc.)\n    _updates: null,\n    // Paper Layers\n    _layers: null,\n\n    SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n    UPDATE_DELAYING_BATCHES: ['translate'],\n    // If you interact with these elements,\n    // the default interaction such as `element move` is prevented.\n    FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'] ,\n    // If you interact with these elements, the events are not propagated to the paper\n    // i.e. paper events such as `element:pointerdown` are not triggered.\n    GUARDED_TAG_NAMES: [\n        // Guard <select> for consistency. When you click on it:\n        // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n        // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n        //          on close. However, if you open and then close by clicking elsewhere on the page,\n        //           no other event is triggered.\n        // Safari: when you open it, it triggers `pointerdown`. That's it.\n        'SELECT',\n    ],\n    MIN_SCALE: 1e-6,\n\n    init: function() {\n\n        const { options, el } = this;\n        if (!options.cellViewNamespace) {\n            /* eslint-disable no-undef */\n            options.cellViewNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n        const model = this.model = options.model || new Graph;\n\n        // Layers (SVGGroups)\n        this._layers = {};\n\n        this.setGrid(options.drawGrid);\n        this.cloneOptions();\n        this.render();\n        this._setDimensions();\n        this.startListening();\n\n        // Hash of all cell views.\n        this._views = {};\n\n        // Mouse wheel events buffer\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: [],\n        };\n\n        // Reference to the paper owner document\n        this.$document = $(el.ownerDocument);\n        // Render existing cells in the graph\n        this.resetViews(model.attributes.cells.models);\n        // Start the Rendering Loop\n        if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();\n    },\n\n    _resetUpdates: function() {\n        return this._updates = {\n            id: null,\n            priorities: [{}, {}, {}],\n            unmountedCids: [],\n            mountedCids: [],\n            unmounted: {},\n            mounted: {},\n            count: 0,\n            keyFrozen: false,\n            freezeKey: null,\n            sort: false,\n            disabled: false,\n            idle: false\n        };\n    },\n\n    startListening: function() {\n        var model = this.model;\n        this.listenTo(model, 'add', this.onCellAdded)\n            .listenTo(model, 'remove', this.onCellRemoved)\n            .listenTo(model, 'change', this.onCellChange)\n            .listenTo(model, 'reset', this.onGraphReset)\n            .listenTo(model, 'sort', this.onGraphSort)\n            .listenTo(model, 'batch:stop', this.onGraphBatchStop);\n        this.on('cell:highlight', this.onCellHighlight)\n            .on('cell:unhighlight', this.onCellUnhighlight)\n            .on('scale translate', this.update);\n    },\n\n    onCellAdded: function(cell, _, opt) {\n        var position = opt.position;\n        if (this.isAsync() || !isNumber(position)) {\n            this.renderView(cell, opt);\n        } else {\n            if (opt.maxPosition === position) this.freeze({ key: 'addCells' });\n            this.renderView(cell, opt);\n            if (position === 0) this.unfreeze({ key: 'addCells' });\n        }\n    },\n\n    onCellRemoved: function(cell, _, opt) {\n        const view = this.findViewByModel(cell);\n        if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);\n    },\n\n    onCellChange: function(cell, opt) {\n        if (cell === this.model.attributes.cells) return;\n        if (cell.hasChanged('z') && this.options.sorting === sortingTypes.APPROX) {\n            const view = this.findViewByModel(cell);\n            if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    onGraphReset: function(collection, opt) {\n        this.resetLayers();\n        this.resetViews(collection.models, opt);\n    },\n\n    onGraphSort: function() {\n        if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n        this.sortViews();\n    },\n\n    onGraphBatchStop: function(data) {\n        if (this.isFrozen()) return;\n        var name = data && data.batchName;\n        var graph = this.model;\n        if (!this.isAsync()) {\n            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n                this.updateViews(data);\n            }\n        }\n        var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n        if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {\n            this.sortViews();\n        }\n    },\n\n    cloneOptions: function() {\n\n        const { options } = this;\n        const {\n            defaultConnector,\n            defaultRouter,\n            defaultConnectionPoint,\n            defaultAnchor,\n            defaultLinkAnchor,\n            origin,\n            highlighting,\n            cellViewNamespace,\n            interactive\n        } = options;\n\n        // Default cellView namespace for ES5\n        /* eslint-disable no-undef */\n        if (!cellViewNamespace && typeof joint !== 'undefined' && has(joint, 'shapes')) {\n            options.cellViewNamespace = joint.shapes;\n        }\n        /* eslint-enable no-undef */\n\n        // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n        // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n        if (!isFunction(defaultConnector)) {\n            options.defaultConnector = cloneDeep(defaultConnector);\n        }\n        if (!isFunction(defaultRouter)) {\n            options.defaultRouter = cloneDeep(defaultRouter);\n        }\n        if (!isFunction(defaultConnectionPoint)) {\n            options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);\n        }\n        if (!isFunction(defaultAnchor)) {\n            options.defaultAnchor = cloneDeep(defaultAnchor);\n        }\n        if (!isFunction(defaultLinkAnchor)) {\n            options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);\n        }\n        if (isPlainObject(interactive)) {\n            options.interactive = assign({}, interactive);\n        }\n        if (isPlainObject(highlighting)) {\n            // Return the default highlighting options into the user specified options.\n            options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);\n        }\n        options.origin = assign({}, origin);\n    },\n\n    children: function() {\n        var ns = V.namespace;\n        return [{\n            namespaceURI: ns.xhtml,\n            tagName: 'div',\n            className: addClassNamePrefix('paper-background'),\n            selector: 'background'\n        }, {\n            namespaceURI: ns.xhtml,\n            tagName: 'div',\n            className: addClassNamePrefix('paper-grid'),\n            selector: 'grid'\n        }, {\n            namespaceURI: ns.svg,\n            tagName: 'svg',\n            attributes: {\n                'width': '100%',\n                'height': '100%',\n                'xmlns:xlink': ns.xlink\n            },\n            selector: 'svg',\n            children: [{\n                // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n                // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n                tagName: 'defs',\n                selector: 'defs'\n            }, {\n                tagName: 'g',\n                className: addClassNamePrefix('layers'),\n                selector: 'layers'\n            }]\n        }];\n    },\n\n    hasLayerView(layerName) {\n        return  (layerName in this._layers);\n    },\n\n    getLayerView(layerName) {\n        const { _layers } = this;\n        if (layerName in _layers) return _layers[layerName];\n        throw new Error(`dia.Paper: Unknown layer \"${layerName}\"`);\n    },\n\n    getLayerNode(layerName) {\n        return this.getLayerView(layerName).el;\n    },\n\n    render: function() {\n\n        this.renderChildren();\n        const { childNodes, options } = this;\n        const { svg, defs, layers, background, grid } = childNodes;\n\n        svg.style.overflow = options.overflow ? 'visible' : 'hidden';\n\n        this.svg = svg;\n        this.defs = defs;\n        this.layers = layers;\n        this.$background = $(background);\n        this.$grid = $(grid);\n\n        this.renderLayers();\n\n        V.ensureId(svg);\n\n        if (options.background) {\n            this.drawBackground(options.background);\n        }\n\n        if (options.drawGrid) {\n            this.drawGrid();\n        }\n\n        return this;\n    },\n\n    renderLayers: function(layers = defaultLayers) {\n        this.removeLayers();\n        // TODO: Layers to be read from the graph `layers` attribute\n        layers.forEach(({ name, sorted }) => {\n            const layerView = new PaperLayer({ name });\n            this.layers.appendChild(layerView.el);\n            this._layers[name] = layerView;\n        });\n        // Throws an exception if doesn't exist\n        const cellsLayerView = this.getLayerView(LayersNames.CELLS);\n        const toolsLayerView = this.getLayerView(LayersNames.TOOLS);\n        const labelsLayerView = this.getLayerView(LayersNames.LABELS);\n        // backwards compatibility\n        this.tools = toolsLayerView.el;\n        this.cells = this.viewport = cellsLayerView.el;\n        // user-select: none;\n        cellsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n        labelsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n    },\n\n    removeLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach(name => {\n            _layers[name].remove();\n            delete _layers[name];\n        });\n    },\n\n    resetLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach(name => {\n            _layers[name].removePivots();\n        });\n    },\n\n    update: function() {\n\n        if (this.options.drawGrid) {\n            this.drawGrid();\n        }\n\n        if (this._background) {\n            this.updateBackgroundImage(this._background);\n        }\n\n        return this;\n    },\n\n    matrix: function(ctm) {\n\n        var viewport = this.layers;\n\n        // Getter:\n        if (ctm === undefined) {\n\n            var transformString = viewport.getAttribute('transform');\n\n            if ((this._viewportTransformString || null) === transformString) {\n                // It's ok to return the cached matrix. The transform attribute has not changed since\n                // the matrix was stored.\n                ctm = this._viewportMatrix;\n            } else {\n                // The viewport transform attribute has changed. Measure the matrix and cache again.\n                ctm = viewport.getCTM();\n                this._viewportMatrix = ctm;\n                this._viewportTransformString = transformString;\n            }\n\n            // Clone the cached current transformation matrix.\n            // If no matrix previously stored the identity matrix is returned.\n            return V.createSVGMatrix(ctm);\n        }\n\n        // Setter:\n        ctm = V.createSVGMatrix(ctm);\n        var ctmString = V.matrixToTransformString(ctm);\n        viewport.setAttribute('transform', ctmString);\n\n        this._viewportMatrix = ctm;\n        this._viewportTransformString = viewport.getAttribute('transform');\n\n        return this;\n    },\n\n    clientMatrix: function() {\n\n        return V.createSVGMatrix(this.cells.getScreenCTM());\n    },\n\n    requestConnectedLinksUpdate: function(view, priority, opt) {\n        if (view instanceof CellView) {\n            var model = view.model;\n            var links = this.model.getConnectedLinks(model);\n            for (var j = 0, n = links.length; j < n; j++) {\n                var link = links[j];\n                var linkView = this.findViewByModel(link);\n                if (!linkView) continue;\n                var flagLabels = ['UPDATE'];\n                if (link.getTargetCell() === model) flagLabels.push('TARGET');\n                if (link.getSourceCell() === model) flagLabels.push('SOURCE');\n                var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n                this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n            }\n        }\n    },\n\n    forcePostponedViewUpdate: function(view, flag) {\n        if (!view || !(view instanceof CellView)) return false;\n        var model = view.model;\n        if (model.isElement()) return false;\n        if ((flag & view.getFlag(['SOURCE', 'TARGET'])) === 0) {\n            var dumpOptions = { silent: true };\n            // LinkView is waiting for the target or the source cellView to be rendered\n            // This can happen when the cells are not in the viewport.\n            var sourceFlag = 0;\n            var sourceView = this.findViewByModel(model.getSourceCell());\n            if (sourceView && !this.isViewMounted(sourceView)) {\n                sourceFlag = this.dumpView(sourceView, dumpOptions);\n                view.updateEndMagnet('source');\n            }\n            var targetFlag = 0;\n            var targetView = this.findViewByModel(model.getTargetCell());\n            if (targetView && !this.isViewMounted(targetView)) {\n                targetFlag = this.dumpView(targetView, dumpOptions);\n                view.updateEndMagnet('target');\n            }\n            if (sourceFlag === 0 && targetFlag === 0) {\n                // If leftover flag is 0, all view updates were done.\n                return !this.dumpView(view, dumpOptions);\n            }\n        }\n        return false;\n    },\n\n    requestViewUpdate: function(view, flag, priority, opt) {\n        opt || (opt = {});\n        this.scheduleViewUpdate(view, flag, priority, opt);\n        var isAsync = this.isAsync();\n        if (this.isFrozen() || (isAsync && opt.async !== false)) return;\n        if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n        var stats = this.updateViews(opt);\n        if (isAsync) this.notifyAfterRender(stats, opt);\n    },\n\n    scheduleViewUpdate: function(view, type, priority, opt) {\n        const { _updates: updates, options } = this;\n        if (updates.idle) {\n            if (options.autoFreeze) {\n                updates.idle = false;\n                this.unfreeze();\n            }\n        }\n        const { FLAG_REMOVE, FLAG_INSERT, UPDATE_PRIORITY, cid } = view;\n        let priorityUpdates = updates.priorities[priority];\n        if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n        // Move higher priority updates to this priority\n        if (priority > UPDATE_PRIORITY) {\n            // Not the default priority for this view. It's most likely a link view\n            // connected to another link view, which triggered the update.\n            // TODO: If there is an update scheduled with a lower priority already, we should\n            // change the requested priority to the lowest one. Does not seem to be critical\n            // right now, as it \"only\" results in multiple updates on the same view.\n            for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n                const prevPriorityUpdates = updates.priorities[i];\n                if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n                priorityUpdates[cid] |= prevPriorityUpdates[cid];\n                delete prevPriorityUpdates[cid];\n            }\n        }\n        let currentType = priorityUpdates[cid] || 0;\n        // Prevent cycling\n        if ((currentType & type) === type) return;\n        if (!currentType) updates.count++;\n        if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n            // When a view is removed we need to remove the insert flag as this is a reinsert\n            priorityUpdates[cid] ^= FLAG_INSERT;\n        } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n            // When a view is added we need to remove the remove flag as this is view was previously removed\n            priorityUpdates[cid] ^= FLAG_REMOVE;\n        }\n        priorityUpdates[cid] |= type;\n        const viewUpdateFn = options.onViewUpdate;\n        if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n    },\n\n    dumpViewUpdate: function(view) {\n        if (!view) return 0;\n        var updates = this._updates;\n        var cid = view.cid;\n        var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n        var flag = this.registerMountedView(view) | priorityUpdates[cid];\n        delete priorityUpdates[cid];\n        return flag;\n    },\n\n    dumpView: function(view, opt = {}) {\n        const flag = this.dumpViewUpdate(view);\n        if (!flag) return 0;\n        const shouldNotify = !opt.silent;\n        if (shouldNotify) this.notifyBeforeRender(opt);\n        const leftover = this.updateView(view, flag, opt);\n        if (shouldNotify) {\n            const stats = { updated: 1, priority: view.UPDATE_PRIORITY };\n            this.notifyAfterRender(stats, opt);\n        }\n        return leftover;\n    },\n\n    updateView: function(view, flag, opt) {\n        if (!view) return 0;\n        const { FLAG_REMOVE, FLAG_INSERT, FLAG_INIT, model } = view;\n        if (view instanceof CellView) {\n            if (flag & FLAG_REMOVE) {\n                this.removeView(model);\n                return 0;\n            }\n            if (flag & FLAG_INSERT) {\n                const isInitialInsert = !!(flag & FLAG_INIT);\n                if (isInitialInsert) {\n                    flag ^= FLAG_INIT;\n                }\n                this.insertView(view, isInitialInsert);\n                flag ^= FLAG_INSERT;\n            }\n        }\n        if (!flag) return 0;\n        return view.confirmUpdate(flag, opt || {});\n    },\n\n    requireView: function(model, opt) {\n        var view = this.findViewByModel(model);\n        if (!view) return null;\n        this.dumpView(view, opt);\n        return view;\n    },\n\n    registerUnmountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.unmounted) return 0;\n        var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n        updates.unmountedCids.push(cid);\n        delete updates.mounted[cid];\n        return flag;\n    },\n\n    registerMountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.mounted) return 0;\n        updates.mounted[cid] = true;\n        updates.mountedCids.push(cid);\n        var flag = updates.unmounted[cid] || 0;\n        delete updates.unmounted[cid];\n        return flag;\n    },\n\n    isViewMounted: function(view) {\n        if (!view) return false;\n        var cid = view.cid;\n        var updates = this._updates;\n        return (cid in updates.mounted);\n    },\n\n    dumpViews: function(opt) {\n        var passingOpt = defaults({}, opt, { viewport: null });\n        this.checkViewport(passingOpt);\n        this.updateViews(passingOpt);\n    },\n\n    // Synchronous views update\n    updateViews: function(opt) {\n        this.notifyBeforeRender(opt);\n        let batchStats;\n        let updateCount = 0;\n        let batchCount = 0;\n        let priority = MIN_PRIORITY;\n        do {\n            batchCount++;\n            batchStats = this.updateViewsBatch(opt);\n            updateCount += batchStats.updated;\n            priority = Math.min(batchStats.priority, priority);\n        } while (!batchStats.empty);\n        const stats = { updated: updateCount, batches: batchCount, priority };\n        this.notifyAfterRender(stats, opt);\n        return stats;\n    },\n\n    hasScheduledUpdates: function() {\n        const priorities = this._updates.priorities;\n        const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        let i = priorityIndexes.length;\n        while (i > 0 && i--) {\n            // a faster way how to check if an object is empty\n            for (let _key in priorities[priorityIndexes[i]]) return true;\n        }\n        return false;\n    },\n\n    updateViewsAsync: function(opt, data) {\n        opt || (opt = {});\n        data || (data = { processed: 0, priority: MIN_PRIORITY });\n        const { _updates: updates, options } = this;\n        const id = updates.id;\n        if (id) {\n            cancelFrame(id);\n            if (data.processed === 0 && this.hasScheduledUpdates()) {\n                this.notifyBeforeRender(opt);\n            }\n            const stats = this.updateViewsBatch(opt);\n            const passingOpt = defaults({}, opt, {\n                mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n                unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n            });\n            const checkStats = this.checkViewport(passingOpt);\n            const unmountCount = checkStats.unmounted;\n            const mountCount = checkStats.mounted;\n            let processed = data.processed;\n            const total = updates.count;\n            if (stats.updated > 0) {\n                // Some updates have been just processed\n                processed += stats.updated + stats.unmounted;\n                stats.processed = processed;\n                data.priority = Math.min(stats.priority, data.priority);\n                if (stats.empty && mountCount === 0) {\n                    stats.unmounted += unmountCount;\n                    stats.mounted += mountCount;\n                    stats.priority = data.priority;\n                    this.notifyAfterRender(stats, opt);\n                    data.processed = 0;\n                    data.priority = MIN_PRIORITY;\n                    updates.count = 0;\n                } else {\n                    data.processed = processed;\n                }\n            } else {\n                if (!updates.idle) {\n                    if (options.autoFreeze) {\n                        this.freeze();\n                        updates.idle = true;\n                        this.trigger('render:idle', opt);\n                    }\n                }\n            }\n            // Progress callback\n            const progressFn = opt.progress;\n            if (total && typeof progressFn === 'function') {\n                progressFn.call(this, stats.empty, processed, total, stats, this);\n            }\n            // The current frame could have been canceled in a callback\n            if (updates.id !== id) return;\n        }\n        if (updates.disabled) {\n            throw new Error('dia.Paper: can not unfreeze the paper after it was removed');\n        }\n        updates.id = nextFrame(this.updateViewsAsync, this, opt, data);\n    },\n\n    notifyBeforeRender: function(opt = {}) {\n        let beforeFn = opt.beforeRender;\n        if (typeof beforeFn !== 'function') {\n            beforeFn = this.options.beforeRender;\n            if (typeof beforeFn !== 'function') return;\n        }\n        beforeFn.call(this, opt, this);\n    },\n\n    notifyAfterRender: function(stats, opt = {}) {\n        let afterFn = opt.afterRender;\n        if (typeof afterFn !== 'function') {\n            afterFn = this.options.afterRender;\n        }\n        if (typeof afterFn === 'function') {\n            afterFn.call(this, stats, opt, this);\n        }\n        this.trigger('render:done', stats, opt);\n    },\n\n    updateViewsBatch: function(opt) {\n        opt || (opt = {});\n        var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n        var updates = this._updates;\n        var updateCount = 0;\n        var postponeCount = 0;\n        var unmountCount = 0;\n        var mountCount = 0;\n        var maxPriority = MIN_PRIORITY;\n        var empty = true;\n        var options = this.options;\n        var priorities = updates.priorities;\n        var viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        var postponeViewFn = options.onViewPostponed;\n        if (typeof postponeViewFn !== 'function') postponeViewFn = null;\n        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n            var priority = +priorityIndexes[i];\n            var priorityUpdates = priorities[priority];\n            for (var cid in priorityUpdates) {\n                if (updateCount >= batchSize) {\n                    empty = false;\n                    break main;\n                }\n                var view = views[cid];\n                if (!view) {\n                    // This should not occur\n                    delete priorityUpdates[cid];\n                    continue;\n                }\n                var currentFlag = priorityUpdates[cid];\n                if ((currentFlag & view.FLAG_REMOVE) === 0) {\n                    // We should never check a view for viewport if we are about to remove the view\n                    var isDetached = cid in updates.unmounted;\n                    if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n                        // Unmount View\n                        if (!isDetached) {\n                            this.registerUnmountedView(view);\n                            this.detachView(view);\n                        }\n                        updates.unmounted[cid] |= currentFlag;\n                        delete priorityUpdates[cid];\n                        unmountCount++;\n                        continue;\n                    }\n                    // Mount View\n                    if (isDetached) {\n                        currentFlag |= view.FLAG_INSERT;\n                        mountCount++;\n                    }\n                    currentFlag |= this.registerMountedView(view);\n                }\n                var leftoverFlag = this.updateView(view, currentFlag, opt);\n                if (leftoverFlag > 0) {\n                    // View update has not finished completely\n                    priorityUpdates[cid] = leftoverFlag;\n                    if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n                        postponeCount++;\n                        empty = false;\n                        continue;\n                    }\n                }\n                if (maxPriority > priority) maxPriority = priority;\n                updateCount++;\n                delete priorityUpdates[cid];\n            }\n        }\n        return {\n            priority: maxPriority,\n            updated: updateCount,\n            postponed: postponeCount,\n            unmounted: unmountCount,\n            mounted: mountCount,\n            empty: empty\n        };\n    },\n\n    getUnmountedViews: function() {\n        const updates = this._updates;\n        const unmountedCids = Object.keys(updates.unmounted);\n        const n = unmountedCids.length;\n        const unmountedViews = new Array(n);\n        for (var i = 0; i < n; i++) {\n            unmountedViews[i] = views[unmountedCids[i]];\n        }\n        return unmountedViews;\n    },\n\n    getMountedViews: function() {\n        const updates = this._updates;\n        const mountedCids = Object.keys(updates.mounted);\n        const n = mountedCids.length;\n        const mountedViews = new Array(n);\n        for (var i = 0; i < n; i++) {\n            mountedViews[i] = views[mountedCids[i]];\n        }\n        return mountedViews;\n    },\n\n    checkUnmountedViews: function(viewportFn, opt) {\n        opt || (opt  = {});\n        var mountCount = 0;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n        var updates = this._updates;\n        var unmountedCids = updates.unmountedCids;\n        var unmounted = updates.unmounted;\n        for (var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++) {\n            var cid = unmountedCids[i];\n            if (!(cid in unmounted)) continue;\n            var view = views[cid];\n            if (!view) continue;\n            if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n                // Push at the end of all unmounted ids, so this can be check later again\n                unmountedCids.push(cid);\n                continue;\n            }\n            mountCount++;\n            var flag = this.registerMountedView(view);\n            if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, { mounting: true });\n        }\n        // Get rid of views, that have been mounted\n        unmountedCids.splice(0, i);\n        return mountCount;\n    },\n\n    checkMountedViews: function(viewportFn, opt) {\n        opt || (opt = {});\n        var unmountCount = 0;\n        if (typeof viewportFn !== 'function') return unmountCount;\n        var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n        var updates = this._updates;\n        var mountedCids = updates.mountedCids;\n        var mounted = updates.mounted;\n        for (var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++) {\n            var cid = mountedCids[i];\n            if (!(cid in mounted)) continue;\n            var view = views[cid];\n            if (!view) continue;\n            if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n                // Push at the end of all mounted ids, so this can be check later again\n                mountedCids.push(cid);\n                continue;\n            }\n            unmountCount++;\n            var flag = this.registerUnmountedView(view);\n            if (flag) this.detachView(view);\n        }\n        // Get rid of views, that have been unmounted\n        mountedCids.splice(0, i);\n        return unmountCount;\n    },\n\n    checkViewVisibility: function(cellView, opt = {}) {\n        let viewportFn = 'viewport' in opt ? opt.viewport : this.options.viewport;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        const updates = this._updates;\n        const { mounted, unmounted } = updates;\n        const visible = !cellView.DETACHABLE || !viewportFn || viewportFn.call(this, cellView, false, this);\n\n        let isUnmounted = false;\n        let isMounted = false;\n\n        if (cellView.cid in mounted && !visible) {\n            const flag = this.registerUnmountedView(cellView);\n            if (flag) this.detachView(cellView);\n            const i = updates.mountedCids.indexOf(cellView.cid);\n            updates.mountedCids.splice(i, 1);\n            isUnmounted = true;\n        }\n\n        if (!isUnmounted && cellView.cid in unmounted && visible) {\n            const i = updates.unmountedCids.indexOf(cellView.cid);\n            updates.unmountedCids.splice(i, 1);\n            var flag = this.registerMountedView(cellView);\n            if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, { mounting: true });\n            isMounted = true;\n        }\n\n        return {\n            mounted: isMounted ? 1 : 0,\n            unmounted: isUnmounted ? 1 : 0\n        };\n    },\n\n    checkViewport: function(opt) {\n        var passingOpt = defaults({}, opt, {\n            mountBatchSize: Infinity,\n            unmountBatchSize: Infinity\n        });\n        var viewportFn = 'viewport' in passingOpt ? passingOpt.viewport : this.options.viewport;\n        var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n        if (unmountedCount > 0) {\n            // Do not check views, that have been just unmounted and pushed at the end of the cids array\n            var unmountedCids = this._updates.unmountedCids;\n            passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n        }\n        var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n        return {\n            mounted: mountedCount,\n            unmounted: unmountedCount\n        };\n    },\n\n    freeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var isFrozen = this.options.frozen;\n        var freezeKey = updates.freezeKey;\n        if (key && key !== freezeKey)  {\n            // key passed, but the paper is already freezed with another key\n            if (isFrozen && freezeKey) return;\n            updates.freezeKey = key;\n            updates.keyFrozen = isFrozen;\n        }\n        this.options.frozen = true;\n        var id = updates.id;\n        updates.id = null;\n        if (this.isAsync() && id) cancelFrame(id);\n    },\n\n    unfreeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var freezeKey = updates.freezeKey;\n        // key passed, but the paper is already freezed with another key\n        if (key && freezeKey && key !== freezeKey) return;\n        updates.freezeKey = null;\n        // key passed, but the paper is already freezed\n        if (key && key === freezeKey && updates.keyFrozen) return;\n        if (this.isAsync()) {\n            this.freeze();\n            this.updateViewsAsync(opt);\n        } else {\n            this.updateViews(opt);\n        }\n        this.options.frozen = updates.keyFrozen = false;\n        if (updates.sort) {\n            this.sortViews();\n            updates.sort = false;\n        }\n    },\n\n    isAsync: function() {\n        return !!this.options.async;\n    },\n\n    isFrozen: function() {\n        return !!this.options.frozen;\n    },\n\n    isExactSorting: function() {\n        return this.options.sorting === sortingTypes.EXACT;\n    },\n\n    onRemove: function() {\n\n        this.freeze();\n        this._updates.disabled = true;\n        //clean up all DOM elements/views to prevent memory leaks\n        this.removeLayers();\n        this.removeViews();\n    },\n\n    getComputedSize: function() {\n\n        var options = this.options;\n        var w = options.width;\n        var h = options.height;\n        if (!isNumber(w)) w = this.el.clientWidth;\n        if (!isNumber(h)) h = this.el.clientHeight;\n        return { width: w, height: h };\n    },\n\n    setDimensions: function(width, height) {\n        const { options } = this;\n        const { width: currentWidth, height: currentHeight } = options;\n        let w = (width === undefined) ? currentWidth : width;\n        let h = (height === undefined) ? currentHeight : height;\n        if (currentWidth === w && currentHeight === h) return;\n        options.width = w;\n        options.height = h;\n        this._setDimensions();\n        const computedSize = this.getComputedSize();\n        this.trigger('resize', computedSize.width, computedSize.height);\n    },\n\n    _setDimensions: function() {\n        const { options } = this;\n        let w = options.width;\n        let h = options.height;\n        if (isNumber(w)) w = Math.round(w);\n        if (isNumber(h)) h = Math.round(h);\n        this.$el.css({\n            width: (w === null) ? '' : w,\n            height: (h === null) ? '' : h\n        });\n    },\n\n    setOrigin: function(ox, oy) {\n        return this.translate(ox || 0, oy || 0);\n    },\n\n    // Expand/shrink the paper to fit the content.\n    // Alternatively signature function(opt)\n    fitToContent: function(gridWidth, gridHeight, padding, opt) {\n\n        if (isObject(gridWidth)) {\n            // first parameter is an option object\n            opt = gridWidth;\n        } else {\n            // Support for a deprecated signature\n            opt = assign({ gridWidth, gridHeight, padding }, opt);\n        }\n\n        const { x, y, width, height } = this.getFitToContentArea(opt);\n        const { sx, sy } = this.scale();\n\n        this.setOrigin(-x * sx, -y * sy);\n        this.setDimensions(width * sx, height * sy);\n\n        return new Rect(x, y, width, height);\n    },\n\n    getFitToContentArea: function(opt = {}) {\n\n        // Calculate the paper size to accommodate all the graph's elements.\n\n        const gridWidth = opt.gridWidth || 1;\n        const gridHeight = opt.gridHeight || 1;\n        const padding = normalizeSides(opt.padding || 0);\n\n        const minWidth = Math.max(opt.minWidth || 0, gridWidth);\n        const minHeight = Math.max(opt.minHeight || 0, gridHeight);\n        const maxWidth = opt.maxWidth || Number.MAX_VALUE;\n        const maxHeight = opt.maxHeight || Number.MAX_VALUE;\n        const newOrigin = opt.allowNewOrigin;\n\n        const area = ('contentArea' in opt) ? new Rect(opt.contentArea) : this.getContentArea(opt);\n        const { sx, sy } = this.scale();\n        area.x *= sx;\n        area.y *= sy;\n        area.width *= sx;\n        area.height *= sy;\n\n        let calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n        let calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n        if (!opt.allowNegativeBottomRight) {\n            calcWidth = Math.max(calcWidth, 1);\n            calcHeight = Math.max(calcHeight, 1);\n        }\n        calcWidth *= gridWidth;\n        calcHeight *= gridHeight;\n\n        let tx = 0;\n        if ((newOrigin === 'negative' && area.x < 0) || (newOrigin === 'positive' && area.x >= 0) || newOrigin === 'any') {\n            tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n            tx += padding.left;\n            calcWidth += tx;\n        }\n\n        let ty = 0;\n        if ((newOrigin === 'negative' && area.y < 0) || (newOrigin === 'positive' && area.y >= 0) || newOrigin === 'any') {\n            ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n            ty += padding.top;\n            calcHeight += ty;\n        }\n\n        calcWidth += padding.right;\n        calcHeight += padding.bottom;\n\n        // Make sure the resulting width and height are greater than minimum.\n        calcWidth = Math.max(calcWidth, minWidth);\n        calcHeight = Math.max(calcHeight, minHeight);\n\n        // Make sure the resulting width and height are lesser than maximum.\n        calcWidth = Math.min(calcWidth, maxWidth);\n        calcHeight = Math.min(calcHeight, maxHeight);\n\n        return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n    },\n\n    transformToFitContent: function(opt) {\n        opt || (opt = {});\n\n        let contentBBox, contentLocalOrigin;\n        if ('contentArea' in opt) {\n            const contentArea = opt.contentArea;\n            contentBBox = this.localToPaperRect(contentArea);\n            contentLocalOrigin = new Point(contentArea);\n        } else {\n            contentBBox = this.getContentBBox(opt);\n            contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n        }\n\n        if (!contentBBox.width || !contentBBox.height) return;\n\n        defaults(opt, {\n            padding: 0,\n            preserveAspectRatio: true,\n            scaleGrid: null,\n            minScale: 0,\n            maxScale: Number.MAX_VALUE,\n            verticalAlign: 'top',\n            horizontalAlign: 'left',\n            //minScaleX\n            //minScaleY\n            //maxScaleX\n            //maxScaleY\n            //fittingBBox\n        });\n\n        const padding = normalizeSides(opt.padding);\n\n        const minScaleX = opt.minScaleX || opt.minScale;\n        const maxScaleX = opt.maxScaleX || opt.maxScale;\n        const minScaleY = opt.minScaleY || opt.minScale;\n        const maxScaleY = opt.maxScaleY || opt.maxScale;\n\n        let fittingBBox;\n        if (opt.fittingBBox) {\n            fittingBBox = opt.fittingBBox;\n        } else {\n            const currentTranslate = this.translate();\n            const computedSize = this.getComputedSize();\n            fittingBBox = {\n                x: currentTranslate.tx,\n                y: currentTranslate.ty,\n                width: computedSize.width,\n                height: computedSize.height\n            };\n        }\n\n        fittingBBox = new Rect(fittingBBox).moveAndExpand({\n            x: padding.left,\n            y: padding.top,\n            width: -padding.left - padding.right,\n            height: -padding.top - padding.bottom\n        });\n\n        const currentScale = this.scale();\n\n        let newSx = fittingBBox.width / contentBBox.width * currentScale.sx;\n        let newSy = fittingBBox.height / contentBBox.height * currentScale.sy;\n\n        if (opt.preserveAspectRatio) {\n            newSx = newSy = Math.min(newSx, newSy);\n        }\n\n        // snap scale to a grid\n        if (opt.scaleGrid) {\n\n            const gridSize = opt.scaleGrid;\n\n            newSx = gridSize * Math.floor(newSx / gridSize);\n            newSy = gridSize * Math.floor(newSy / gridSize);\n        }\n\n        // scale min/max boundaries\n        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n\n        const scaleDiff = {\n            x: newSx / currentScale.sx,\n            y: newSy / currentScale.sy\n        };\n\n        const origin = this.options.origin;\n        let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - origin.x;\n        let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - origin.y;\n\n        switch (opt.verticalAlign) {\n            case 'middle':\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n                break;\n            case 'bottom':\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n                break;\n            case 'top':\n            default:\n                break;\n        }\n\n        switch (opt.horizontalAlign) {\n            case 'middle':\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n                break;\n            case 'right':\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n                break;\n            case 'left':\n            default:\n                break;\n        }\n\n        this.scale(newSx, newSy);\n        this.translate(newOx, newOy);\n    },\n\n    scaleContentToFit: function(opt) {\n        this.transformToFitContent(opt);\n    },\n\n    // Return the dimensions of the content area in local units (without transformations).\n    getContentArea: function(opt) {\n\n        if (opt && opt.useModelGeometry) {\n            return this.model.getBBox() || new Rect();\n        }\n\n        return V(this.cells).getBBox();\n    },\n\n    // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n    getContentBBox: function(opt) {\n\n        return this.localToPaperRect(this.getContentArea(opt));\n    },\n\n    // Returns a geometry rectangle representing the entire\n    // paper area (coordinates from the left paper border to the right one\n    // and the top border to the bottom one).\n    getArea: function() {\n\n        return this.paperToLocalRect(this.getComputedSize());\n    },\n\n    getRestrictedArea: function(...args) {\n\n        const { restrictTranslate } = this.options;\n\n        let restrictedArea;\n        if (isFunction(restrictTranslate)) {\n            // A method returning a bounding box\n            restrictedArea = restrictTranslate.apply(this, args);\n        } else if (restrictTranslate === true) {\n            // The paper area\n            restrictedArea = this.getArea();\n        } else if (!restrictTranslate) {\n            // falsy value\n            restrictedArea = null;\n        } else {\n            // any other value\n            restrictedArea = new Rect(restrictTranslate);\n        }\n\n        return restrictedArea;\n    },\n\n    createViewForModel: function(cell) {\n\n        const { options } = this;\n        // A class taken from the paper options.\n        var optionalViewClass;\n\n        // A default basic class (either dia.ElementView or dia.LinkView)\n        var defaultViewClass;\n\n        // A special class defined for this model in the corresponding namespace.\n        // e.g. joint.shapes.basic.Rect searches for joint.shapes.basic.RectView\n        var namespace = options.cellViewNamespace;\n        var type = cell.get('type') + 'View';\n        var namespaceViewClass = getByPath(namespace, type, '.');\n\n        if (cell.isLink()) {\n            optionalViewClass = options.linkView;\n            defaultViewClass = LinkView;\n        } else {\n            optionalViewClass = options.elementView;\n            defaultViewClass = ElementView;\n        }\n\n        // a) the paper options view is a class (deprecated)\n        //  1. search the namespace for a view\n        //  2. if no view was found, use view from the paper options\n        // b) the paper options view is a function\n        //  1. call the function from the paper options\n        //  2. if no view was return, search the namespace for a view\n        //  3. if no view was found, use the default\n        var ViewClass = (optionalViewClass.prototype instanceof Backbone.View)\n            ? namespaceViewClass || optionalViewClass\n            : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n\n        return new ViewClass({\n            model: cell,\n            interactive: options.interactive,\n            labelsLayer: options.labelsLayer === true ? LayersNames.LABELS : options.labelsLayer\n        });\n    },\n\n    removeView: function(cell) {\n\n        const { id } = cell;\n        const { _views, _updates } = this;\n        const view = _views[id];\n        if (view) {\n            var { cid } = view;\n            const { mounted, unmounted } = _updates;\n            view.remove();\n            delete _views[id];\n            delete mounted[cid];\n            delete unmounted[cid];\n        }\n        return view;\n    },\n\n    renderView: function(cell, opt) {\n\n        const { id } = cell;\n        const views = this._views;\n        let view, flag;\n        let create = true;\n        if (id in views) {\n            view = views[id];\n            if (view.model === cell) {\n                flag = view.FLAG_INSERT;\n                create = false;\n            } else {\n                // The view for this `id` already exist.\n                // The cell is a new instance of the model with identical id\n                // We simply remove the existing view and create a new one\n                this.removeView(cell);\n            }\n        }\n        if (create) {\n            view = views[id] = this.createViewForModel(cell);\n            view.paper = this;\n            flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag(result(view, 'initFlag'));\n        }\n        this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n        return view;\n    },\n\n    onImageDragStart: function() {\n        // This is the only way to prevent image dragging in Firefox that works.\n        // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n        return false;\n    },\n\n    resetViews: function(cells, opt) {\n        opt || (opt = {});\n        cells || (cells = []);\n        this._resetUpdates();\n        // clearing views removes any event listeners\n        this.removeViews();\n        // Allows to unfreeze normally while in the idle state using autoFreeze option\n        const key = this.options.autoFreeze ? null : 'reset';\n        this.freeze({ key });\n        for (var i = 0, n = cells.length; i < n; i++) {\n            this.renderView(cells[i], opt);\n        }\n        this.unfreeze({ key });\n        this.sortViews();\n    },\n\n    removeViews: function() {\n\n        invoke(this._views, 'remove');\n\n        this._views = {};\n    },\n\n    sortViews: function() {\n\n        if (!this.isExactSorting()) {\n            // noop\n            return;\n        }\n        if (this.isFrozen()) {\n            // sort views once unfrozen\n            this._updates.sort = true;\n            return;\n        }\n        this.sortViewsExact();\n    },\n\n    sortViewsExact: function() {\n\n        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n        // associated model `z` attribute.\n\n        var $cells = $(this.cells).children('[model-id]');\n        var cells = this.model.get('cells');\n\n        sortElements($cells, function(a, b) {\n            var cellA = cells.get(a.getAttribute('model-id'));\n            var cellB = cells.get(b.getAttribute('model-id'));\n            var zA = cellA.attributes.z || 0;\n            var zB = cellB.attributes.z || 0;\n            return (zA === zB) ? 0 : (zA < zB) ? -1 : 1;\n        });\n    },\n\n    insertView: function(view, isInitialInsert) {\n        const layerView = this.getLayerView(LayersNames.CELLS);\n        const { el, model } = view;\n        switch (this.options.sorting) {\n            case sortingTypes.APPROX:\n                layerView.insertSortedNode(el, model.get('z'));\n                break;\n            case sortingTypes.EXACT:\n            default:\n                layerView.insertNode(el);\n                break;\n        }\n        view.onMount(isInitialInsert);\n    },\n\n    detachView(view) {\n        view.unmount();\n        view.onDetach();\n    },\n\n    scale: function(sx, sy, ox, oy) {\n\n        // getter\n        if (sx === undefined) {\n            return V.matrixToScale(this.matrix());\n        }\n\n        // setter\n        if (sy === undefined) {\n            sy = sx;\n        }\n        if (ox === undefined) {\n            ox = 0;\n            oy = 0;\n        }\n\n        var translate = this.translate();\n\n        if (ox || oy || translate.tx || translate.ty) {\n            var newTx = translate.tx - ox * (sx - 1);\n            var newTy = translate.ty - oy * (sy - 1);\n            this.translate(newTx, newTy);\n        }\n\n        sx = Math.max(sx || 0, this.MIN_SCALE);\n        sy = Math.max(sy || 0, this.MIN_SCALE);\n\n        var ctm = this.matrix();\n        ctm.a = sx;\n        ctm.d = sy;\n\n        this.matrix(ctm);\n\n        this.trigger('scale', sx, sy, ox, oy);\n\n        return this;\n    },\n\n    // Experimental - do not use in production.\n    rotate: function(angle, cx, cy) {\n\n        // getter\n        if (angle === undefined) {\n            return V.matrixToRotate(this.matrix());\n        }\n\n        // setter\n\n        // If the origin is not set explicitely, rotate around the center. Note that\n        // we must use the plain bounding box (`this.el.getBBox()` instead of the one that gives us\n        // the real bounding box (`bbox()`) including transformations).\n        if (cx === undefined) {\n            var bbox = this.cells.getBBox();\n            cx = bbox.width / 2;\n            cy = bbox.height / 2;\n        }\n\n        var ctm = this.matrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);\n        this.matrix(ctm);\n\n        return this;\n    },\n\n    translate: function(tx, ty) {\n\n        // getter\n        if (tx === undefined) {\n            return V.matrixToTranslate(this.matrix());\n        }\n\n        const { options } = this;\n        const { origin, drawGrid } = options;\n\n        // setter\n        tx || (tx = 0);\n        ty || (ty = 0);\n\n        const ctm = this.matrix();\n        if (ctm.e === tx && ctm.f === ty) return this;\n        ctm.e = tx;\n        ctm.f = ty;\n\n        this.matrix(ctm);\n\n        const { tx: ox, ty: oy } = this.translate();\n        origin.x = ox;\n        origin.y = oy;\n\n        this.trigger('translate', ox, oy);\n\n        if (drawGrid) {\n            this.drawGrid();\n        }\n\n        return this;\n    },\n\n    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n    // be a selector or a jQuery object.\n    findView: function($el) {\n\n        var el = isString($el)\n            ? this.cells.querySelector($el)\n            : $el instanceof $ ? $el[0] : $el;\n\n        var id = this.findAttribute('model-id', el);\n        if (id) return this._views[id];\n\n        return undefined;\n    },\n\n    // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n    findViewByModel: function(cell) {\n\n        var id = (isString(cell) || isNumber(cell)) ? cell : (cell && cell.id);\n\n        return this._views[id];\n    },\n\n    // Find all views at given point\n    findViewsFromPoint: function(p) {\n\n        p = new Point(p);\n\n        var views = this.model.getElements().map(this.findViewByModel, this);\n\n        return views.filter(function(view) {\n            return view && view.vel.getBBox({ target: this.cells }).containsPoint(p);\n        }, this);\n    },\n\n    // Find all views in given area\n    findViewsInArea: function(rect, opt) {\n\n        opt = defaults(opt || {}, { strict: false });\n        rect = new Rect(rect);\n\n        var views = this.model.getElements().map(this.findViewByModel, this);\n        var method = opt.strict ? 'containsRect' : 'intersect';\n\n        return views.filter(function(view) {\n            return view && rect[method](view.vel.getBBox({ target: this.cells }));\n        }, this);\n    },\n\n    removeTools: function() {\n        this.dispatchToolsEvent('remove');\n        return this;\n    },\n\n    hideTools: function() {\n        this.dispatchToolsEvent('hide');\n        return this;\n    },\n\n    showTools: function() {\n        this.dispatchToolsEvent('show');\n        return this;\n    },\n\n    dispatchToolsEvent: function(event, ...args) {\n        if (typeof event !== 'string') return;\n        this.trigger('tools:event', event, ...args);\n    },\n\n\n    getModelById: function(id) {\n\n        return this.model.getCell(id);\n    },\n\n    snapToGrid: function(x, y) {\n\n        // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n    },\n\n    localToPaperPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new Point(x, y);\n        var paperPoint = V.transformPoint(localPoint, this.matrix());\n        return paperPoint;\n    },\n\n    localToPaperRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var localRect = new Rect(x, y, width, height);\n        var paperRect = V.transformRect(localRect, this.matrix());\n        return paperRect;\n    },\n\n    paperToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var paperPoint = new Point(x, y);\n        var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\n        return localPoint;\n    },\n\n    paperToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var paperRect = new Rect(x, y, width, height);\n        var localRect = V.transformRect(paperRect, this.matrix().inverse());\n        return localRect;\n    },\n\n    localToClientPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new Point(x, y);\n        var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\n        return clientPoint;\n    },\n\n    localToClientRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var localRect = new Rect(x, y, width, height);\n        var clientRect = V.transformRect(localRect, this.clientMatrix());\n        return clientRect;\n    },\n\n    // Transform client coordinates to the paper local coordinates.\n    // Useful when you have a mouse event object and you'd like to get coordinates\n    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n    clientToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var clientPoint = new Point(x, y);\n        var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\n        return localPoint;\n    },\n\n    clientToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var clientRect = new Rect(x, y, width, height);\n        var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\n        return localRect;\n    },\n\n    localToPagePoint: function(x, y) {\n\n        return this.localToPaperPoint(x, y).offset(this.pageOffset());\n    },\n\n    localToPageRect: function(x, y, width, height) {\n\n        return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n    },\n\n    pageToLocalPoint: function(x, y) {\n\n        var pagePoint = new Point(x, y);\n        var paperPoint = pagePoint.difference(this.pageOffset());\n        return this.paperToLocalPoint(paperPoint);\n    },\n\n    pageToLocalRect: function(x, y, width, height) {\n\n        var pageOffset = this.pageOffset();\n        var paperRect = new Rect(x, y, width, height);\n        paperRect.x -= pageOffset.x;\n        paperRect.y -= pageOffset.y;\n        return this.paperToLocalRect(paperRect);\n    },\n\n    clientOffset: function() {\n\n        var clientRect = this.svg.getBoundingClientRect();\n        return new Point(clientRect.left, clientRect.top);\n    },\n\n    pageOffset: function() {\n\n        return this.clientOffset().offset(window.scrollX, window.scrollY);\n    },\n\n    linkAllowed: function(linkView) {\n\n        if (!(linkView instanceof LinkView)) {\n            throw new Error('Must provide a linkView.');\n        }\n\n        var link = linkView.model;\n        var paperOptions = this.options;\n        var graph = this.model;\n        var ns = graph.constructor.validations;\n\n        if (!paperOptions.multiLinks) {\n            if (!ns.multiLinks.call(this, graph, link)) return false;\n        }\n\n        if (!paperOptions.linkPinning) {\n            // Link pinning is not allowed and the link is not connected to the target.\n            if (!ns.linkPinning.call(this, graph, link)) return false;\n        }\n\n        if (typeof paperOptions.allowLink === 'function') {\n            if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n        }\n\n        return true;\n    },\n\n    getDefaultLink: function(cellView, magnet) {\n\n        return isFunction(this.options.defaultLink)\n        // default link is a function producing link model\n            ? this.options.defaultLink.call(this, cellView, magnet)\n        // default link is the Backbone model\n            : this.options.defaultLink.clone();\n    },\n\n    // Cell highlighting.\n    // ------------------\n\n    resolveHighlighter: function(opt = {}) {\n\n        let { highlighter: highlighterDef, type } = opt;\n        const { highlighting,highlighterNamespace  } = this.options;\n\n        /*\n            Expecting opt.highlighter to have the following structure:\n            {\n                name: 'highlighter-name',\n                options: {\n                    some: 'value'\n                }\n            }\n        */\n        if (highlighterDef === undefined) {\n\n            // Is highlighting disabled?\n            if (!highlighting) return false;\n            // check for built-in types\n            if (type) {\n                highlighterDef = highlighting[type];\n                // Is a specific type highlight disabled?\n                if (highlighterDef === false) return false;\n            }\n            if (!highlighterDef) {\n                // Type not defined use default highlight\n                highlighterDef = highlighting['default'];\n            }\n        }\n\n        // Do nothing if opt.highlighter is falsy.\n        // This allows the case to not highlight cell(s) in certain cases.\n        // For example, if you want to NOT highlight when embedding elements\n        // or use a custom highlighter.\n        if (!highlighterDef) return false;\n\n        // Allow specifying a highlighter by name.\n        if (isString(highlighterDef)) {\n            highlighterDef = {\n                name: highlighterDef\n            };\n        }\n\n        const name = highlighterDef.name;\n        const highlighter = highlighterNamespace[name];\n\n        // Highlighter validation\n        if (!highlighter) {\n            throw new Error('Unknown highlighter (\"' + name + '\")');\n        }\n        if (typeof highlighter.highlight !== 'function') {\n            throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n        }\n        if (typeof highlighter.unhighlight !== 'function') {\n            throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n        }\n\n        return {\n            highlighter,\n            options: highlighterDef.options || {},\n            name\n        };\n    },\n\n    onCellHighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.highlight(cellView, magnetEl, options);\n    },\n\n    onCellUnhighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.unhighlight(cellView, magnetEl, options);\n    },\n\n    // Interaction.\n    // ------------\n\n    pointerdblclick: function(evt) {\n\n        evt.preventDefault();\n\n        // magnetpointerdblclick can stop propagation\n\n        evt = normalizeEvent(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        if (view) {\n            view.pointerdblclick(evt, localPoint.x, localPoint.y);\n\n        } else {\n            this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    pointerclick: function(evt) {\n\n        // magnetpointerclick can stop propagation\n\n        var data = this.eventData(evt);\n        // Trigger event only if mouse has not moved.\n        if (data.mousemoved <= this.options.clickThreshold) {\n\n            evt = normalizeEvent(evt);\n\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n\n            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n            if (view) {\n                view.pointerclick(evt, localPoint.x, localPoint.y);\n\n            } else {\n                this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    contextmenu: function(evt) {\n\n        if (this.options.preventContextMenu) evt.preventDefault();\n\n        if (this.contextMenuFired) {\n            this.contextMenuFired = false;\n            return;\n        }\n\n        evt = normalizeEvent(evt);\n\n        this.contextMenuTrigger(evt);\n    },\n\n    contextMenuTrigger: function(evt) {\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        if (view) {\n            view.contextmenu(evt, localPoint.x, localPoint.y);\n\n        } else {\n            this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    pointerdown: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const { target, button } = evt;\n        const view = this.findView(target);\n        const isContextMenu = (button === 2);\n\n        if (view) {\n\n            if (!isContextMenu && this.guard(evt, view)) return;\n\n            const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n\n            if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n                // If the target is a form element, we do not want to prevent the default action.\n                // For example, we want to be able to select text in a text input or\n                // to be able to click on a checkbox.\n                evt.preventDefault();\n            }\n\n            if (isTargetFormNode) {\n                // If the target is a form element, we do not want to start dragging the element.\n                // For example, we want to be able to select text by dragging the mouse.\n                view.preventDefaultInteraction(evt);\n            }\n\n            const rootViewEl = view.el;\n\n            // Custom event\n            const eventNode = target.closest('[event]');\n            if (eventNode && rootViewEl !== eventNode && view.el.contains(eventNode)) {\n                const eventEvt = normalizeEvent($.Event(evt.originalEvent, {\n                    data: evt.data,\n                    // Originally the event listener was attached to the event element.\n                    currentTarget: eventNode\n                }));\n                this.onevent(eventEvt);\n                if (eventEvt.isDefaultPrevented()) {\n                    evt.preventDefault();\n                }\n                // `onevent` can stop propagation\n                if (eventEvt.isPropagationStopped()) return;\n                evt.data = eventEvt.data;\n            }\n\n            // Element magnet\n            const magnetNode = target.closest('[magnet]');\n            if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n                const magnetEvt = normalizeEvent($.Event(evt.originalEvent, {\n                    data: evt.data,\n                    // Originally the event listener was attached to the magnet element.\n                    currentTarget: magnetNode\n                }));\n                this.onmagnet(magnetEvt);\n                if (magnetEvt.isDefaultPrevented()) {\n                    evt.preventDefault();\n                }\n                // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n                if (magnetEvt.isPropagationStopped()) {\n                    // `magnet:pointermove` and `magnet:pointerup` events must be fired\n                    if (isContextMenu) return;\n                    this.delegateDragEvents(view, magnetEvt.data);\n                    return;\n                }\n                evt.data = magnetEvt.data;\n            }\n        }\n\n        if (isContextMenu) {\n            this.contextMenuFired = true;\n            const contextmenuEvt = $.Event(evt.originalEvent, { type: 'contextmenu', data: evt.data });\n            this.contextMenuTrigger(contextmenuEvt);\n        } else {\n            const localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            if (view) {\n                view.pointerdown(evt, localPoint.x, localPoint.y);\n            } else {\n                if (this.options.preventDefaultBlankAction) {\n                    evt.preventDefault();\n                }\n                this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n            }\n\n            this.delegateDragEvents(view, evt.data);\n        }\n\n    },\n\n    pointermove: function(evt) {\n\n        // mouse moved counter\n        var data = this.eventData(evt);\n        if (!data.mousemoved) {\n            data.mousemoved = 0;\n            // Make sure that events like `mouseenter` and `mouseleave` are\n            // not triggered while the user is dragging a cellView.\n            this.undelegateEvents();\n            // Note: the events are undelegated after the first `pointermove` event.\n            // Not on `pointerdown` to make sure that `dbltap` is recognized.\n        }\n\n        var mousemoved = ++data.mousemoved;\n\n        if (mousemoved <= this.options.moveThreshold) return;\n\n        evt = normalizeEvent(evt);\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        var view = data.sourceView;\n        if (view) {\n            view.pointermove(evt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n        }\n\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt) {\n\n        this.undelegateDocumentEvents();\n\n        var normalizedEvt = normalizeEvent(evt);\n\n        var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\n        var view = this.eventData(evt).sourceView;\n        if (view) {\n            view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n        }\n\n        if (!normalizedEvt.isPropagationStopped()) {\n            this.pointerclick($.Event(evt.originalEvent, { type: 'click', data: evt.data }));\n        }\n\n        this.delegateEvents();\n    },\n\n    mouseover: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        if (view) {\n            view.mouseover(evt);\n\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger('blank:mouseover', evt);\n        }\n    },\n\n    mouseout: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        if (view) {\n            view.mouseout(evt);\n\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger('blank:mouseout', evt);\n        }\n    },\n\n    mouseenter: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const {\n            target, // The EventTarget the pointing device entered to\n            relatedTarget, // The EventTarget the pointing device exited from\n            currentTarget // The EventTarget on which the event listener was registered\n        } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse left a cell tool\n                return;\n            }\n            view.mouseenter(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer remains inside the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            return;\n        }\n        // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n        // (mouseenter method would be fired twice)\n        if (currentTarget === this.el) {\n            // `paper` (more descriptive), not `blank`\n            this.trigger('paper:mouseenter', evt);\n        }\n    },\n\n    mouseleave: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const {\n            target, // The EventTarget the pointing device exited from\n            relatedTarget, // The EventTarget the pointing device entered to\n            currentTarget // The EventTarget on which the event listener was registered\n        } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse entered a cell tool\n                return;\n            }\n            view.mouseleave(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer has exited a cellView. The pointer is still inside of the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            // The pointer has entered a new cellView\n            return;\n        }\n        // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n        // (mouseleave method would be fired twice)\n        if (currentTarget === this.el) {\n            // There is no cellView under the pointer, nor the blank area of the paper\n            this.trigger('paper:mouseleave', evt);\n        }\n    },\n\n    _processMouseWheelEvtBuf: debounce(function() {\n        const { event, deltas } = this._mw_evt_buffer;\n        const deltaY = deltas.reduce((acc, deltaY) => acc + cap(deltaY, WHEEL_CAP), 0);\n\n        const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n        const { x, y } = this.clientToLocalPoint(event.clientX, event.clientY);\n        this.trigger('paper:pinch', event, x, y, scale);\n\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: [],\n        };\n    }, WHEEL_WAIT_MS, { maxWait: WHEEL_WAIT_MS }),\n\n    mousewheel: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        const originalEvent = evt.originalEvent;\n        const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n        const { deltaX, deltaY } = normalizeWheel(originalEvent);\n\n        const pinchHandlers = this._events['paper:pinch'];\n\n        // Touchpad devices will send a fake CTRL press when a pinch is performed\n        //\n        // We also check if there are any subscribers to paper:pinch event. If there are none,\n        // just skip the entire block of code (we don't want to blindly call\n        // .preventDefault() if we really don't have to).\n        if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n            // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n            originalEvent.preventDefault();\n            this._mw_evt_buffer.event = originalEvent;\n            this._mw_evt_buffer.deltas.push(deltaY);\n            this._processMouseWheelEvtBuf();\n        } else {\n            const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n            if (view) {\n                view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n\n            } else {\n                this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n            }\n\n            this.trigger('paper:pan', evt, deltaX, deltaY);\n        }\n    },\n\n    onevent: function(evt) {\n\n        var eventNode = evt.currentTarget;\n        var eventName = eventNode.getAttribute('event');\n        if (eventName) {\n            var view = this.findView(eventNode);\n            if (view) {\n\n                evt = normalizeEvent(evt);\n                if (this.guard(evt, view)) return;\n\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                view.onevent(evt, eventName, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    magnetEvent: function(evt, handler) {\n\n        var magnetNode = evt.currentTarget;\n        var magnetValue = magnetNode.getAttribute('magnet');\n        if (magnetValue) {\n            var view = this.findView(magnetNode);\n            if (view) {\n                evt = normalizeEvent(evt);\n                if (this.guard(evt, view)) return;\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    onmagnet: function(evt) {\n\n        if (evt.button === 2) {\n            this.contextMenuFired = true;\n            this.magnetContextMenuFired = true;\n            const contextmenuEvt = $.Event(evt.originalEvent, {\n                type: 'contextmenu',\n                data: evt.data,\n                currentTarget: evt.currentTarget,\n            });\n            this.magnetContextMenuTrigger(contextmenuEvt);\n            if (contextmenuEvt.isPropagationStopped()) {\n                evt.stopPropagation();\n            }\n        } else {\n            this.magnetEvent(evt, function(view, evt, _, x, y) {\n                view.onmagnet(evt, x, y);\n            });\n        }\n    },\n\n    magnetpointerdblclick: function(evt) {\n\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetpointerdblclick(evt, magnet, x, y);\n        });\n    },\n\n    magnetcontextmenu: function(evt) {\n        if (this.options.preventContextMenu) evt.preventDefault();\n\n        if (this.magnetContextMenuFired) {\n            this.magnetContextMenuFired = false;\n            return;\n        }\n\n        this.magnetContextMenuTrigger(evt);\n    },\n\n    magnetContextMenuTrigger: function(evt) {\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetcontextmenu(evt, magnet, x, y);\n        });\n    },\n\n    onlabel: function(evt) {\n\n        var labelNode = evt.currentTarget;\n        var view = this.findView(labelNode);\n        if (view) {\n\n            evt = normalizeEvent(evt);\n            if (this.guard(evt, view)) return;\n\n            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            view.onlabel(evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    getPointerArgs(evt) {\n        const normalizedEvt = normalizeEvent(evt);\n        const { x, y } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n        return [normalizedEvt, x, y];\n    },\n\n    delegateDragEvents: function(view, data) {\n\n        data || (data = {});\n        this.eventData({ data: data }, { sourceView: view || null, mousemoved: 0 });\n        this.delegateDocumentEvents(null, data);\n    },\n\n    // Guard the specified event. If the event should be ignored, guard returns `true`.\n    // Otherwise, it returns `false`.\n    guard: function(evt, view) {\n\n        if (evt.type === 'mousedown' && evt.button === 2) {\n            // handled as `contextmenu` type\n            return true;\n        }\n\n        if (this.options.guard && this.options.guard(evt, view)) {\n            return true;\n        }\n\n        if (evt.data && evt.data.guarded !== undefined) {\n            return evt.data.guarded;\n        }\n\n        const { target } = evt;\n\n        if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n            return true;\n        }\n\n        if (view && view.model && (view.model instanceof Cell)) {\n            return false;\n        }\n\n        if (this.svg === target || this.el === target || $.contains(this.svg, target)) {\n            return false;\n        }\n\n        return true;    // Event guarded. Paper should not react on it in any way.\n    },\n\n    setGridSize: function(gridSize) {\n\n        const { options } = this;\n        options.gridSize = gridSize;\n\n        if (options.drawGrid && !options.drawGridSize) {\n            // Do not redraw the grid if the `drawGridSize` is set.\n            this.drawGrid();\n        }\n\n        return this;\n    },\n\n    clearGrid: function() {\n\n        if (this.$grid) {\n            this.$grid.css('backgroundImage', 'none');\n        }\n        return this;\n    },\n\n    _getGridRefs: function() {\n\n        if (!this._gridCache) {\n\n            this._gridCache = {\n                root: V('svg', { width: '100%', height: '100%' }, V('defs')),\n                patterns: {},\n                add: function(id, vel) {\n                    V(this.root.node.childNodes[0]).append(vel);\n                    this.patterns[id] = vel;\n                    this.root.append(V('rect', { width: '100%', height: '100%', fill: 'url(#' + id + ')' }));\n                },\n                get: function(id) {\n                    return this.patterns[id];\n                },\n                exist: function(id) {\n                    return this.patterns[id] !== undefined;\n                }\n            };\n        }\n\n        return this._gridCache;\n    },\n\n    setGrid: function(drawGrid) {\n\n        this.clearGrid();\n\n        this._gridCache = null;\n        this._gridSettings = [];\n\n        var optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n        optionsList.forEach(function(item) {\n            this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(item));\n        }, this);\n        return this;\n    },\n\n    _resolveDrawGridOption: function(opt) {\n\n        var namespace = this.constructor.gridPatterns;\n        if (isString(opt) && Array.isArray(namespace[opt])) {\n            return namespace[opt].map(function(item) {\n                return assign({}, item);\n            });\n        }\n\n        var options = opt || { args: [{}] };\n        var isArray = Array.isArray(options);\n        var name = options.name;\n\n        if (!isArray && !name && !options.markup) {\n            name = 'dot';\n        }\n\n        if (name && Array.isArray(namespace[name])) {\n            var pattern = namespace[name].map(function(item) {\n                return assign({}, item);\n            });\n\n            var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n\n            defaults(args[0], omit(opt, 'args'));\n            for (var i = 0; i < args.length; i++) {\n                if (pattern[i]) {\n                    assign(pattern[i], args[i]);\n                }\n            }\n            return pattern;\n        }\n\n        return isArray ? options : [options];\n    },\n\n    drawGrid: function(opt) {\n\n        const gridSize = this.options.drawGridSize || this.options.gridSize;\n        if (gridSize <= 1) {\n            return this.clearGrid();\n        }\n\n        var localOptions = Array.isArray(opt) ? opt : [opt];\n\n        var ctm = this.matrix();\n        var refs = this._getGridRefs();\n\n        this._gridSettings.forEach(function(gridLayerSetting, index) {\n\n            var id = 'pattern_' + index;\n            var options = merge(gridLayerSetting, localOptions[index], {\n                sx: ctm.a || 1,\n                sy: ctm.d || 1,\n                ox: ctm.e || 0,\n                oy: ctm.f || 0\n            });\n\n            options.width = gridSize * (ctm.a || 1) * (options.scaleFactor || 1);\n            options.height = gridSize * (ctm.d || 1) * (options.scaleFactor || 1);\n\n            if (!refs.exist(id)) {\n                refs.add(id, V('pattern', { id: id, patternUnits: 'userSpaceOnUse' }, V(options.markup)));\n            }\n\n            var patternDefVel = refs.get(id);\n\n            if (isFunction(options.update)) {\n                options.update(patternDefVel.node.childNodes[0], options);\n            }\n\n            var x = options.ox % options.width;\n            if (x < 0) x += options.width;\n\n            var y = options.oy % options.height;\n            if (y < 0) y += options.height;\n\n            patternDefVel.attr({\n                x: x,\n                y: y,\n                width: options.width,\n                height: options.height\n            });\n        });\n\n        var patternUri = new XMLSerializer().serializeToString(refs.root.node);\n        patternUri = 'url(data:image/svg+xml;base64,' + btoa(patternUri) + ')';\n\n        this.$grid.css('backgroundImage', patternUri);\n\n        return this;\n    },\n\n    updateBackgroundImage: function(opt) {\n\n        opt = opt || {};\n\n        var backgroundPosition = opt.position || 'center';\n        var backgroundSize = opt.size || 'auto auto';\n\n        var currentScale = this.scale();\n        var currentTranslate = this.translate();\n\n        // backgroundPosition\n        if (isObject(backgroundPosition)) {\n            var x = currentTranslate.tx + (currentScale.sx * (backgroundPosition.x || 0));\n            var y = currentTranslate.ty + (currentScale.sy * (backgroundPosition.y || 0));\n            backgroundPosition = x + 'px ' + y + 'px';\n        }\n\n        // backgroundSize\n        if (isObject(backgroundSize)) {\n            backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n            backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n        }\n\n        this.$background.css({\n            backgroundSize: backgroundSize,\n            backgroundPosition: backgroundPosition\n        });\n    },\n\n    drawBackgroundImage: function(img, opt) {\n\n        // Clear the background image if no image provided\n        if (!(img instanceof HTMLImageElement)) {\n            this.$background.css('backgroundImage', '');\n            return;\n        }\n\n        if (!this._background || this._background.id !== opt.id) {\n            // Draw only the last image requested (see drawBackground())\n            return;\n        }\n\n        opt = opt || {};\n\n        var backgroundImage;\n        var backgroundSize = opt.size;\n        var backgroundRepeat = opt.repeat || 'no-repeat';\n        var backgroundOpacity = opt.opacity || 1;\n        var backgroundQuality = Math.abs(opt.quality) || 1;\n        var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];\n\n        if (isFunction(backgroundPattern)) {\n            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n            img.width *= backgroundQuality;\n            img.height *= backgroundQuality;\n            var canvas = backgroundPattern(img, opt);\n            if (!(canvas instanceof HTMLCanvasElement)) {\n                throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n            }\n\n            backgroundImage = canvas.toDataURL('image/png');\n            backgroundRepeat = 'repeat';\n            if (isObject(backgroundSize)) {\n                // recalculate the tile size if an object passed in\n                backgroundSize.width *= canvas.width / img.width;\n                backgroundSize.height *= canvas.height / img.height;\n            } else if (backgroundSize === undefined) {\n                // calculate the tile size if no provided\n                opt.size = {\n                    width: canvas.width / backgroundQuality,\n                    height: canvas.height / backgroundQuality\n                };\n            }\n        } else {\n            // backgroundRepeat:\n            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n            backgroundImage = img.src;\n            if (backgroundSize === undefined) {\n                // pass the image size for  the backgroundSize if no size provided\n                opt.size = {\n                    width: img.width,\n                    height: img.height\n                };\n            }\n        }\n\n        this.$background.css({\n            opacity: backgroundOpacity,\n            backgroundRepeat: backgroundRepeat,\n            backgroundImage: 'url(' + backgroundImage + ')'\n        });\n\n        this.updateBackgroundImage(opt);\n    },\n\n    updateBackgroundColor: function(color) {\n\n        this.$el.css('backgroundColor', color || '');\n    },\n\n    drawBackground: function(opt) {\n\n        opt = opt || {};\n\n        this.updateBackgroundColor(opt.color);\n\n        if (opt.image) {\n            opt = this._background = cloneDeep(opt);\n            guid(opt);\n            var img = document.createElement('img');\n            img.onload = this.drawBackgroundImage.bind(this, img, opt);\n            img.src = opt.image;\n        } else {\n            this.drawBackgroundImage(null);\n            this._background = null;\n        }\n\n        return this;\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n\n        invoke(this._views, 'setInteractivity', value);\n    },\n\n    // Paper definitions.\n    // ------------------\n\n    isDefined: function(defId) {\n\n        return !!this.svg.getElementById(defId);\n    },\n\n    defineFilter: function(filter) {\n\n        if (!isObject(filter)) {\n            throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n        }\n\n        var filterId = filter.id;\n        var name = filter.name;\n        // Generate a hash code from the stringified filter definition. This gives us\n        // a unique filter ID for different definitions.\n        if (!filterId) {\n            filterId = name + this.svg.id + hashCode(JSON.stringify(filter));\n        }\n        // If the filter already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        // If not, create one.\n        if (!this.isDefined(filterId)) {\n\n            var namespace = _filter;\n            var filterSVGString = namespace[name] && namespace[name](filter.args || {});\n            if (!filterSVGString) {\n                throw new Error('Non-existing filter ' + name);\n            }\n\n            // Set the filter area to be 3x the bounding box of the cell\n            // and center the filter around the cell.\n            var filterAttrs = assign({\n                filterUnits: 'objectBoundingBox',\n                x: -1,\n                y: -1,\n                width: 3,\n                height: 3\n            }, filter.attrs, {\n                id: filterId\n            });\n\n            V(filterSVGString, filterAttrs).appendTo(this.defs);\n        }\n\n        return filterId;\n    },\n\n    defineGradient: function(gradient) {\n        if (!isObject(gradient)) {\n            throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            type,\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = type + svg.id + hashCode(JSON.stringify(gradient)),\n            stops,\n            attrs = {}\n        } = gradient;\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const stopVEls = toArray(stops).map(({ offset, color, opacity }) => {\n            return V('stop').attr({\n                'offset': offset,\n                'stop-color': color,\n                'stop-opacity': Number.isFinite(opacity) ? opacity : 1\n            });\n        });\n        const gradientVEl = V(type, attrs, stopVEls);\n        gradientVEl.id = id;\n        gradientVEl.appendTo(defs);\n        return id;\n    },\n\n    definePattern: function(pattern) {\n        if (!isObject(pattern)) {\n            throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = svg.id + hashCode(JSON.stringify(pattern)),\n            markup,\n            attrs = {}\n        } = pattern;\n        if (!markup) {\n            throw new TypeError('dia.Paper: definePattern() requires markup.');\n        }\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const patternVEl = V('pattern', {\n            patternUnits: 'userSpaceOnUse'\n        });\n        patternVEl.id = id;\n        patternVEl.attr(attrs);\n        if (typeof markup === 'string') {\n            patternVEl.append(V(markup));\n        } else {\n            const { fragment } = parseDOMJSON(markup);\n            patternVEl.append(fragment);\n        }\n        patternVEl.appendTo(defs);\n        return id;\n    },\n\n    defineMarker: function(marker) {\n        if (!isObject(marker)) {\n            throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = svg.id + hashCode(JSON.stringify(marker)),\n            // user-provided markup\n            // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)\n            markup,\n            // user-provided attributes\n            // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)\n            // note: `transform` attrs are ignored by browsers\n            attrs = {},\n            // deprecated - use `attrs/markerUnits` instead (which has higher priority)\n            markerUnits = 'userSpaceOnUse'\n        } = marker;\n        // If the marker already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const markerVEl = V('marker', {\n            orient: 'auto',\n            overflow: 'visible',\n            markerUnits: markerUnits\n        });\n        markerVEl.id = id;\n        markerVEl.attr(attrs);\n        let markerContentVEl;\n        if (markup) {\n            let markupVEl;\n            if (typeof markup === 'string') {\n                // Marker object has a `markup` property of type string.\n                // - Construct V from the provided string.\n                markupVEl = V(markup);\n                // `markupVEl` is now either a single VEl, or an array of VEls.\n                // - Coerce it to an array.\n                markupVEl = (Array.isArray(markupVEl) ? markupVEl : [markupVEl]);\n            } else {\n                // Marker object has a `markup` property of type object.\n                // - Construct V from the object by parsing it as DOM JSON.\n                const { fragment } = parseDOMJSON(markup);\n                markupVEl = V(fragment).children();\n            }\n            // `markupVEl` is an array with one or more VEls inside.\n            // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n            if (markupVEl.length > 1) {\n                markerContentVEl = V('g').append(markupVEl);\n            } else {\n                markerContentVEl = markupVEl[0];\n            }\n        } else {\n            // Marker object is a flat structure.\n            // - Construct a new V of type `marker.type`.\n            const { type = 'path' } = marker;\n            markerContentVEl = V(type);\n        }\n        // `markerContentVEl` is a single VEl.\n        // Assign additional attributes to it (= context attributes + marker attributes):\n        // - Attribute values are taken from non-special properties of `marker`.\n        const markerAttrs = omit(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');\n        const markerAttrsKeys = Object.keys(markerAttrs);\n        markerAttrsKeys.forEach((key) => {\n            const value = markerAttrs[key];\n            const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n            if (markupValue == null) {\n                // Default logic:\n                markerContentVEl.attr(key, value);\n            } else {\n                // Properties with special logic should be added as cases to this switch block:\n                switch(key) {\n                    case 'transform':\n                        // - Prepend `transform` to existing value.\n                        markerContentVEl.attr(key, (value + ' ' + markupValue));\n                        break;\n                }\n            }\n        });\n        markerContentVEl.appendTo(markerVEl);\n        markerVEl.appendTo(defs);\n        return id;\n    }\n\n}, {\n\n    sorting: sortingTypes,\n\n    Layers: LayersNames,\n\n    backgroundPatterns: {\n\n        flipXy: function(img) {\n            // d b\n            // q p\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = 2 * imgWidth;\n            canvas.height = 2 * imgHeight;\n\n            var ctx = canvas.getContext('2d');\n            // top-left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // xy-flipped bottom-right image\n            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // x-flipped top-right image\n            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // y-flipped bottom-left image\n            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        flipX: function(img) {\n            // d b\n            // d b\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = imgWidth * 2;\n            canvas.height = imgHeight;\n\n            var ctx = canvas.getContext('2d');\n            // left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped right image\n            ctx.translate(2 * imgWidth, 0);\n            ctx.scale(-1, 1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        flipY: function(img) {\n            // d d\n            // q q\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = imgWidth;\n            canvas.height = imgHeight * 2;\n\n            var ctx = canvas.getContext('2d');\n            // top image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped bottom image\n            ctx.translate(0, 2 * imgHeight);\n            ctx.scale(1, -1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        watermark: function(img, opt) {\n            //   d\n            // d\n\n            opt = opt || {};\n\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            var canvas = document.createElement('canvas');\n            canvas.width = imgWidth * 3;\n            canvas.height = imgHeight * 3;\n\n            var ctx = canvas.getContext('2d');\n            var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n            var radians = toRad(angle);\n            var stepX = canvas.width / 4;\n            var stepY = canvas.height / 4;\n\n            for (var i = 0; i < 4; i++) {\n                for (var j = 0; j < 4; j++) {\n                    if ((i + j) % 2 > 0) {\n                        // reset the current transformations\n                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n                        ctx.rotate(radians);\n                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n                    }\n                }\n            }\n\n            return canvas;\n        }\n    },\n\n    gridPatterns: {\n        dot: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'rect',\n            update: function(el, opt) {\n                V(el).attr({\n                    width: opt.thickness * opt.sx,\n                    height: opt.thickness * opt.sy,\n                    fill: opt.color\n                });\n            }\n        }],\n        fixedDot: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'rect',\n            update: function(el, opt) {\n                var size = opt.sx <= 1 ? opt.thickness * opt.sx : opt.thickness;\n                V(el).attr({ width: size, height: size, fill: opt.color });\n            }\n        }],\n        mesh: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'path',\n            update: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }],\n        doubleMesh: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'path',\n            update: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }, {\n            color: '#000000',\n            thickness: 3,\n            scaleFactor: 4,\n            markup: 'path',\n            update: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }]\n    }\n});\n\n"],"mappings":";;AAAA,OAAOA,CAAC,MAAM,gBAAgB;AAC9B,SACIC,QAAQ,EACRC,MAAM,EACNC,SAAS,EACTC,QAAQ,EACRC,WAAW,EACXC,QAAQ,EACRC,YAAY,EACZC,kBAAkB,EAClBC,cAAc,EACdC,UAAU,EACVC,aAAa,EACbC,SAAS,EACTC,YAAY,EACZC,QAAQ,EACRC,IAAI,EACJC,cAAc,EACdC,cAAc,EACdC,GAAG,EACHC,QAAQ,EACRC,IAAI,EACJC,MAAM,EACNC,KAAK,EACLC,SAAS,EACTC,SAAS,EACTC,MAAM,EACNC,QAAQ,EACRC,MAAM,IAAIC,OAAO,EACjBC,YAAY,EACZC,OAAO,EACPC,GAAG,QACA,mBAAmB;AAC1B,SAASC,IAAI,EAAEC,KAAK,EAAEC,KAAK,QAAQ,gBAAgB;AACnD,SAASC,IAAI,EAAEC,KAAK,QAAQ,kBAAkB;AAC9C,SAASC,QAAQ,QAAQ,gBAAgB;AACzC,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,QAAQ,QAAQ,gBAAgB;AACzC,SAASC,IAAI,QAAQ,YAAY;AACjC,SAASC,IAAI,QAAQ,YAAY;AACjC,SAASC,KAAK,QAAQ,aAAa;AACnC,SAASC,WAAW,EAAEC,UAAU,QAAQ,kBAAkB;AAC1D,OAAO,KAAKC,YAAY,MAAM,2BAA2B;AACzD,OAAO,KAAKC,WAAW,MAAM,0BAA0B;AACvD,OAAO,KAAKC,gBAAgB,MAAM,+BAA+B;AACjE,OAAO,KAAKC,OAAO,MAAM,sBAAsB;AAE/C,OAAOC,CAAC,MAAM,QAAQ;AACtB,OAAOC,QAAQ,MAAM,UAAU;AAE/B,MAAMC,YAAY,GAAG;EACjBC,IAAI,EAAE,cAAc;EACpBC,MAAM,EAAE,qBAAqB;EAC7BC,KAAK,EAAE;AACX,CAAC;AAED,MAAMC,SAAS,GAAG,EAAE;AACpB,MAAMC,aAAa,GAAG,EAAE;AACxB,MAAMC,gBAAgB,GAAG,IAAI;AAC7B,MAAMC,iBAAiB,GAAGC,QAAQ;AAClC,MAAMC,YAAY,GAAG,gBAAgB,CAAC,CAAC;;AAEvC,MAAMC,iBAAiB,GAAGxB,QAAQ,CAACyB,YAAY;AAE/C,MAAMC,mBAAmB,GAAG;EACxB,CAACF,iBAAiB,CAACG,OAAO,GAAG;IACzBC,IAAI,EAAE,QAAQ;IACdC,OAAO,EAAE;MACLC,OAAO,EAAE;IACb;EACJ,CAAC;EACD,CAACN,iBAAiB,CAACO,mBAAmB,GAAG;IACrCH,IAAI,EAAE,UAAU;IAChBC,OAAO,EAAE;MACLG,SAAS,EAAE;IACf;EACJ,CAAC;EACD,CAACR,iBAAiB,CAACS,oBAAoB,GAAG;IACtCL,IAAI,EAAE,UAAU;IAChBC,OAAO,EAAE;MACLG,SAAS,EAAE;IACf;EACJ;AACJ,CAAC;AAED,MAAME,aAAa,GAAG,CAAC;EACnBN,IAAI,EAAEtB,WAAW,CAAC6B;AACtB,CAAC,EAAE;EACCP,IAAI,EAAEtB,WAAW,CAAC8B;AACtB,CAAC,EAAE;EACCR,IAAI,EAAEtB,WAAW,CAAC+B;AACtB,CAAC,EAAE;EACCT,IAAI,EAAEtB,WAAW,CAACgC;AACtB,CAAC,EAAE;EACCV,IAAI,EAAEtB,WAAW,CAACiC;AACtB,CAAC,CAAC;AAEF,OAAO,MAAMC,KAAK,GAAG1C,IAAI,CAAC2C,MAAM,CAAC;EAE7BT,SAAS,EAAE,OAAO;EAElBH,OAAO,EAAE;IAELa,KAAK,EAAE,GAAG;IACVC,MAAM,EAAE,GAAG;IACXC,MAAM,EAAE;MAAEC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;IAAE;IACxBC,QAAQ,EAAE,CAAC;IACX;IACA;IACAC,QAAQ,EAAE,KAAK;IACf;IACAC,YAAY,EAAE,IAAI;IAElB;IACA;IACAC,UAAU,EAAE,KAAK;IAEjBC,kBAAkB,EAAE,KAAK;IACzBC,WAAW,EAAEnD,WAAW;IACxBoD,QAAQ,EAAEnD,QAAQ;IAClBoD,UAAU,EAAE,KAAK;IAAE;IACnBC,SAAS,EAAE,KAAK;IAAE;IAClBC,aAAa,EAAE,KAAK;IAAE;;IAEtB;IACA;IACA;IACA;IACAC,WAAW,EAAE,KAAK;IAElB;IACAC,UAAU,EAAE,IAAI;IAEhB;IACAC,KAAK,EAAE,UAASC,GAAG,EAAEC,IAAI,EAAE;MAEvB;MACA,OAAO,KAAK;IAChB,CAAC;IAEDC,YAAY,EAAEpC,mBAAmB;IAEjC;IACAqC,kBAAkB,EAAE,IAAI;IAExB;IACAC,yBAAyB,EAAE,IAAI;IAE/B;IACAC,wBAAwB,EAAE,IAAI;IAE9B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAC,iBAAiB,EAAE,KAAK;IAExB;IACA;IACA;IACAC,aAAa,EAAE,KAAK;IAEpB;IACA;IACA;IACAC,WAAW,EAAE,IAAIjE,IAAI;IAErB;IACA;IACAkE,gBAAgB,EAAE;MAAEzC,IAAI,EAAE;IAAS,CAAC;IAEpC;IACA;IACA0C,aAAa,EAAE;MAAE1C,IAAI,EAAE;IAAS,CAAC;IAEjC2C,aAAa,EAAE;MAAE3C,IAAI,EAAE;IAAS,CAAC;IAEjC4C,iBAAiB,EAAE;MAAE5C,IAAI,EAAE;IAAkB,CAAC;IAE9C6C,sBAAsB,EAAE;MAAE7C,IAAI,EAAE;IAAO,CAAC;IAExC;;IAEA8C,kBAAkB,EAAE,IAAI;IAExB;IACAC,cAAc,EAAE,UAASC,SAAS,EAAEC,MAAM,EAAEC,IAAI,EAAE;MAC9C,OAAOD,MAAM,CAACE,YAAY,CAAC,QAAQ,CAAC,KAAK,SAAS;IACtD,CAAC;IAED;IACA;IACAC,kBAAkB,EAAE,UAASC,SAAS,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,GAAG,EAAEC,SAAS,EAAE;MACnF,OAAO,CAACD,GAAG,KAAK,QAAQ,GAAGF,SAAS,GAAGF,SAAS,aAAahF,WAAW;IAC5E,CAAC;IAED;;IAEA;IACA;IACAsF,aAAa,EAAE,KAAK;IAEpB;IACAC,iBAAiB,EAAE,UAASC,SAAS,EAAEC,UAAU,EAAE;MAC/C;MACA,OAAO,IAAI;IACf,CAAC;IAED;IACAC,mBAAmB,EAAE,UAASF,SAAS,EAAE;MACrC;MACA,OAAO,IAAI;IACf,CAAC;IAED;IACA;IACAG,YAAY,EAAE,MAAM;IAAE;;IAEtB;IACA;IACA;IACAC,eAAe,EAAE,IAAI;IAErB;IACAC,WAAW,EAAE;MACTC,SAAS,EAAE;IACf,CAAC;IAED;IACA;IACAC,WAAW,EAAE,IAAI;IAEjB;IACA;IACA;IACAC,SAAS,EAAE,IAAI;IAEf;IACAC,cAAc,EAAE,CAAC;IAEjB;IACAC,aAAa,EAAE,CAAC;IAEhB;IACA;IACAC,eAAe,EAAE,CAAC;IAElB;;IAEAC,OAAO,EAAEvF,YAAY,CAACG,KAAK;IAE3BqF,MAAM,EAAE,KAAK;IAEbC,UAAU,EAAE,KAAK;IAEjB;IACAC,YAAY,EAAE,UAAS3C,IAAI,EAAE4C,IAAI,EAAEC,QAAQ,EAAEC,GAAG,EAAEC,KAAK,EAAE;MACrD;MACA;MACA;MACA;MACA;MACA,IAAKH,IAAI,IAAI5C,IAAI,CAACgD,WAAW,GAAGhD,IAAI,CAACiD,WAAW,CAAC,IAAKH,GAAG,CAACI,QAAQ,IAAIJ,GAAG,CAACK,OAAO,EAAE;MACnFJ,KAAK,CAACK,2BAA2B,CAACpD,IAAI,EAAE6C,QAAQ,EAAEC,GAAG,CAAC;IAC1D,CAAC;IAED;IACAO,eAAe,EAAE,UAASrD,IAAI,EAAE4C,IAAI,EAAEG,KAAK,EAAE;MACzC,OAAOA,KAAK,CAACO,wBAAwB,CAACtD,IAAI,EAAE4C,IAAI,CAAC;IACrD,CAAC;IAEDW,YAAY,EAAE,IAAI;IAAE;;IAEpBC,WAAW,EAAE,IAAI;IAAE;;IAEnBC,QAAQ,EAAE,IAAI;IAEd;;IAEAC,iBAAiB,EAAE,IAAI;IAEvBC,eAAe,EAAE,IAAI;IAErBC,kBAAkB,EAAE,IAAI;IAExBC,oBAAoB,EAAElH,YAAY;IAElCmH,eAAe,EAAEhH,OAAO;IAExBiH,mBAAmB,EAAEnH,WAAW;IAEhCoH,wBAAwB,EAAEnH,gBAAgB;IAE1CoH,QAAQ,EAAE;EACd,CAAC;EAEDC,MAAM,EAAE;IACJ,UAAU,EAAE,iBAAiB;IAC7B,QAAQ,EAAE,iBAAiB;IAC3B,aAAa,EAAE,aAAa;IAC5B,WAAW,EAAE,aAAa;IAC1B,YAAY,EAAE,aAAa;IAC3B,WAAW,EAAE,WAAW;IACxB,UAAU,EAAE,UAAU;IACtB,YAAY,EAAE,YAAY;IAC1B,YAAY,EAAE,YAAY;IAC1B,OAAO,EAAE,YAAY;IACrB,wBAAwB,EAAE,YAAY;IACtC,wBAAwB,EAAE,YAAY;IACtC,yBAAyB,EAAE,YAAY;IACvC,yBAAyB,EAAE,YAAY;IACvC,+BAA+B,EAAE,uBAAuB;IACxD,kCAAkC,EAAE,mBAAmB;IACvD,8BAA8B,EAAE,SAAS;IAAE;IAC3C,+BAA+B,EAAE,SAAS;IAC1C,6BAA6B,EAAE,kBAAkB,CAAC;EACtD,CAAC;;EAEDC,cAAc,EAAE;IACZ,WAAW,EAAE,aAAa;IAC1B,WAAW,EAAE,aAAa;IAC1B,SAAS,EAAE,WAAW;IACtB,UAAU,EAAE,WAAW;IACvB,aAAa,EAAE;EACnB,CAAC;EAEDC,GAAG,EAAE,IAAI;EACTX,QAAQ,EAAE,IAAI;EACdY,IAAI,EAAE,IAAI;EACVC,KAAK,EAAE,IAAI;EACXC,WAAW,EAAE,IAAI;EACjBC,MAAM,EAAE,IAAI;EACZC,KAAK,EAAE,IAAI;EACXC,SAAS,EAAE,IAAI;EAEf;EACAC,eAAe,EAAE,IAAI;EACrB;EACA;EACAC,wBAAwB,EAAE,IAAI;EAC9B;EACAC,QAAQ,EAAE,IAAI;EACd;EACAC,OAAO,EAAE,IAAI;EAEbC,qBAAqB,EAAE,CAAC,KAAK,EAAE,UAAU,EAAE,SAAS,CAAC;EACrDC,uBAAuB,EAAE,CAAC,WAAW,CAAC;EACtC;EACA;EACAC,sBAAsB,EAAE,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC;EAC3E;EACA;EACAC,iBAAiB,EAAE;EACf;EACA;EACA;EACA;EACA;EACA;EACA,QAAQ,CACX;EACDC,SAAS,EAAE,IAAI;EAEfC,IAAI,EAAE,YAAW;IAEb,MAAM;MAAEpH,OAAO;MAAEqH;IAAG,CAAC,GAAG,IAAI;IAC5B,IAAI,CAACrH,OAAO,CAAC0F,iBAAiB,EAAE;MAC5B;MACA1F,OAAO,CAAC0F,iBAAiB,GAAG,OAAO4B,KAAK,KAAK,WAAW,IAAIzJ,GAAG,CAACyJ,KAAK,EAAE,QAAQ,CAAC,GAAGA,KAAK,CAACC,MAAM,GAAG,IAAI;MACtG;IACJ;;IAEA,MAAMC,KAAK,GAAG,IAAI,CAACA,KAAK,GAAGxH,OAAO,CAACwH,KAAK,IAAI,IAAIhJ,KAAK;;IAErD;IACA,IAAI,CAACsI,OAAO,GAAG,CAAC,CAAC;IAEjB,IAAI,CAACW,OAAO,CAACzH,OAAO,CAACmB,QAAQ,CAAC;IAC9B,IAAI,CAACuG,YAAY,EAAE;IACnB,IAAI,CAACC,MAAM,EAAE;IACb,IAAI,CAACC,cAAc,EAAE;IACrB,IAAI,CAACC,cAAc,EAAE;;IAErB;IACA,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC;;IAEhB;IACA,IAAI,CAACC,cAAc,GAAG;MAClBC,KAAK,EAAE,IAAI;MACXC,MAAM,EAAE;IACZ,CAAC;;IAED;IACA,IAAI,CAACvB,SAAS,GAAG3H,CAAC,CAACsI,EAAE,CAACa,aAAa,CAAC;IACpC;IACA,IAAI,CAACC,UAAU,CAACX,KAAK,CAACY,UAAU,CAACC,KAAK,CAACC,MAAM,CAAC;IAC9C;IACA,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE,IAAI,IAAI,CAACC,OAAO,EAAE,EAAE,IAAI,CAACC,gBAAgB,EAAE;EACnE,CAAC;EAEDC,aAAa,EAAE,YAAW;IACtB,OAAO,IAAI,CAAC7B,QAAQ,GAAG;MACnB8B,EAAE,EAAE,IAAI;MACRC,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACxBC,aAAa,EAAE,EAAE;MACjBC,WAAW,EAAE,EAAE;MACfC,SAAS,EAAE,CAAC,CAAC;MACbC,OAAO,EAAE,CAAC,CAAC;MACXC,KAAK,EAAE,CAAC;MACRC,SAAS,EAAE,KAAK;MAChBC,SAAS,EAAE,IAAI;MACfC,IAAI,EAAE,KAAK;MACXC,QAAQ,EAAE,KAAK;MACfC,IAAI,EAAE;IACV,CAAC;EACL,CAAC;EAEDzB,cAAc,EAAE,YAAW;IACvB,IAAIL,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAI,CAAC+B,QAAQ,CAAC/B,KAAK,EAAE,KAAK,EAAE,IAAI,CAACgC,WAAW,CAAC,CACxCD,QAAQ,CAAC/B,KAAK,EAAE,QAAQ,EAAE,IAAI,CAACiC,aAAa,CAAC,CAC7CF,QAAQ,CAAC/B,KAAK,EAAE,QAAQ,EAAE,IAAI,CAACkC,YAAY,CAAC,CAC5CH,QAAQ,CAAC/B,KAAK,EAAE,OAAO,EAAE,IAAI,CAACmC,YAAY,CAAC,CAC3CJ,QAAQ,CAAC/B,KAAK,EAAE,MAAM,EAAE,IAAI,CAACoC,WAAW,CAAC,CACzCL,QAAQ,CAAC/B,KAAK,EAAE,YAAY,EAAE,IAAI,CAACqC,gBAAgB,CAAC;IACzD,IAAI,CAACC,EAAE,CAAC,gBAAgB,EAAE,IAAI,CAACC,eAAe,CAAC,CAC1CD,EAAE,CAAC,kBAAkB,EAAE,IAAI,CAACE,iBAAiB,CAAC,CAC9CF,EAAE,CAAC,iBAAiB,EAAE,IAAI,CAACG,MAAM,CAAC;EAC3C,CAAC;EAEDT,WAAW,EAAE,UAASU,IAAI,EAAEC,CAAC,EAAErF,GAAG,EAAE;IAChC,IAAIsF,QAAQ,GAAGtF,GAAG,CAACsF,QAAQ;IAC3B,IAAI,IAAI,CAAC5B,OAAO,EAAE,IAAI,CAACzM,QAAQ,CAACqO,QAAQ,CAAC,EAAE;MACvC,IAAI,CAACC,UAAU,CAACH,IAAI,EAAEpF,GAAG,CAAC;IAC9B,CAAC,MAAM;MACH,IAAIA,GAAG,CAACwF,WAAW,KAAKF,QAAQ,EAAE,IAAI,CAACG,MAAM,CAAC;QAAEC,GAAG,EAAE;MAAW,CAAC,CAAC;MAClE,IAAI,CAACH,UAAU,CAACH,IAAI,EAAEpF,GAAG,CAAC;MAC1B,IAAIsF,QAAQ,KAAK,CAAC,EAAE,IAAI,CAACK,QAAQ,CAAC;QAAED,GAAG,EAAE;MAAW,CAAC,CAAC;IAC1D;EACJ,CAAC;EAEDf,aAAa,EAAE,UAASS,IAAI,EAAEC,CAAC,EAAErF,GAAG,EAAE;IAClC,MAAM9C,IAAI,GAAG,IAAI,CAAC0I,eAAe,CAACR,IAAI,CAAC;IACvC,IAAIlI,IAAI,EAAE,IAAI,CAAC2I,iBAAiB,CAAC3I,IAAI,EAAEA,IAAI,CAACiD,WAAW,EAAEjD,IAAI,CAAC4I,eAAe,EAAE9F,GAAG,CAAC;EACvF,CAAC;EAED4E,YAAY,EAAE,UAASQ,IAAI,EAAEpF,GAAG,EAAE;IAC9B,IAAIoF,IAAI,KAAK,IAAI,CAAC1C,KAAK,CAACY,UAAU,CAACC,KAAK,EAAE;IAC1C,IAAI6B,IAAI,CAACW,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC7K,OAAO,CAACwE,OAAO,KAAKvF,YAAY,CAACE,MAAM,EAAE;MACtE,MAAM6C,IAAI,GAAG,IAAI,CAAC0I,eAAe,CAACR,IAAI,CAAC;MACvC,IAAIlI,IAAI,EAAE,IAAI,CAAC2I,iBAAiB,CAAC3I,IAAI,EAAEA,IAAI,CAACgD,WAAW,EAAEhD,IAAI,CAAC4I,eAAe,EAAE9F,GAAG,CAAC;IACvF;EACJ,CAAC;EAED6E,YAAY,EAAE,UAASmB,UAAU,EAAEhG,GAAG,EAAE;IACpC,IAAI,CAACiG,WAAW,EAAE;IAClB,IAAI,CAAC5C,UAAU,CAAC2C,UAAU,CAACxC,MAAM,EAAExD,GAAG,CAAC;EAC3C,CAAC;EAED8E,WAAW,EAAE,YAAW;IACpB,IAAI,IAAI,CAACpC,KAAK,CAACwD,cAAc,CAAC,IAAI,CAACjE,qBAAqB,CAAC,EAAE;IAC3D,IAAI,CAACkE,SAAS,EAAE;EACpB,CAAC;EAEDpB,gBAAgB,EAAE,UAASqB,IAAI,EAAE;IAC7B,IAAI,IAAI,CAAC3C,QAAQ,EAAE,EAAE;IACrB,IAAIxI,IAAI,GAAGmL,IAAI,IAAIA,IAAI,CAACC,SAAS;IACjC,IAAIC,KAAK,GAAG,IAAI,CAAC5D,KAAK;IACtB,IAAI,CAAC,IAAI,CAACgB,OAAO,EAAE,EAAE;MACjB,IAAI6C,qBAAqB,GAAG,IAAI,CAACrE,uBAAuB;MACxD,IAAIqE,qBAAqB,CAACC,QAAQ,CAACvL,IAAI,CAAC,IAAI,CAACqL,KAAK,CAACJ,cAAc,CAACK,qBAAqB,CAAC,EAAE;QACtF,IAAI,CAACE,WAAW,CAACL,IAAI,CAAC;MAC1B;IACJ;IACA,IAAIM,mBAAmB,GAAG,IAAI,CAACzE,qBAAqB;IACpD,IAAIyE,mBAAmB,CAACF,QAAQ,CAACvL,IAAI,CAAC,IAAI,CAACqL,KAAK,CAACJ,cAAc,CAACQ,mBAAmB,CAAC,EAAE;MAClF,IAAI,CAACP,SAAS,EAAE;IACpB;EACJ,CAAC;EAEDvD,YAAY,EAAE,YAAW;IAErB,MAAM;MAAE1H;IAAQ,CAAC,GAAG,IAAI;IACxB,MAAM;MACFwC,gBAAgB;MAChBC,aAAa;MACbG,sBAAsB;MACtBF,aAAa;MACbC,iBAAiB;MACjB5B,MAAM;MACNkB,YAAY;MACZyD,iBAAiB;MACjBzB;IACJ,CAAC,GAAGjE,OAAO;;IAEX;IACA;IACA,IAAI,CAAC0F,iBAAiB,IAAI,OAAO4B,KAAK,KAAK,WAAW,IAAIzJ,GAAG,CAACyJ,KAAK,EAAE,QAAQ,CAAC,EAAE;MAC5EtH,OAAO,CAAC0F,iBAAiB,GAAG4B,KAAK,CAACC,MAAM;IAC5C;IACA;;IAEA;IACA;IACA,IAAI,CAAC/K,UAAU,CAACgG,gBAAgB,CAAC,EAAE;MAC/BxC,OAAO,CAACwC,gBAAgB,GAAGlF,SAAS,CAACkF,gBAAgB,CAAC;IAC1D;IACA,IAAI,CAAChG,UAAU,CAACiG,aAAa,CAAC,EAAE;MAC5BzC,OAAO,CAACyC,aAAa,GAAGnF,SAAS,CAACmF,aAAa,CAAC;IACpD;IACA,IAAI,CAACjG,UAAU,CAACoG,sBAAsB,CAAC,EAAE;MACrC5C,OAAO,CAAC4C,sBAAsB,GAAGtF,SAAS,CAACsF,sBAAsB,CAAC;IACtE;IACA,IAAI,CAACpG,UAAU,CAACkG,aAAa,CAAC,EAAE;MAC5B1C,OAAO,CAAC0C,aAAa,GAAGpF,SAAS,CAACoF,aAAa,CAAC;IACpD;IACA,IAAI,CAAClG,UAAU,CAACmG,iBAAiB,CAAC,EAAE;MAChC3C,OAAO,CAAC2C,iBAAiB,GAAGrF,SAAS,CAACqF,iBAAiB,CAAC;IAC5D;IACA,IAAIlG,aAAa,CAACwH,WAAW,CAAC,EAAE;MAC5BjE,OAAO,CAACiE,WAAW,GAAGjI,MAAM,CAAC,CAAC,CAAC,EAAEiI,WAAW,CAAC;IACjD;IACA,IAAIxH,aAAa,CAACwF,YAAY,CAAC,EAAE;MAC7B;MACAjC,OAAO,CAACiC,YAAY,GAAG5F,YAAY,CAAC,CAAC,CAAC,EAAE4F,YAAY,EAAEpC,mBAAmB,CAAC;IAC9E;IACAG,OAAO,CAACe,MAAM,GAAG/E,MAAM,CAAC,CAAC,CAAC,EAAE+E,MAAM,CAAC;EACvC,CAAC;EAED0K,QAAQ,EAAE,YAAW;IACjB,IAAIC,EAAE,GAAG5P,CAAC,CAAC6P,SAAS;IACpB,OAAO,CAAC;MACJC,YAAY,EAAEF,EAAE,CAACG,KAAK;MACtBC,OAAO,EAAE,KAAK;MACd3L,SAAS,EAAE7D,kBAAkB,CAAC,kBAAkB,CAAC;MACjDyP,QAAQ,EAAE;IACd,CAAC,EAAE;MACCH,YAAY,EAAEF,EAAE,CAACG,KAAK;MACtBC,OAAO,EAAE,KAAK;MACd3L,SAAS,EAAE7D,kBAAkB,CAAC,YAAY,CAAC;MAC3CyP,QAAQ,EAAE;IACd,CAAC,EAAE;MACCH,YAAY,EAAEF,EAAE,CAACtF,GAAG;MACpB0F,OAAO,EAAE,KAAK;MACd1D,UAAU,EAAE;QACR,OAAO,EAAE,MAAM;QACf,QAAQ,EAAE,MAAM;QAChB,aAAa,EAAEsD,EAAE,CAACM;MACtB,CAAC;MACDD,QAAQ,EAAE,KAAK;MACfN,QAAQ,EAAE,CAAC;QACP;QACA;QACAK,OAAO,EAAE,MAAM;QACfC,QAAQ,EAAE;MACd,CAAC,EAAE;QACCD,OAAO,EAAE,GAAG;QACZ3L,SAAS,EAAE7D,kBAAkB,CAAC,QAAQ,CAAC;QACvCyP,QAAQ,EAAE;MACd,CAAC;IACL,CAAC,CAAC;EACN,CAAC;EAEDE,YAAY,CAACC,SAAS,EAAE;IACpB,OAASA,SAAS,IAAI,IAAI,CAACpF,OAAO;EACtC,CAAC;EAEDqF,YAAY,CAACD,SAAS,EAAE;IACpB,MAAM;MAAEpF;IAAQ,CAAC,GAAG,IAAI;IACxB,IAAIoF,SAAS,IAAIpF,OAAO,EAAE,OAAOA,OAAO,CAACoF,SAAS,CAAC;IACnD,MAAM,IAAIE,KAAK,CAAE,6BAA4BF,SAAU,GAAE,CAAC;EAC9D,CAAC;EAEDG,YAAY,CAACH,SAAS,EAAE;IACpB,OAAO,IAAI,CAACC,YAAY,CAACD,SAAS,CAAC,CAAC7E,EAAE;EAC1C,CAAC;EAEDM,MAAM,EAAE,YAAW;IAEf,IAAI,CAAC2E,cAAc,EAAE;IACrB,MAAM;MAAEC,UAAU;MAAEvM;IAAQ,CAAC,GAAG,IAAI;IACpC,MAAM;MAAEoG,GAAG;MAAEC,IAAI;MAAEG,MAAM;MAAEnF,UAAU;MAAEmL;IAAK,CAAC,GAAGD,UAAU;IAE1DnG,GAAG,CAACqG,KAAK,CAACxG,QAAQ,GAAGjG,OAAO,CAACiG,QAAQ,GAAG,SAAS,GAAG,QAAQ;IAE5D,IAAI,CAACG,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACG,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACD,WAAW,GAAGxH,CAAC,CAACsC,UAAU,CAAC;IAChC,IAAI,CAACoF,KAAK,GAAG1H,CAAC,CAACyN,IAAI,CAAC;IAEpB,IAAI,CAACE,YAAY,EAAE;IAEnB5Q,CAAC,CAAC6Q,QAAQ,CAACvG,GAAG,CAAC;IAEf,IAAIpG,OAAO,CAACqB,UAAU,EAAE;MACpB,IAAI,CAACuL,cAAc,CAAC5M,OAAO,CAACqB,UAAU,CAAC;IAC3C;IAEA,IAAIrB,OAAO,CAACmB,QAAQ,EAAE;MAClB,IAAI,CAACA,QAAQ,EAAE;IACnB;IAEA,OAAO,IAAI;EACf,CAAC;EAEDuL,YAAY,EAAE,UAASlG,MAAM,GAAGnG,aAAa,EAAE;IAC3C,IAAI,CAACwM,YAAY,EAAE;IACnB;IACArG,MAAM,CAACsG,OAAO,CAAC,CAAC;MAAE/M,IAAI;MAAEgN;IAAO,CAAC,KAAK;MACjC,MAAMC,SAAS,GAAG,IAAItO,UAAU,CAAC;QAAEqB;MAAK,CAAC,CAAC;MAC1C,IAAI,CAACyG,MAAM,CAACyG,WAAW,CAACD,SAAS,CAAC3F,EAAE,CAAC;MACrC,IAAI,CAACP,OAAO,CAAC/G,IAAI,CAAC,GAAGiN,SAAS;IAClC,CAAC,CAAC;IACF;IACA,MAAME,cAAc,GAAG,IAAI,CAACf,YAAY,CAAC1N,WAAW,CAAC8B,KAAK,CAAC;IAC3D,MAAM4M,cAAc,GAAG,IAAI,CAAChB,YAAY,CAAC1N,WAAW,CAACiC,KAAK,CAAC;IAC3D,MAAM0M,eAAe,GAAG,IAAI,CAACjB,YAAY,CAAC1N,WAAW,CAAC+B,MAAM,CAAC;IAC7D;IACA,IAAI,CAAC8F,KAAK,GAAG6G,cAAc,CAAC9F,EAAE;IAC9B,IAAI,CAACgB,KAAK,GAAG,IAAI,CAAC5C,QAAQ,GAAGyH,cAAc,CAAC7F,EAAE;IAC9C;IACA6F,cAAc,CAACG,GAAG,CAACC,QAAQ,CAAChR,kBAAkB,CAAC,UAAU,CAAC,CAAC;IAC3D8Q,eAAe,CAACC,GAAG,CAACC,QAAQ,CAAChR,kBAAkB,CAAC,UAAU,CAAC,CAAC;EAChE,CAAC;EAEDuQ,YAAY,EAAE,YAAW;IACrB,MAAM;MAAE/F;IAAQ,CAAC,GAAG,IAAI;IACxByG,MAAM,CAACC,IAAI,CAAC1G,OAAO,CAAC,CAACgG,OAAO,CAAC/M,IAAI,IAAI;MACjC+G,OAAO,CAAC/G,IAAI,CAAC,CAAC0N,MAAM,EAAE;MACtB,OAAO3G,OAAO,CAAC/G,IAAI,CAAC;IACxB,CAAC,CAAC;EACN,CAAC;EAEDgL,WAAW,EAAE,YAAW;IACpB,MAAM;MAAEjE;IAAQ,CAAC,GAAG,IAAI;IACxByG,MAAM,CAACC,IAAI,CAAC1G,OAAO,CAAC,CAACgG,OAAO,CAAC/M,IAAI,IAAI;MACjC+G,OAAO,CAAC/G,IAAI,CAAC,CAAC2N,YAAY,EAAE;IAChC,CAAC,CAAC;EACN,CAAC;EAEDzD,MAAM,EAAE,YAAW;IAEf,IAAI,IAAI,CAACjK,OAAO,CAACmB,QAAQ,EAAE;MACvB,IAAI,CAACA,QAAQ,EAAE;IACnB;IAEA,IAAI,IAAI,CAACwM,WAAW,EAAE;MAClB,IAAI,CAACC,qBAAqB,CAAC,IAAI,CAACD,WAAW,CAAC;IAChD;IAEA,OAAO,IAAI;EACf,CAAC;EAEDE,MAAM,EAAE,UAASC,GAAG,EAAE;IAElB,IAAIrI,QAAQ,GAAG,IAAI,CAACe,MAAM;;IAE1B;IACA,IAAIsH,GAAG,KAAKC,SAAS,EAAE;MAEnB,IAAIC,eAAe,GAAGvI,QAAQ,CAACvC,YAAY,CAAC,WAAW,CAAC;MAExD,IAAI,CAAC,IAAI,CAAC0D,wBAAwB,IAAI,IAAI,MAAMoH,eAAe,EAAE;QAC7D;QACA;QACAF,GAAG,GAAG,IAAI,CAACnH,eAAe;MAC9B,CAAC,MAAM;QACH;QACAmH,GAAG,GAAGrI,QAAQ,CAACwI,MAAM,EAAE;QACvB,IAAI,CAACtH,eAAe,GAAGmH,GAAG;QAC1B,IAAI,CAAClH,wBAAwB,GAAGoH,eAAe;MACnD;;MAEA;MACA;MACA,OAAOlS,CAAC,CAACoS,eAAe,CAACJ,GAAG,CAAC;IACjC;;IAEA;IACAA,GAAG,GAAGhS,CAAC,CAACoS,eAAe,CAACJ,GAAG,CAAC;IAC5B,IAAIK,SAAS,GAAGrS,CAAC,CAACsS,uBAAuB,CAACN,GAAG,CAAC;IAC9CrI,QAAQ,CAAC4I,YAAY,CAAC,WAAW,EAAEF,SAAS,CAAC;IAE7C,IAAI,CAACxH,eAAe,GAAGmH,GAAG;IAC1B,IAAI,CAAClH,wBAAwB,GAAGnB,QAAQ,CAACvC,YAAY,CAAC,WAAW,CAAC;IAElE,OAAO,IAAI;EACf,CAAC;EAEDoL,YAAY,EAAE,YAAW;IAErB,OAAOxS,CAAC,CAACoS,eAAe,CAAC,IAAI,CAAC7F,KAAK,CAACkG,YAAY,EAAE,CAAC;EACvD,CAAC;EAEDnJ,2BAA2B,EAAE,UAASpD,IAAI,EAAE6C,QAAQ,EAAEC,GAAG,EAAE;IACvD,IAAI9C,IAAI,YAAY7D,QAAQ,EAAE;MAC1B,IAAIqJ,KAAK,GAAGxF,IAAI,CAACwF,KAAK;MACtB,IAAIgH,KAAK,GAAG,IAAI,CAAChH,KAAK,CAACiH,iBAAiB,CAACjH,KAAK,CAAC;MAC/C,KAAK,IAAIkH,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGH,KAAK,CAACI,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;QAC1C,IAAIG,IAAI,GAAGL,KAAK,CAACE,CAAC,CAAC;QACnB,IAAIlN,QAAQ,GAAG,IAAI,CAACkJ,eAAe,CAACmE,IAAI,CAAC;QACzC,IAAI,CAACrN,QAAQ,EAAE;QACf,IAAIsN,UAAU,GAAG,CAAC,QAAQ,CAAC;QAC3B,IAAID,IAAI,CAACE,aAAa,EAAE,KAAKvH,KAAK,EAAEsH,UAAU,CAACE,IAAI,CAAC,QAAQ,CAAC;QAC7D,IAAIH,IAAI,CAACI,aAAa,EAAE,KAAKzH,KAAK,EAAEsH,UAAU,CAACE,IAAI,CAAC,QAAQ,CAAC;QAC7D,IAAIE,YAAY,GAAGC,IAAI,CAACC,GAAG,CAACvK,QAAQ,GAAG,CAAC,EAAErD,QAAQ,CAACoJ,eAAe,CAAC;QACnE,IAAI,CAACyE,kBAAkB,CAAC7N,QAAQ,EAAEA,QAAQ,CAAC8N,OAAO,CAACR,UAAU,CAAC,EAAEI,YAAY,EAAEpK,GAAG,CAAC;MACtF;IACJ;EACJ,CAAC;EAEDQ,wBAAwB,EAAE,UAAStD,IAAI,EAAE4C,IAAI,EAAE;IAC3C,IAAI,CAAC5C,IAAI,IAAI,EAAEA,IAAI,YAAY7D,QAAQ,CAAC,EAAE,OAAO,KAAK;IACtD,IAAIqJ,KAAK,GAAGxF,IAAI,CAACwF,KAAK;IACtB,IAAIA,KAAK,CAAC+H,SAAS,EAAE,EAAE,OAAO,KAAK;IACnC,IAAI,CAAC3K,IAAI,GAAG5C,IAAI,CAACsN,OAAO,CAAC,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC,MAAM,CAAC,EAAE;MACnD,IAAIE,WAAW,GAAG;QAAEC,MAAM,EAAE;MAAK,CAAC;MAClC;MACA;MACA,IAAIC,UAAU,GAAG,CAAC;MAClB,IAAIC,UAAU,GAAG,IAAI,CAACjF,eAAe,CAAClD,KAAK,CAACyH,aAAa,EAAE,CAAC;MAC5D,IAAIU,UAAU,IAAI,CAAC,IAAI,CAACC,aAAa,CAACD,UAAU,CAAC,EAAE;QAC/CD,UAAU,GAAG,IAAI,CAACG,QAAQ,CAACF,UAAU,EAAEH,WAAW,CAAC;QACnDxN,IAAI,CAAC8N,eAAe,CAAC,QAAQ,CAAC;MAClC;MACA,IAAIC,UAAU,GAAG,CAAC;MAClB,IAAIC,UAAU,GAAG,IAAI,CAACtF,eAAe,CAAClD,KAAK,CAACuH,aAAa,EAAE,CAAC;MAC5D,IAAIiB,UAAU,IAAI,CAAC,IAAI,CAACJ,aAAa,CAACI,UAAU,CAAC,EAAE;QAC/CD,UAAU,GAAG,IAAI,CAACF,QAAQ,CAACG,UAAU,EAAER,WAAW,CAAC;QACnDxN,IAAI,CAAC8N,eAAe,CAAC,QAAQ,CAAC;MAClC;MACA,IAAIJ,UAAU,KAAK,CAAC,IAAIK,UAAU,KAAK,CAAC,EAAE;QACtC;QACA,OAAO,CAAC,IAAI,CAACF,QAAQ,CAAC7N,IAAI,EAAEwN,WAAW,CAAC;MAC5C;IACJ;IACA,OAAO,KAAK;EAChB,CAAC;EAED7E,iBAAiB,EAAE,UAAS3I,IAAI,EAAE4C,IAAI,EAAEC,QAAQ,EAAEC,GAAG,EAAE;IACnDA,GAAG,KAAKA,GAAG,GAAG,CAAC,CAAC,CAAC;IACjB,IAAI,CAACuK,kBAAkB,CAACrN,IAAI,EAAE4C,IAAI,EAAEC,QAAQ,EAAEC,GAAG,CAAC;IAClD,IAAI0D,OAAO,GAAG,IAAI,CAACA,OAAO,EAAE;IAC5B,IAAI,IAAI,CAACD,QAAQ,EAAE,IAAKC,OAAO,IAAI1D,GAAG,CAACmL,KAAK,KAAK,KAAM,EAAE;IACzD,IAAI,IAAI,CAACzI,KAAK,CAACwD,cAAc,CAAC,IAAI,CAAChE,uBAAuB,CAAC,EAAE;IAC7D,IAAIkJ,KAAK,GAAG,IAAI,CAAC3E,WAAW,CAACzG,GAAG,CAAC;IACjC,IAAI0D,OAAO,EAAE,IAAI,CAAC2H,iBAAiB,CAACD,KAAK,EAAEpL,GAAG,CAAC;EACnD,CAAC;EAEDuK,kBAAkB,EAAE,UAASrN,IAAI,EAAEoO,IAAI,EAAEvL,QAAQ,EAAEC,GAAG,EAAE;IACpD,MAAM;MAAE+B,QAAQ,EAAEwJ,OAAO;MAAErQ;IAAQ,CAAC,GAAG,IAAI;IAC3C,IAAIqQ,OAAO,CAAC/G,IAAI,EAAE;MACd,IAAItJ,OAAO,CAAC0E,UAAU,EAAE;QACpB2L,OAAO,CAAC/G,IAAI,GAAG,KAAK;QACpB,IAAI,CAACmB,QAAQ,EAAE;MACnB;IACJ;IACA,MAAM;MAAExF,WAAW;MAAED,WAAW;MAAE4F,eAAe;MAAE0F;IAAI,CAAC,GAAGtO,IAAI;IAC/D,IAAIuO,eAAe,GAAGF,OAAO,CAACzH,UAAU,CAAC/D,QAAQ,CAAC;IAClD,IAAI,CAAC0L,eAAe,EAAEA,eAAe,GAAGF,OAAO,CAACzH,UAAU,CAAC/D,QAAQ,CAAC,GAAG,CAAC,CAAC;IACzE;IACA,IAAIA,QAAQ,GAAG+F,eAAe,EAAE;MAC5B;MACA;MACA;MACA;MACA;MACA,KAAK,IAAI4F,CAAC,GAAG3L,QAAQ,GAAG,CAAC,EAAE2L,CAAC,IAAI5F,eAAe,EAAE4F,CAAC,EAAE,EAAE;QAClD,MAAMC,mBAAmB,GAAGJ,OAAO,CAACzH,UAAU,CAAC4H,CAAC,CAAC;QACjD,IAAI,CAACC,mBAAmB,IAAI,EAAEH,GAAG,IAAIG,mBAAmB,CAAC,EAAE;QAC3DF,eAAe,CAACD,GAAG,CAAC,IAAIG,mBAAmB,CAACH,GAAG,CAAC;QAChD,OAAOG,mBAAmB,CAACH,GAAG,CAAC;MACnC;IACJ;IACA,IAAII,WAAW,GAAGH,eAAe,CAACD,GAAG,CAAC,IAAI,CAAC;IAC3C;IACA,IAAI,CAACI,WAAW,GAAGN,IAAI,MAAMA,IAAI,EAAE;IACnC,IAAI,CAACM,WAAW,EAAEL,OAAO,CAACpH,KAAK,EAAE;IACjC,IAAImH,IAAI,GAAGnL,WAAW,IAAIyL,WAAW,GAAG1L,WAAW,EAAE;MACjD;MACAuL,eAAe,CAACD,GAAG,CAAC,IAAItL,WAAW;IACvC,CAAC,MAAM,IAAIoL,IAAI,GAAGpL,WAAW,IAAI0L,WAAW,GAAGzL,WAAW,EAAE;MACxD;MACAsL,eAAe,CAACD,GAAG,CAAC,IAAIrL,WAAW;IACvC;IACAsL,eAAe,CAACD,GAAG,CAAC,IAAIF,IAAI;IAC5B,MAAMO,YAAY,GAAG3Q,OAAO,CAAC2E,YAAY;IACzC,IAAI,OAAOgM,YAAY,KAAK,UAAU,EAAEA,YAAY,CAACC,IAAI,CAAC,IAAI,EAAE5O,IAAI,EAAEoO,IAAI,EAAEvL,QAAQ,EAAEC,GAAG,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC;EAC1G,CAAC;EAED+L,cAAc,EAAE,UAAS7O,IAAI,EAAE;IAC3B,IAAI,CAACA,IAAI,EAAE,OAAO,CAAC;IACnB,IAAIqO,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC3B,IAAIyJ,GAAG,GAAGtO,IAAI,CAACsO,GAAG;IAClB,IAAIC,eAAe,GAAGF,OAAO,CAACzH,UAAU,CAAC5G,IAAI,CAAC4I,eAAe,CAAC;IAC9D,IAAIhG,IAAI,GAAG,IAAI,CAACkM,mBAAmB,CAAC9O,IAAI,CAAC,GAAGuO,eAAe,CAACD,GAAG,CAAC;IAChE,OAAOC,eAAe,CAACD,GAAG,CAAC;IAC3B,OAAO1L,IAAI;EACf,CAAC;EAEDiL,QAAQ,EAAE,UAAS7N,IAAI,EAAE8C,GAAG,GAAG,CAAC,CAAC,EAAE;IAC/B,MAAMF,IAAI,GAAG,IAAI,CAACiM,cAAc,CAAC7O,IAAI,CAAC;IACtC,IAAI,CAAC4C,IAAI,EAAE,OAAO,CAAC;IACnB,MAAMmM,YAAY,GAAG,CAACjM,GAAG,CAAC2K,MAAM;IAChC,IAAIsB,YAAY,EAAE,IAAI,CAACC,kBAAkB,CAAClM,GAAG,CAAC;IAC9C,MAAMmM,QAAQ,GAAG,IAAI,CAACC,UAAU,CAAClP,IAAI,EAAE4C,IAAI,EAAEE,GAAG,CAAC;IACjD,IAAIiM,YAAY,EAAE;MACd,MAAMb,KAAK,GAAG;QAAEiB,OAAO,EAAE,CAAC;QAAEtM,QAAQ,EAAE7C,IAAI,CAAC4I;MAAgB,CAAC;MAC5D,IAAI,CAACuF,iBAAiB,CAACD,KAAK,EAAEpL,GAAG,CAAC;IACtC;IACA,OAAOmM,QAAQ;EACnB,CAAC;EAEDC,UAAU,EAAE,UAASlP,IAAI,EAAE4C,IAAI,EAAEE,GAAG,EAAE;IAClC,IAAI,CAAC9C,IAAI,EAAE,OAAO,CAAC;IACnB,MAAM;MAAEiD,WAAW;MAAED,WAAW;MAAEoM,SAAS;MAAE5J;IAAM,CAAC,GAAGxF,IAAI;IAC3D,IAAIA,IAAI,YAAY7D,QAAQ,EAAE;MAC1B,IAAIyG,IAAI,GAAGK,WAAW,EAAE;QACpB,IAAI,CAACoM,UAAU,CAAC7J,KAAK,CAAC;QACtB,OAAO,CAAC;MACZ;MACA,IAAI5C,IAAI,GAAGI,WAAW,EAAE;QACpB,MAAMsM,eAAe,GAAG,CAAC,EAAE1M,IAAI,GAAGwM,SAAS,CAAC;QAC5C,IAAIE,eAAe,EAAE;UACjB1M,IAAI,IAAIwM,SAAS;QACrB;QACA,IAAI,CAACG,UAAU,CAACvP,IAAI,EAAEsP,eAAe,CAAC;QACtC1M,IAAI,IAAII,WAAW;MACvB;IACJ;IACA,IAAI,CAACJ,IAAI,EAAE,OAAO,CAAC;IACnB,OAAO5C,IAAI,CAACwP,aAAa,CAAC5M,IAAI,EAAEE,GAAG,IAAI,CAAC,CAAC,CAAC;EAC9C,CAAC;EAED2M,WAAW,EAAE,UAASjK,KAAK,EAAE1C,GAAG,EAAE;IAC9B,IAAI9C,IAAI,GAAG,IAAI,CAAC0I,eAAe,CAAClD,KAAK,CAAC;IACtC,IAAI,CAACxF,IAAI,EAAE,OAAO,IAAI;IACtB,IAAI,CAAC6N,QAAQ,CAAC7N,IAAI,EAAE8C,GAAG,CAAC;IACxB,OAAO9C,IAAI;EACf,CAAC;EAED0P,qBAAqB,EAAE,UAAS1P,IAAI,EAAE;IAClC,IAAIsO,GAAG,GAAGtO,IAAI,CAACsO,GAAG;IAClB,IAAID,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC3B,IAAIyJ,GAAG,IAAID,OAAO,CAACtH,SAAS,EAAE,OAAO,CAAC;IACtC,IAAInE,IAAI,GAAGyL,OAAO,CAACtH,SAAS,CAACuH,GAAG,CAAC,IAAItO,IAAI,CAACgD,WAAW;IACrDqL,OAAO,CAACxH,aAAa,CAACmG,IAAI,CAACsB,GAAG,CAAC;IAC/B,OAAOD,OAAO,CAACrH,OAAO,CAACsH,GAAG,CAAC;IAC3B,OAAO1L,IAAI;EACf,CAAC;EAEDkM,mBAAmB,EAAE,UAAS9O,IAAI,EAAE;IAChC,IAAIsO,GAAG,GAAGtO,IAAI,CAACsO,GAAG;IAClB,IAAID,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC3B,IAAIyJ,GAAG,IAAID,OAAO,CAACrH,OAAO,EAAE,OAAO,CAAC;IACpCqH,OAAO,CAACrH,OAAO,CAACsH,GAAG,CAAC,GAAG,IAAI;IAC3BD,OAAO,CAACvH,WAAW,CAACkG,IAAI,CAACsB,GAAG,CAAC;IAC7B,IAAI1L,IAAI,GAAGyL,OAAO,CAACtH,SAAS,CAACuH,GAAG,CAAC,IAAI,CAAC;IACtC,OAAOD,OAAO,CAACtH,SAAS,CAACuH,GAAG,CAAC;IAC7B,OAAO1L,IAAI;EACf,CAAC;EAEDgL,aAAa,EAAE,UAAS5N,IAAI,EAAE;IAC1B,IAAI,CAACA,IAAI,EAAE,OAAO,KAAK;IACvB,IAAIsO,GAAG,GAAGtO,IAAI,CAACsO,GAAG;IAClB,IAAID,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC3B,OAAQyJ,GAAG,IAAID,OAAO,CAACrH,OAAO;EAClC,CAAC;EAED2I,SAAS,EAAE,UAAS7M,GAAG,EAAE;IACrB,IAAI8M,UAAU,GAAGxV,QAAQ,CAAC,CAAC,CAAC,EAAE0I,GAAG,EAAE;MAAEW,QAAQ,EAAE;IAAK,CAAC,CAAC;IACtD,IAAI,CAACoM,aAAa,CAACD,UAAU,CAAC;IAC9B,IAAI,CAACrG,WAAW,CAACqG,UAAU,CAAC;EAChC,CAAC;EAED;EACArG,WAAW,EAAE,UAASzG,GAAG,EAAE;IACvB,IAAI,CAACkM,kBAAkB,CAAClM,GAAG,CAAC;IAC5B,IAAIgN,UAAU;IACd,IAAIC,WAAW,GAAG,CAAC;IACnB,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAInN,QAAQ,GAAGnF,YAAY;IAC3B,GAAG;MACCsS,UAAU,EAAE;MACZF,UAAU,GAAG,IAAI,CAACG,gBAAgB,CAACnN,GAAG,CAAC;MACvCiN,WAAW,IAAID,UAAU,CAACX,OAAO;MACjCtM,QAAQ,GAAGsK,IAAI,CAAC+C,GAAG,CAACJ,UAAU,CAACjN,QAAQ,EAAEA,QAAQ,CAAC;IACtD,CAAC,QAAQ,CAACiN,UAAU,CAACK,KAAK;IAC1B,MAAMjC,KAAK,GAAG;MAAEiB,OAAO,EAAEY,WAAW;MAAEK,OAAO,EAAEJ,UAAU;MAAEnN;IAAS,CAAC;IACrE,IAAI,CAACsL,iBAAiB,CAACD,KAAK,EAAEpL,GAAG,CAAC;IAClC,OAAOoL,KAAK;EAChB,CAAC;EAEDmC,mBAAmB,EAAE,YAAW;IAC5B,MAAMzJ,UAAU,GAAG,IAAI,CAAC/B,QAAQ,CAAC+B,UAAU;IAC3C,MAAM0J,eAAe,GAAG/E,MAAM,CAACC,IAAI,CAAC5E,UAAU,CAAC,CAAC,CAAC;IACjD,IAAI4H,CAAC,GAAG8B,eAAe,CAAC1D,MAAM;IAC9B,OAAO4B,CAAC,GAAG,CAAC,IAAIA,CAAC,EAAE,EAAE;MACjB;MACA,KAAK,IAAI+B,IAAI,IAAI3J,UAAU,CAAC0J,eAAe,CAAC9B,CAAC,CAAC,CAAC,EAAE,OAAO,IAAI;IAChE;IACA,OAAO,KAAK;EAChB,CAAC;EAED/H,gBAAgB,EAAE,UAAS3D,GAAG,EAAEoG,IAAI,EAAE;IAClCpG,GAAG,KAAKA,GAAG,GAAG,CAAC,CAAC,CAAC;IACjBoG,IAAI,KAAKA,IAAI,GAAG;MAAEsH,SAAS,EAAE,CAAC;MAAE3N,QAAQ,EAAEnF;IAAa,CAAC,CAAC;IACzD,MAAM;MAAEmH,QAAQ,EAAEwJ,OAAO;MAAErQ;IAAQ,CAAC,GAAG,IAAI;IAC3C,MAAM2I,EAAE,GAAG0H,OAAO,CAAC1H,EAAE;IACrB,IAAIA,EAAE,EAAE;MACJxM,WAAW,CAACwM,EAAE,CAAC;MACf,IAAIuC,IAAI,CAACsH,SAAS,KAAK,CAAC,IAAI,IAAI,CAACH,mBAAmB,EAAE,EAAE;QACpD,IAAI,CAACrB,kBAAkB,CAAClM,GAAG,CAAC;MAChC;MACA,MAAMoL,KAAK,GAAG,IAAI,CAAC+B,gBAAgB,CAACnN,GAAG,CAAC;MACxC,MAAM8M,UAAU,GAAGxV,QAAQ,CAAC,CAAC,CAAC,EAAE0I,GAAG,EAAE;QACjC2N,cAAc,EAAElT,gBAAgB,GAAG2Q,KAAK,CAAClH,OAAO;QAChD0J,gBAAgB,EAAEnT,gBAAgB,GAAG2Q,KAAK,CAACnH;MAC/C,CAAC,CAAC;MACF,MAAM4J,UAAU,GAAG,IAAI,CAACd,aAAa,CAACD,UAAU,CAAC;MACjD,MAAMgB,YAAY,GAAGD,UAAU,CAAC5J,SAAS;MACzC,MAAM8J,UAAU,GAAGF,UAAU,CAAC3J,OAAO;MACrC,IAAIwJ,SAAS,GAAGtH,IAAI,CAACsH,SAAS;MAC9B,MAAMM,KAAK,GAAGzC,OAAO,CAACpH,KAAK;MAC3B,IAAIiH,KAAK,CAACiB,OAAO,GAAG,CAAC,EAAE;QACnB;QACAqB,SAAS,IAAItC,KAAK,CAACiB,OAAO,GAAGjB,KAAK,CAACnH,SAAS;QAC5CmH,KAAK,CAACsC,SAAS,GAAGA,SAAS;QAC3BtH,IAAI,CAACrG,QAAQ,GAAGsK,IAAI,CAAC+C,GAAG,CAAChC,KAAK,CAACrL,QAAQ,EAAEqG,IAAI,CAACrG,QAAQ,CAAC;QACvD,IAAIqL,KAAK,CAACiC,KAAK,IAAIU,UAAU,KAAK,CAAC,EAAE;UACjC3C,KAAK,CAACnH,SAAS,IAAI6J,YAAY;UAC/B1C,KAAK,CAAClH,OAAO,IAAI6J,UAAU;UAC3B3C,KAAK,CAACrL,QAAQ,GAAGqG,IAAI,CAACrG,QAAQ;UAC9B,IAAI,CAACsL,iBAAiB,CAACD,KAAK,EAAEpL,GAAG,CAAC;UAClCoG,IAAI,CAACsH,SAAS,GAAG,CAAC;UAClBtH,IAAI,CAACrG,QAAQ,GAAGnF,YAAY;UAC5B2Q,OAAO,CAACpH,KAAK,GAAG,CAAC;QACrB,CAAC,MAAM;UACHiC,IAAI,CAACsH,SAAS,GAAGA,SAAS;QAC9B;MACJ,CAAC,MAAM;QACH,IAAI,CAACnC,OAAO,CAAC/G,IAAI,EAAE;UACf,IAAItJ,OAAO,CAAC0E,UAAU,EAAE;YACpB,IAAI,CAAC6F,MAAM,EAAE;YACb8F,OAAO,CAAC/G,IAAI,GAAG,IAAI;YACnB,IAAI,CAACyJ,OAAO,CAAC,aAAa,EAAEjO,GAAG,CAAC;UACpC;QACJ;MACJ;MACA;MACA,MAAMkO,UAAU,GAAGlO,GAAG,CAACmO,QAAQ;MAC/B,IAAIH,KAAK,IAAI,OAAOE,UAAU,KAAK,UAAU,EAAE;QAC3CA,UAAU,CAACpC,IAAI,CAAC,IAAI,EAAEV,KAAK,CAACiC,KAAK,EAAEK,SAAS,EAAEM,KAAK,EAAE5C,KAAK,EAAE,IAAI,CAAC;MACrE;MACA;MACA,IAAIG,OAAO,CAAC1H,EAAE,KAAKA,EAAE,EAAE;IAC3B;IACA,IAAI0H,OAAO,CAAChH,QAAQ,EAAE;MAClB,MAAM,IAAI+C,KAAK,CAAC,4DAA4D,CAAC;IACjF;IACAiE,OAAO,CAAC1H,EAAE,GAAG1M,SAAS,CAAC,IAAI,CAACwM,gBAAgB,EAAE,IAAI,EAAE3D,GAAG,EAAEoG,IAAI,CAAC;EAClE,CAAC;EAED8F,kBAAkB,EAAE,UAASlM,GAAG,GAAG,CAAC,CAAC,EAAE;IACnC,IAAIoO,QAAQ,GAAGpO,GAAG,CAACS,YAAY;IAC/B,IAAI,OAAO2N,QAAQ,KAAK,UAAU,EAAE;MAChCA,QAAQ,GAAG,IAAI,CAAClT,OAAO,CAACuF,YAAY;MACpC,IAAI,OAAO2N,QAAQ,KAAK,UAAU,EAAE;IACxC;IACAA,QAAQ,CAACtC,IAAI,CAAC,IAAI,EAAE9L,GAAG,EAAE,IAAI,CAAC;EAClC,CAAC;EAEDqL,iBAAiB,EAAE,UAASD,KAAK,EAAEpL,GAAG,GAAG,CAAC,CAAC,EAAE;IACzC,IAAIqO,OAAO,GAAGrO,GAAG,CAACU,WAAW;IAC7B,IAAI,OAAO2N,OAAO,KAAK,UAAU,EAAE;MAC/BA,OAAO,GAAG,IAAI,CAACnT,OAAO,CAACwF,WAAW;IACtC;IACA,IAAI,OAAO2N,OAAO,KAAK,UAAU,EAAE;MAC/BA,OAAO,CAACvC,IAAI,CAAC,IAAI,EAAEV,KAAK,EAAEpL,GAAG,EAAE,IAAI,CAAC;IACxC;IACA,IAAI,CAACiO,OAAO,CAAC,aAAa,EAAE7C,KAAK,EAAEpL,GAAG,CAAC;EAC3C,CAAC;EAEDmN,gBAAgB,EAAE,UAASnN,GAAG,EAAE;IAC5BA,GAAG,KAAKA,GAAG,GAAG,CAAC,CAAC,CAAC;IACjB,IAAIsO,SAAS,GAAGtO,GAAG,CAACsO,SAAS,IAAI5T,iBAAiB;IAClD,IAAI6Q,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC3B,IAAIkL,WAAW,GAAG,CAAC;IACnB,IAAIsB,aAAa,GAAG,CAAC;IACrB,IAAIT,YAAY,GAAG,CAAC;IACpB,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAIS,WAAW,GAAG5T,YAAY;IAC9B,IAAIyS,KAAK,GAAG,IAAI;IAChB,IAAInS,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,IAAI4I,UAAU,GAAGyH,OAAO,CAACzH,UAAU;IACnC,IAAI2K,UAAU,GAAG,UAAU,IAAIzO,GAAG,GAAGA,GAAG,CAACW,QAAQ,GAAGzF,OAAO,CAACyF,QAAQ;IACpE,IAAI,OAAO8N,UAAU,KAAK,UAAU,EAAEA,UAAU,GAAG,IAAI;IACvD,IAAIC,cAAc,GAAGxT,OAAO,CAACqF,eAAe;IAC5C,IAAI,OAAOmO,cAAc,KAAK,UAAU,EAAEA,cAAc,GAAG,IAAI;IAC/D,IAAIlB,eAAe,GAAG/E,MAAM,CAACC,IAAI,CAAC5E,UAAU,CAAC,CAAC,CAAC;IAC/C6K,IAAI,EAAE,KAAK,IAAIjD,CAAC,GAAG,CAAC,EAAE7B,CAAC,GAAG2D,eAAe,CAAC1D,MAAM,EAAE4B,CAAC,GAAG7B,CAAC,EAAE6B,CAAC,EAAE,EAAE;MAC1D,IAAI3L,QAAQ,GAAG,CAACyN,eAAe,CAAC9B,CAAC,CAAC;MAClC,IAAID,eAAe,GAAG3H,UAAU,CAAC/D,QAAQ,CAAC;MAC1C,KAAK,IAAIyL,GAAG,IAAIC,eAAe,EAAE;QAC7B,IAAIwB,WAAW,IAAIqB,SAAS,EAAE;UAC1BjB,KAAK,GAAG,KAAK;UACb,MAAMsB,IAAI;QACd;QACA,IAAIzR,IAAI,GAAG9D,KAAK,CAACoS,GAAG,CAAC;QACrB,IAAI,CAACtO,IAAI,EAAE;UACP;UACA,OAAOuO,eAAe,CAACD,GAAG,CAAC;UAC3B;QACJ;QACA,IAAIoD,WAAW,GAAGnD,eAAe,CAACD,GAAG,CAAC;QACtC,IAAI,CAACoD,WAAW,GAAG1R,IAAI,CAACiD,WAAW,MAAM,CAAC,EAAE;UACxC;UACA,IAAI0O,UAAU,IAAGrD,GAAG,IAAID,OAAO,CAACtH,SAAS;UACzC,IAAI/G,IAAI,CAAC4R,UAAU,IAAIL,UAAU,IAAI,CAACA,UAAU,CAAC3C,IAAI,CAAC,IAAI,EAAE5O,IAAI,EAAE,CAAC2R,UAAU,EAAE,IAAI,CAAC,EAAE;YAClF;YACA,IAAI,CAACA,UAAU,EAAE;cACb,IAAI,CAACjC,qBAAqB,CAAC1P,IAAI,CAAC;cAChC,IAAI,CAAC6R,UAAU,CAAC7R,IAAI,CAAC;YACzB;YACAqO,OAAO,CAACtH,SAAS,CAACuH,GAAG,CAAC,IAAIoD,WAAW;YACrC,OAAOnD,eAAe,CAACD,GAAG,CAAC;YAC3BsC,YAAY,EAAE;YACd;UACJ;UACA;UACA,IAAIe,UAAU,EAAE;YACZD,WAAW,IAAI1R,IAAI,CAACgD,WAAW;YAC/B6N,UAAU,EAAE;UAChB;UACAa,WAAW,IAAI,IAAI,CAAC5C,mBAAmB,CAAC9O,IAAI,CAAC;QACjD;QACA,IAAI8R,YAAY,GAAG,IAAI,CAAC5C,UAAU,CAAClP,IAAI,EAAE0R,WAAW,EAAE5O,GAAG,CAAC;QAC1D,IAAIgP,YAAY,GAAG,CAAC,EAAE;UAClB;UACAvD,eAAe,CAACD,GAAG,CAAC,GAAGwD,YAAY;UACnC,IAAI,CAACN,cAAc,IAAI,CAACA,cAAc,CAAC5C,IAAI,CAAC,IAAI,EAAE5O,IAAI,EAAE8R,YAAY,EAAE,IAAI,CAAC,IAAIvD,eAAe,CAACD,GAAG,CAAC,EAAE;YACjG+C,aAAa,EAAE;YACflB,KAAK,GAAG,KAAK;YACb;UACJ;QACJ;QACA,IAAImB,WAAW,GAAGzO,QAAQ,EAAEyO,WAAW,GAAGzO,QAAQ;QAClDkN,WAAW,EAAE;QACb,OAAOxB,eAAe,CAACD,GAAG,CAAC;MAC/B;IACJ;IACA,OAAO;MACHzL,QAAQ,EAAEyO,WAAW;MACrBnC,OAAO,EAAEY,WAAW;MACpBgC,SAAS,EAAEV,aAAa;MACxBtK,SAAS,EAAE6J,YAAY;MACvB5J,OAAO,EAAE6J,UAAU;MACnBV,KAAK,EAAEA;IACX,CAAC;EACL,CAAC;EAED6B,iBAAiB,EAAE,YAAW;IAC1B,MAAM3D,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC7B,MAAMgC,aAAa,GAAG0E,MAAM,CAACC,IAAI,CAAC6C,OAAO,CAACtH,SAAS,CAAC;IACpD,MAAM4F,CAAC,GAAG9F,aAAa,CAAC+F,MAAM;IAC9B,MAAMqF,cAAc,GAAG,IAAIC,KAAK,CAACvF,CAAC,CAAC;IACnC,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,CAAC,EAAE6B,CAAC,EAAE,EAAE;MACxByD,cAAc,CAACzD,CAAC,CAAC,GAAGtS,KAAK,CAAC2K,aAAa,CAAC2H,CAAC,CAAC,CAAC;IAC/C;IACA,OAAOyD,cAAc;EACzB,CAAC;EAEDE,eAAe,EAAE,YAAW;IACxB,MAAM9D,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC7B,MAAMiC,WAAW,GAAGyE,MAAM,CAACC,IAAI,CAAC6C,OAAO,CAACrH,OAAO,CAAC;IAChD,MAAM2F,CAAC,GAAG7F,WAAW,CAAC8F,MAAM;IAC5B,MAAMwF,YAAY,GAAG,IAAIF,KAAK,CAACvF,CAAC,CAAC;IACjC,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,CAAC,EAAE6B,CAAC,EAAE,EAAE;MACxB4D,YAAY,CAAC5D,CAAC,CAAC,GAAGtS,KAAK,CAAC4K,WAAW,CAAC0H,CAAC,CAAC,CAAC;IAC3C;IACA,OAAO4D,YAAY;EACvB,CAAC;EAEDC,mBAAmB,EAAE,UAASd,UAAU,EAAEzO,GAAG,EAAE;IAC3CA,GAAG,KAAKA,GAAG,GAAI,CAAC,CAAC,CAAC;IAClB,IAAI+N,UAAU,GAAG,CAAC;IAClB,IAAI,OAAOU,UAAU,KAAK,UAAU,EAAEA,UAAU,GAAG,IAAI;IACvD,IAAIH,SAAS,GAAG,gBAAgB,IAAItO,GAAG,GAAGA,GAAG,CAAC2N,cAAc,GAAGhT,QAAQ;IACvE,IAAI4Q,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC3B,IAAIgC,aAAa,GAAGwH,OAAO,CAACxH,aAAa;IACzC,IAAIE,SAAS,GAAGsH,OAAO,CAACtH,SAAS;IACjC,KAAK,IAAIyH,CAAC,GAAG,CAAC,EAAE7B,CAAC,GAAGQ,IAAI,CAAC+C,GAAG,CAACrJ,aAAa,CAAC+F,MAAM,EAAEwE,SAAS,CAAC,EAAE5C,CAAC,GAAG7B,CAAC,EAAE6B,CAAC,EAAE,EAAE;MACvE,IAAIF,GAAG,GAAGzH,aAAa,CAAC2H,CAAC,CAAC;MAC1B,IAAI,EAAEF,GAAG,IAAIvH,SAAS,CAAC,EAAE;MACzB,IAAI/G,IAAI,GAAG9D,KAAK,CAACoS,GAAG,CAAC;MACrB,IAAI,CAACtO,IAAI,EAAE;MACX,IAAIA,IAAI,CAAC4R,UAAU,IAAIL,UAAU,IAAI,CAACA,UAAU,CAAC3C,IAAI,CAAC,IAAI,EAAE5O,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE;QAC5E;QACA6G,aAAa,CAACmG,IAAI,CAACsB,GAAG,CAAC;QACvB;MACJ;MACAuC,UAAU,EAAE;MACZ,IAAIjO,IAAI,GAAG,IAAI,CAACkM,mBAAmB,CAAC9O,IAAI,CAAC;MACzC,IAAI4C,IAAI,EAAE,IAAI,CAACyK,kBAAkB,CAACrN,IAAI,EAAE4C,IAAI,EAAE5C,IAAI,CAAC4I,eAAe,EAAE;QAAE1F,QAAQ,EAAE;MAAK,CAAC,CAAC;IAC3F;IACA;IACA2D,aAAa,CAACyL,MAAM,CAAC,CAAC,EAAE9D,CAAC,CAAC;IAC1B,OAAOqC,UAAU;EACrB,CAAC;EAED0B,iBAAiB,EAAE,UAAShB,UAAU,EAAEzO,GAAG,EAAE;IACzCA,GAAG,KAAKA,GAAG,GAAG,CAAC,CAAC,CAAC;IACjB,IAAI8N,YAAY,GAAG,CAAC;IACpB,IAAI,OAAOW,UAAU,KAAK,UAAU,EAAE,OAAOX,YAAY;IACzD,IAAIQ,SAAS,GAAG,kBAAkB,IAAItO,GAAG,GAAGA,GAAG,CAAC4N,gBAAgB,GAAGjT,QAAQ;IAC3E,IAAI4Q,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC3B,IAAIiC,WAAW,GAAGuH,OAAO,CAACvH,WAAW;IACrC,IAAIE,OAAO,GAAGqH,OAAO,CAACrH,OAAO;IAC7B,KAAK,IAAIwH,CAAC,GAAG,CAAC,EAAE7B,CAAC,GAAGQ,IAAI,CAAC+C,GAAG,CAACpJ,WAAW,CAAC8F,MAAM,EAAEwE,SAAS,CAAC,EAAE5C,CAAC,GAAG7B,CAAC,EAAE6B,CAAC,EAAE,EAAE;MACrE,IAAIF,GAAG,GAAGxH,WAAW,CAAC0H,CAAC,CAAC;MACxB,IAAI,EAAEF,GAAG,IAAItH,OAAO,CAAC,EAAE;MACvB,IAAIhH,IAAI,GAAG9D,KAAK,CAACoS,GAAG,CAAC;MACrB,IAAI,CAACtO,IAAI,EAAE;MACX,IAAI,CAACA,IAAI,CAAC4R,UAAU,IAAIL,UAAU,CAAC3C,IAAI,CAAC,IAAI,EAAE5O,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE;QAC7D;QACA8G,WAAW,CAACkG,IAAI,CAACsB,GAAG,CAAC;QACrB;MACJ;MACAsC,YAAY,EAAE;MACd,IAAIhO,IAAI,GAAG,IAAI,CAAC8M,qBAAqB,CAAC1P,IAAI,CAAC;MAC3C,IAAI4C,IAAI,EAAE,IAAI,CAACiP,UAAU,CAAC7R,IAAI,CAAC;IACnC;IACA;IACA8G,WAAW,CAACwL,MAAM,CAAC,CAAC,EAAE9D,CAAC,CAAC;IACxB,OAAOoC,YAAY;EACvB,CAAC;EAED4B,mBAAmB,EAAE,UAASC,QAAQ,EAAE3P,GAAG,GAAG,CAAC,CAAC,EAAE;IAC9C,IAAIyO,UAAU,GAAG,UAAU,IAAIzO,GAAG,GAAGA,GAAG,CAACW,QAAQ,GAAG,IAAI,CAACzF,OAAO,CAACyF,QAAQ;IACzE,IAAI,OAAO8N,UAAU,KAAK,UAAU,EAAEA,UAAU,GAAG,IAAI;IACvD,MAAMlD,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC7B,MAAM;MAAEmC,OAAO;MAAED;IAAU,CAAC,GAAGsH,OAAO;IACtC,MAAMqE,OAAO,GAAG,CAACD,QAAQ,CAACb,UAAU,IAAI,CAACL,UAAU,IAAIA,UAAU,CAAC3C,IAAI,CAAC,IAAI,EAAE6D,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAC;IAEnG,IAAIE,WAAW,GAAG,KAAK;IACvB,IAAIC,SAAS,GAAG,KAAK;IAErB,IAAIH,QAAQ,CAACnE,GAAG,IAAItH,OAAO,IAAI,CAAC0L,OAAO,EAAE;MACrC,MAAM9P,IAAI,GAAG,IAAI,CAAC8M,qBAAqB,CAAC+C,QAAQ,CAAC;MACjD,IAAI7P,IAAI,EAAE,IAAI,CAACiP,UAAU,CAACY,QAAQ,CAAC;MACnC,MAAMjE,CAAC,GAAGH,OAAO,CAACvH,WAAW,CAAC+L,OAAO,CAACJ,QAAQ,CAACnE,GAAG,CAAC;MACnDD,OAAO,CAACvH,WAAW,CAACwL,MAAM,CAAC9D,CAAC,EAAE,CAAC,CAAC;MAChCmE,WAAW,GAAG,IAAI;IACtB;IAEA,IAAI,CAACA,WAAW,IAAIF,QAAQ,CAACnE,GAAG,IAAIvH,SAAS,IAAI2L,OAAO,EAAE;MACtD,MAAMlE,CAAC,GAAGH,OAAO,CAACxH,aAAa,CAACgM,OAAO,CAACJ,QAAQ,CAACnE,GAAG,CAAC;MACrDD,OAAO,CAACxH,aAAa,CAACyL,MAAM,CAAC9D,CAAC,EAAE,CAAC,CAAC;MAClC,IAAI5L,IAAI,GAAG,IAAI,CAACkM,mBAAmB,CAAC2D,QAAQ,CAAC;MAC7C,IAAI7P,IAAI,EAAE,IAAI,CAACyK,kBAAkB,CAACoF,QAAQ,EAAE7P,IAAI,EAAE6P,QAAQ,CAAC7J,eAAe,EAAE;QAAE1F,QAAQ,EAAE;MAAK,CAAC,CAAC;MAC/F0P,SAAS,GAAG,IAAI;IACpB;IAEA,OAAO;MACH5L,OAAO,EAAE4L,SAAS,GAAG,CAAC,GAAG,CAAC;MAC1B7L,SAAS,EAAE4L,WAAW,GAAG,CAAC,GAAG;IACjC,CAAC;EACL,CAAC;EAED9C,aAAa,EAAE,UAAS/M,GAAG,EAAE;IACzB,IAAI8M,UAAU,GAAGxV,QAAQ,CAAC,CAAC,CAAC,EAAE0I,GAAG,EAAE;MAC/B2N,cAAc,EAAEhT,QAAQ;MACxBiT,gBAAgB,EAAEjT;IACtB,CAAC,CAAC;IACF,IAAI8T,UAAU,GAAG,UAAU,IAAI3B,UAAU,GAAGA,UAAU,CAACnM,QAAQ,GAAG,IAAI,CAACzF,OAAO,CAACyF,QAAQ;IACvF,IAAIqP,cAAc,GAAG,IAAI,CAACP,iBAAiB,CAAChB,UAAU,EAAE3B,UAAU,CAAC;IACnE,IAAIkD,cAAc,GAAG,CAAC,EAAE;MACpB;MACA,IAAIjM,aAAa,GAAG,IAAI,CAAChC,QAAQ,CAACgC,aAAa;MAC/C+I,UAAU,CAACa,cAAc,GAAGtD,IAAI,CAAC+C,GAAG,CAACrJ,aAAa,CAAC+F,MAAM,GAAGkG,cAAc,EAAElD,UAAU,CAACa,cAAc,CAAC;IAC1G;IACA,IAAIsC,YAAY,GAAG,IAAI,CAACV,mBAAmB,CAACd,UAAU,EAAE3B,UAAU,CAAC;IACnE,OAAO;MACH5I,OAAO,EAAE+L,YAAY;MACrBhM,SAAS,EAAE+L;IACf,CAAC;EACL,CAAC;EAEDvK,MAAM,EAAE,UAASzF,GAAG,EAAE;IAClBA,GAAG,KAAKA,GAAG,GAAG,CAAC,CAAC,CAAC;IACjB,IAAIuL,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC3B,IAAI2D,GAAG,GAAG1F,GAAG,CAAC0F,GAAG;IACjB,IAAIjC,QAAQ,GAAG,IAAI,CAACvI,OAAO,CAACyE,MAAM;IAClC,IAAI0E,SAAS,GAAGkH,OAAO,CAAClH,SAAS;IACjC,IAAIqB,GAAG,IAAIA,GAAG,KAAKrB,SAAS,EAAG;MAC3B;MACA,IAAIZ,QAAQ,IAAIY,SAAS,EAAE;MAC3BkH,OAAO,CAAClH,SAAS,GAAGqB,GAAG;MACvB6F,OAAO,CAACnH,SAAS,GAAGX,QAAQ;IAChC;IACA,IAAI,CAACvI,OAAO,CAACyE,MAAM,GAAG,IAAI;IAC1B,IAAIkE,EAAE,GAAG0H,OAAO,CAAC1H,EAAE;IACnB0H,OAAO,CAAC1H,EAAE,GAAG,IAAI;IACjB,IAAI,IAAI,CAACH,OAAO,EAAE,IAAIG,EAAE,EAAExM,WAAW,CAACwM,EAAE,CAAC;EAC7C,CAAC;EAED8B,QAAQ,EAAE,UAAS3F,GAAG,EAAE;IACpBA,GAAG,KAAKA,GAAG,GAAG,CAAC,CAAC,CAAC;IACjB,IAAIuL,OAAO,GAAG,IAAI,CAACxJ,QAAQ;IAC3B,IAAI2D,GAAG,GAAG1F,GAAG,CAAC0F,GAAG;IACjB,IAAIrB,SAAS,GAAGkH,OAAO,CAAClH,SAAS;IACjC;IACA,IAAIqB,GAAG,IAAIrB,SAAS,IAAIqB,GAAG,KAAKrB,SAAS,EAAE;IAC3CkH,OAAO,CAAClH,SAAS,GAAG,IAAI;IACxB;IACA,IAAIqB,GAAG,IAAIA,GAAG,KAAKrB,SAAS,IAAIkH,OAAO,CAACnH,SAAS,EAAE;IACnD,IAAI,IAAI,CAACV,OAAO,EAAE,EAAE;MAChB,IAAI,CAAC+B,MAAM,EAAE;MACb,IAAI,CAAC9B,gBAAgB,CAAC3D,GAAG,CAAC;IAC9B,CAAC,MAAM;MACH,IAAI,CAACyG,WAAW,CAACzG,GAAG,CAAC;IACzB;IACA,IAAI,CAAC9E,OAAO,CAACyE,MAAM,GAAG4L,OAAO,CAACnH,SAAS,GAAG,KAAK;IAC/C,IAAImH,OAAO,CAACjH,IAAI,EAAE;MACd,IAAI,CAAC6B,SAAS,EAAE;MAChBoF,OAAO,CAACjH,IAAI,GAAG,KAAK;IACxB;EACJ,CAAC;EAEDZ,OAAO,EAAE,YAAW;IAChB,OAAO,CAAC,CAAC,IAAI,CAACxI,OAAO,CAACiQ,KAAK;EAC/B,CAAC;EAED1H,QAAQ,EAAE,YAAW;IACjB,OAAO,CAAC,CAAC,IAAI,CAACvI,OAAO,CAACyE,MAAM;EAChC,CAAC;EAEDuQ,cAAc,EAAE,YAAW;IACvB,OAAO,IAAI,CAAChV,OAAO,CAACwE,OAAO,KAAKvF,YAAY,CAACG,KAAK;EACtD,CAAC;EAED6V,QAAQ,EAAE,YAAW;IAEjB,IAAI,CAAC1K,MAAM,EAAE;IACb,IAAI,CAAC1D,QAAQ,CAACwC,QAAQ,GAAG,IAAI;IAC7B;IACA,IAAI,CAACwD,YAAY,EAAE;IACnB,IAAI,CAACqI,WAAW,EAAE;EACtB,CAAC;EAEDC,eAAe,EAAE,YAAW;IAExB,IAAInV,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,IAAIoV,CAAC,GAAGpV,OAAO,CAACa,KAAK;IACrB,IAAIwU,CAAC,GAAGrV,OAAO,CAACc,MAAM;IACtB,IAAI,CAAC/E,QAAQ,CAACqZ,CAAC,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC/N,EAAE,CAACiO,WAAW;IACzC,IAAI,CAACvZ,QAAQ,CAACsZ,CAAC,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAChO,EAAE,CAACkO,YAAY;IAC1C,OAAO;MAAE1U,KAAK,EAAEuU,CAAC;MAAEtU,MAAM,EAAEuU;IAAE,CAAC;EAClC,CAAC;EAEDG,aAAa,EAAE,UAAS3U,KAAK,EAAEC,MAAM,EAAE;IACnC,MAAM;MAAEd;IAAQ,CAAC,GAAG,IAAI;IACxB,MAAM;MAAEa,KAAK,EAAE4U,YAAY;MAAE3U,MAAM,EAAE4U;IAAc,CAAC,GAAG1V,OAAO;IAC9D,IAAIoV,CAAC,GAAIvU,KAAK,KAAKkN,SAAS,GAAI0H,YAAY,GAAG5U,KAAK;IACpD,IAAIwU,CAAC,GAAIvU,MAAM,KAAKiN,SAAS,GAAI2H,aAAa,GAAG5U,MAAM;IACvD,IAAI2U,YAAY,KAAKL,CAAC,IAAIM,aAAa,KAAKL,CAAC,EAAE;IAC/CrV,OAAO,CAACa,KAAK,GAAGuU,CAAC;IACjBpV,OAAO,CAACc,MAAM,GAAGuU,CAAC;IAClB,IAAI,CAACzN,cAAc,EAAE;IACrB,MAAM+N,YAAY,GAAG,IAAI,CAACR,eAAe,EAAE;IAC3C,IAAI,CAACpC,OAAO,CAAC,QAAQ,EAAE4C,YAAY,CAAC9U,KAAK,EAAE8U,YAAY,CAAC7U,MAAM,CAAC;EACnE,CAAC;EAED8G,cAAc,EAAE,YAAW;IACvB,MAAM;MAAE5H;IAAQ,CAAC,GAAG,IAAI;IACxB,IAAIoV,CAAC,GAAGpV,OAAO,CAACa,KAAK;IACrB,IAAIwU,CAAC,GAAGrV,OAAO,CAACc,MAAM;IACtB,IAAI/E,QAAQ,CAACqZ,CAAC,CAAC,EAAEA,CAAC,GAAGjG,IAAI,CAACyG,KAAK,CAACR,CAAC,CAAC;IAClC,IAAIrZ,QAAQ,CAACsZ,CAAC,CAAC,EAAEA,CAAC,GAAGlG,IAAI,CAACyG,KAAK,CAACP,CAAC,CAAC;IAClC,IAAI,CAACQ,GAAG,CAACC,GAAG,CAAC;MACTjV,KAAK,EAAGuU,CAAC,KAAK,IAAI,GAAI,EAAE,GAAGA,CAAC;MAC5BtU,MAAM,EAAGuU,CAAC,KAAK,IAAI,GAAI,EAAE,GAAGA;IAChC,CAAC,CAAC;EACN,CAAC;EAEDU,SAAS,EAAE,UAASC,EAAE,EAAEC,EAAE,EAAE;IACxB,OAAO,IAAI,CAACC,SAAS,CAACF,EAAE,IAAI,CAAC,EAAEC,EAAE,IAAI,CAAC,CAAC;EAC3C,CAAC;EAED;EACA;EACAE,YAAY,EAAE,UAASC,SAAS,EAAEC,UAAU,EAAEpW,OAAO,EAAE6E,GAAG,EAAE;IAExD,IAAI5I,QAAQ,CAACka,SAAS,CAAC,EAAE;MACrB;MACAtR,GAAG,GAAGsR,SAAS;IACnB,CAAC,MAAM;MACH;MACAtR,GAAG,GAAG9I,MAAM,CAAC;QAAEoa,SAAS;QAAEC,UAAU;QAAEpW;MAAQ,CAAC,EAAE6E,GAAG,CAAC;IACzD;IAEA,MAAM;MAAE9D,CAAC;MAAEC,CAAC;MAAEJ,KAAK;MAAEC;IAAO,CAAC,GAAG,IAAI,CAACwV,mBAAmB,CAACxR,GAAG,CAAC;IAC7D,MAAM;MAAEyR,EAAE;MAAEC;IAAG,CAAC,GAAG,IAAI,CAACC,KAAK,EAAE;IAE/B,IAAI,CAACV,SAAS,CAAC,CAAC/U,CAAC,GAAGuV,EAAE,EAAE,CAACtV,CAAC,GAAGuV,EAAE,CAAC;IAChC,IAAI,CAAChB,aAAa,CAAC3U,KAAK,GAAG0V,EAAE,EAAEzV,MAAM,GAAG0V,EAAE,CAAC;IAE3C,OAAO,IAAI1Y,IAAI,CAACkD,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,CAAC;EACxC,CAAC;EAEDwV,mBAAmB,EAAE,UAASxR,GAAG,GAAG,CAAC,CAAC,EAAE;IAEpC;;IAEA,MAAMsR,SAAS,GAAGtR,GAAG,CAACsR,SAAS,IAAI,CAAC;IACpC,MAAMC,UAAU,GAAGvR,GAAG,CAACuR,UAAU,IAAI,CAAC;IACtC,MAAMpW,OAAO,GAAG1D,cAAc,CAACuI,GAAG,CAAC7E,OAAO,IAAI,CAAC,CAAC;IAEhD,MAAMyW,QAAQ,GAAGvH,IAAI,CAACC,GAAG,CAACtK,GAAG,CAAC4R,QAAQ,IAAI,CAAC,EAAEN,SAAS,CAAC;IACvD,MAAMO,SAAS,GAAGxH,IAAI,CAACC,GAAG,CAACtK,GAAG,CAAC6R,SAAS,IAAI,CAAC,EAAEN,UAAU,CAAC;IAC1D,MAAMO,QAAQ,GAAG9R,GAAG,CAAC8R,QAAQ,IAAIC,MAAM,CAACC,SAAS;IACjD,MAAMC,SAAS,GAAGjS,GAAG,CAACiS,SAAS,IAAIF,MAAM,CAACC,SAAS;IACnD,MAAME,SAAS,GAAGlS,GAAG,CAACmS,cAAc;IAEpC,MAAMC,IAAI,GAAI,aAAa,IAAIpS,GAAG,GAAI,IAAIhH,IAAI,CAACgH,GAAG,CAACqS,WAAW,CAAC,GAAG,IAAI,CAACC,cAAc,CAACtS,GAAG,CAAC;IAC1F,MAAM;MAAEyR,EAAE;MAAEC;IAAG,CAAC,GAAG,IAAI,CAACC,KAAK,EAAE;IAC/BS,IAAI,CAAClW,CAAC,IAAIuV,EAAE;IACZW,IAAI,CAACjW,CAAC,IAAIuV,EAAE;IACZU,IAAI,CAACrW,KAAK,IAAI0V,EAAE;IAChBW,IAAI,CAACpW,MAAM,IAAI0V,EAAE;IAEjB,IAAIa,SAAS,GAAGlI,IAAI,CAACmI,IAAI,CAAC,CAACJ,IAAI,CAACrW,KAAK,GAAGqW,IAAI,CAAClW,CAAC,IAAIoV,SAAS,CAAC;IAC5D,IAAImB,UAAU,GAAGpI,IAAI,CAACmI,IAAI,CAAC,CAACJ,IAAI,CAACpW,MAAM,GAAGoW,IAAI,CAACjW,CAAC,IAAIoV,UAAU,CAAC;IAC/D,IAAI,CAACvR,GAAG,CAAC0S,wBAAwB,EAAE;MAC/BH,SAAS,GAAGlI,IAAI,CAACC,GAAG,CAACiI,SAAS,EAAE,CAAC,CAAC;MAClCE,UAAU,GAAGpI,IAAI,CAACC,GAAG,CAACmI,UAAU,EAAE,CAAC,CAAC;IACxC;IACAF,SAAS,IAAIjB,SAAS;IACtBmB,UAAU,IAAIlB,UAAU;IAExB,IAAIoB,EAAE,GAAG,CAAC;IACV,IAAKT,SAAS,KAAK,UAAU,IAAIE,IAAI,CAAClW,CAAC,GAAG,CAAC,IAAMgW,SAAS,KAAK,UAAU,IAAIE,IAAI,CAAClW,CAAC,IAAI,CAAE,IAAIgW,SAAS,KAAK,KAAK,EAAE;MAC9GS,EAAE,GAAGtI,IAAI,CAACmI,IAAI,CAAC,CAACJ,IAAI,CAAClW,CAAC,GAAGoV,SAAS,CAAC,GAAGA,SAAS;MAC/CqB,EAAE,IAAIxX,OAAO,CAACyX,IAAI;MAClBL,SAAS,IAAII,EAAE;IACnB;IAEA,IAAIE,EAAE,GAAG,CAAC;IACV,IAAKX,SAAS,KAAK,UAAU,IAAIE,IAAI,CAACjW,CAAC,GAAG,CAAC,IAAM+V,SAAS,KAAK,UAAU,IAAIE,IAAI,CAACjW,CAAC,IAAI,CAAE,IAAI+V,SAAS,KAAK,KAAK,EAAE;MAC9GW,EAAE,GAAGxI,IAAI,CAACmI,IAAI,CAAC,CAACJ,IAAI,CAACjW,CAAC,GAAGoV,UAAU,CAAC,GAAGA,UAAU;MACjDsB,EAAE,IAAI1X,OAAO,CAAC2X,GAAG;MACjBL,UAAU,IAAII,EAAE;IACpB;IAEAN,SAAS,IAAIpX,OAAO,CAAC4X,KAAK;IAC1BN,UAAU,IAAItX,OAAO,CAAC6X,MAAM;;IAE5B;IACAT,SAAS,GAAGlI,IAAI,CAACC,GAAG,CAACiI,SAAS,EAAEX,QAAQ,CAAC;IACzCa,UAAU,GAAGpI,IAAI,CAACC,GAAG,CAACmI,UAAU,EAAEZ,SAAS,CAAC;;IAE5C;IACAU,SAAS,GAAGlI,IAAI,CAAC+C,GAAG,CAACmF,SAAS,EAAET,QAAQ,CAAC;IACzCW,UAAU,GAAGpI,IAAI,CAAC+C,GAAG,CAACqF,UAAU,EAAER,SAAS,CAAC;IAE5C,OAAO,IAAIjZ,IAAI,CAAC,CAAC2Z,EAAE,GAAGlB,EAAE,EAAE,CAACoB,EAAE,GAAGnB,EAAE,EAAEa,SAAS,GAAGd,EAAE,EAAEgB,UAAU,GAAGf,EAAE,CAAC;EACxE,CAAC;EAEDuB,qBAAqB,EAAE,UAASjT,GAAG,EAAE;IACjCA,GAAG,KAAKA,GAAG,GAAG,CAAC,CAAC,CAAC;IAEjB,IAAIkT,WAAW,EAAEC,kBAAkB;IACnC,IAAI,aAAa,IAAInT,GAAG,EAAE;MACtB,MAAMqS,WAAW,GAAGrS,GAAG,CAACqS,WAAW;MACnCa,WAAW,GAAG,IAAI,CAACE,gBAAgB,CAACf,WAAW,CAAC;MAChDc,kBAAkB,GAAG,IAAIla,KAAK,CAACoZ,WAAW,CAAC;IAC/C,CAAC,MAAM;MACHa,WAAW,GAAG,IAAI,CAACG,cAAc,CAACrT,GAAG,CAAC;MACtCmT,kBAAkB,GAAG,IAAI,CAACG,iBAAiB,CAACJ,WAAW,CAAC;IAC5D;IAEA,IAAI,CAACA,WAAW,CAACnX,KAAK,IAAI,CAACmX,WAAW,CAAClX,MAAM,EAAE;IAE/C1E,QAAQ,CAAC0I,GAAG,EAAE;MACV7E,OAAO,EAAE,CAAC;MACVoY,mBAAmB,EAAE,IAAI;MACzBC,SAAS,EAAE,IAAI;MACfC,QAAQ,EAAE,CAAC;MACXC,QAAQ,EAAE3B,MAAM,CAACC,SAAS;MAC1B2B,aAAa,EAAE,KAAK;MACpBC,eAAe,EAAE;MACjB;MACA;MACA;MACA;MACA;IACJ,CAAC,CAAC;;IAEF,MAAMzY,OAAO,GAAG1D,cAAc,CAACuI,GAAG,CAAC7E,OAAO,CAAC;IAE3C,MAAM0Y,SAAS,GAAG7T,GAAG,CAAC6T,SAAS,IAAI7T,GAAG,CAACyT,QAAQ;IAC/C,MAAMK,SAAS,GAAG9T,GAAG,CAAC8T,SAAS,IAAI9T,GAAG,CAAC0T,QAAQ;IAC/C,MAAMK,SAAS,GAAG/T,GAAG,CAAC+T,SAAS,IAAI/T,GAAG,CAACyT,QAAQ;IAC/C,MAAMO,SAAS,GAAGhU,GAAG,CAACgU,SAAS,IAAIhU,GAAG,CAAC0T,QAAQ;IAE/C,IAAIO,WAAW;IACf,IAAIjU,GAAG,CAACiU,WAAW,EAAE;MACjBA,WAAW,GAAGjU,GAAG,CAACiU,WAAW;IACjC,CAAC,MAAM;MACH,MAAMC,gBAAgB,GAAG,IAAI,CAAC9C,SAAS,EAAE;MACzC,MAAMP,YAAY,GAAG,IAAI,CAACR,eAAe,EAAE;MAC3C4D,WAAW,GAAG;QACV/X,CAAC,EAAEgY,gBAAgB,CAACvB,EAAE;QACtBxW,CAAC,EAAE+X,gBAAgB,CAACrB,EAAE;QACtB9W,KAAK,EAAE8U,YAAY,CAAC9U,KAAK;QACzBC,MAAM,EAAE6U,YAAY,CAAC7U;MACzB,CAAC;IACL;IAEAiY,WAAW,GAAG,IAAIjb,IAAI,CAACib,WAAW,CAAC,CAACE,aAAa,CAAC;MAC9CjY,CAAC,EAAEf,OAAO,CAACyX,IAAI;MACfzW,CAAC,EAAEhB,OAAO,CAAC2X,GAAG;MACd/W,KAAK,EAAE,CAACZ,OAAO,CAACyX,IAAI,GAAGzX,OAAO,CAAC4X,KAAK;MACpC/W,MAAM,EAAE,CAACb,OAAO,CAAC2X,GAAG,GAAG3X,OAAO,CAAC6X;IACnC,CAAC,CAAC;IAEF,MAAMoB,YAAY,GAAG,IAAI,CAACzC,KAAK,EAAE;IAEjC,IAAI0C,KAAK,GAAGJ,WAAW,CAAClY,KAAK,GAAGmX,WAAW,CAACnX,KAAK,GAAGqY,YAAY,CAAC3C,EAAE;IACnE,IAAI6C,KAAK,GAAGL,WAAW,CAACjY,MAAM,GAAGkX,WAAW,CAAClX,MAAM,GAAGoY,YAAY,CAAC1C,EAAE;IAErE,IAAI1R,GAAG,CAACuT,mBAAmB,EAAE;MACzBc,KAAK,GAAGC,KAAK,GAAGjK,IAAI,CAAC+C,GAAG,CAACiH,KAAK,EAAEC,KAAK,CAAC;IAC1C;;IAEA;IACA,IAAItU,GAAG,CAACwT,SAAS,EAAE;MAEf,MAAMpX,QAAQ,GAAG4D,GAAG,CAACwT,SAAS;MAE9Ba,KAAK,GAAGjY,QAAQ,GAAGiO,IAAI,CAACkK,KAAK,CAACF,KAAK,GAAGjY,QAAQ,CAAC;MAC/CkY,KAAK,GAAGlY,QAAQ,GAAGiO,IAAI,CAACkK,KAAK,CAACD,KAAK,GAAGlY,QAAQ,CAAC;IACnD;;IAEA;IACAiY,KAAK,GAAGhK,IAAI,CAAC+C,GAAG,CAAC0G,SAAS,EAAEzJ,IAAI,CAACC,GAAG,CAACuJ,SAAS,EAAEQ,KAAK,CAAC,CAAC;IACvDC,KAAK,GAAGjK,IAAI,CAAC+C,GAAG,CAAC4G,SAAS,EAAE3J,IAAI,CAACC,GAAG,CAACyJ,SAAS,EAAEO,KAAK,CAAC,CAAC;IAEvD,MAAME,SAAS,GAAG;MACdtY,CAAC,EAAEmY,KAAK,GAAGD,YAAY,CAAC3C,EAAE;MAC1BtV,CAAC,EAAEmY,KAAK,GAAGF,YAAY,CAAC1C;IAC5B,CAAC;IAED,MAAMzV,MAAM,GAAG,IAAI,CAACf,OAAO,CAACe,MAAM;IAClC,IAAIwY,KAAK,GAAGR,WAAW,CAAC/X,CAAC,GAAGiX,kBAAkB,CAACjX,CAAC,GAAGmY,KAAK,GAAGpY,MAAM,CAACC,CAAC;IACnE,IAAIwY,KAAK,GAAGT,WAAW,CAAC9X,CAAC,GAAGgX,kBAAkB,CAAChX,CAAC,GAAGmY,KAAK,GAAGrY,MAAM,CAACE,CAAC;IAEnE,QAAQ6D,GAAG,CAAC2T,aAAa;MACrB,KAAK,QAAQ;QACTe,KAAK,GAAGA,KAAK,GAAG,CAACT,WAAW,CAACjY,MAAM,GAAGkX,WAAW,CAAClX,MAAM,GAAGwY,SAAS,CAACrY,CAAC,IAAI,CAAC;QAC3E;MACJ,KAAK,QAAQ;QACTuY,KAAK,GAAGA,KAAK,IAAIT,WAAW,CAACjY,MAAM,GAAGkX,WAAW,CAAClX,MAAM,GAAGwY,SAAS,CAACrY,CAAC,CAAC;QACvE;MACJ,KAAK,KAAK;MACV;QACI;IAAM;IAGd,QAAQ6D,GAAG,CAAC4T,eAAe;MACvB,KAAK,QAAQ;QACTa,KAAK,GAAGA,KAAK,GAAG,CAACR,WAAW,CAAClY,KAAK,GAAGmX,WAAW,CAACnX,KAAK,GAAGyY,SAAS,CAACtY,CAAC,IAAI,CAAC;QACzE;MACJ,KAAK,OAAO;QACRuY,KAAK,GAAGA,KAAK,IAAIR,WAAW,CAAClY,KAAK,GAAGmX,WAAW,CAACnX,KAAK,GAAGyY,SAAS,CAACtY,CAAC,CAAC;QACrE;MACJ,KAAK,MAAM;MACX;QACI;IAAM;IAGd,IAAI,CAACyV,KAAK,CAAC0C,KAAK,EAAEC,KAAK,CAAC;IACxB,IAAI,CAAClD,SAAS,CAACqD,KAAK,EAAEC,KAAK,CAAC;EAChC,CAAC;EAEDC,iBAAiB,EAAE,UAAS3U,GAAG,EAAE;IAC7B,IAAI,CAACiT,qBAAqB,CAACjT,GAAG,CAAC;EACnC,CAAC;EAED;EACAsS,cAAc,EAAE,UAAStS,GAAG,EAAE;IAE1B,IAAIA,GAAG,IAAIA,GAAG,CAAC4U,gBAAgB,EAAE;MAC7B,OAAO,IAAI,CAAClS,KAAK,CAACmS,OAAO,EAAE,IAAI,IAAI7b,IAAI,EAAE;IAC7C;IAEA,OAAOhC,CAAC,CAAC,IAAI,CAACuM,KAAK,CAAC,CAACsR,OAAO,EAAE;EAClC,CAAC;EAED;EACAxB,cAAc,EAAE,UAASrT,GAAG,EAAE;IAE1B,OAAO,IAAI,CAACoT,gBAAgB,CAAC,IAAI,CAACd,cAAc,CAACtS,GAAG,CAAC,CAAC;EAC1D,CAAC;EAED;EACA;EACA;EACA8U,OAAO,EAAE,YAAW;IAEhB,OAAO,IAAI,CAACC,gBAAgB,CAAC,IAAI,CAAC1E,eAAe,EAAE,CAAC;EACxD,CAAC;EAED2E,iBAAiB,EAAE,UAAS,GAAGC,IAAI,EAAE;IAEjC,MAAM;MAAE1X;IAAkB,CAAC,GAAG,IAAI,CAACrC,OAAO;IAE1C,IAAIga,cAAc;IAClB,IAAIxd,UAAU,CAAC6F,iBAAiB,CAAC,EAAE;MAC/B;MACA2X,cAAc,GAAG3X,iBAAiB,CAAC4X,KAAK,CAAC,IAAI,EAAEF,IAAI,CAAC;IACxD,CAAC,MAAM,IAAI1X,iBAAiB,KAAK,IAAI,EAAE;MACnC;MACA2X,cAAc,GAAG,IAAI,CAACJ,OAAO,EAAE;IACnC,CAAC,MAAM,IAAI,CAACvX,iBAAiB,EAAE;MAC3B;MACA2X,cAAc,GAAG,IAAI;IACzB,CAAC,MAAM;MACH;MACAA,cAAc,GAAG,IAAIlc,IAAI,CAACuE,iBAAiB,CAAC;IAChD;IAEA,OAAO2X,cAAc;EACzB,CAAC;EAEDE,kBAAkB,EAAE,UAAShQ,IAAI,EAAE;IAE/B,MAAM;MAAElK;IAAQ,CAAC,GAAG,IAAI;IACxB;IACA,IAAIma,iBAAiB;;IAErB;IACA,IAAIC,gBAAgB;;IAEpB;IACA;IACA,IAAIzO,SAAS,GAAG3L,OAAO,CAAC0F,iBAAiB;IACzC,IAAI0K,IAAI,GAAGlG,IAAI,CAACmQ,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM;IACpC,IAAIC,kBAAkB,GAAG5d,SAAS,CAACiP,SAAS,EAAEyE,IAAI,EAAE,GAAG,CAAC;IAExD,IAAIlG,IAAI,CAACqQ,MAAM,EAAE,EAAE;MACfJ,iBAAiB,GAAGna,OAAO,CAACwB,QAAQ;MACpC4Y,gBAAgB,GAAG/b,QAAQ;IAC/B,CAAC,MAAM;MACH8b,iBAAiB,GAAGna,OAAO,CAACuB,WAAW;MACvC6Y,gBAAgB,GAAGhc,WAAW;IAClC;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIoc,SAAS,GAAIL,iBAAiB,CAACM,SAAS,YAAYzb,QAAQ,CAACf,IAAI,GAC/Dqc,kBAAkB,IAAIH,iBAAiB,GACvCA,iBAAiB,CAACvJ,IAAI,CAAC,IAAI,EAAE1G,IAAI,CAAC,IAAIoQ,kBAAkB,IAAIF,gBAAgB;IAElF,OAAO,IAAII,SAAS,CAAC;MACjBhT,KAAK,EAAE0C,IAAI;MACXjG,WAAW,EAAEjE,OAAO,CAACiE,WAAW;MAChCrC,WAAW,EAAE5B,OAAO,CAAC4B,WAAW,KAAK,IAAI,GAAGnD,WAAW,CAAC+B,MAAM,GAAGR,OAAO,CAAC4B;IAC7E,CAAC,CAAC;EACN,CAAC;EAEDyP,UAAU,EAAE,UAASnH,IAAI,EAAE;IAEvB,MAAM;MAAEvB;IAAG,CAAC,GAAGuB,IAAI;IACnB,MAAM;MAAEpC,MAAM;MAAEjB;IAAS,CAAC,GAAG,IAAI;IACjC,MAAM7E,IAAI,GAAG8F,MAAM,CAACa,EAAE,CAAC;IACvB,IAAI3G,IAAI,EAAE;MACN,IAAI;QAAEsO;MAAI,CAAC,GAAGtO,IAAI;MAClB,MAAM;QAAEgH,OAAO;QAAED;MAAU,CAAC,GAAGlC,QAAQ;MACvC7E,IAAI,CAACyL,MAAM,EAAE;MACb,OAAO3F,MAAM,CAACa,EAAE,CAAC;MACjB,OAAOK,OAAO,CAACsH,GAAG,CAAC;MACnB,OAAOvH,SAAS,CAACuH,GAAG,CAAC;IACzB;IACA,OAAOtO,IAAI;EACf,CAAC;EAEDqI,UAAU,EAAE,UAASH,IAAI,EAAEpF,GAAG,EAAE;IAE5B,MAAM;MAAE6D;IAAG,CAAC,GAAGuB,IAAI;IACnB,MAAMhM,KAAK,GAAG,IAAI,CAAC4J,MAAM;IACzB,IAAI9F,IAAI,EAAE4C,IAAI;IACd,IAAI8V,MAAM,GAAG,IAAI;IACjB,IAAI/R,EAAE,IAAIzK,KAAK,EAAE;MACb8D,IAAI,GAAG9D,KAAK,CAACyK,EAAE,CAAC;MAChB,IAAI3G,IAAI,CAACwF,KAAK,KAAK0C,IAAI,EAAE;QACrBtF,IAAI,GAAG5C,IAAI,CAACgD,WAAW;QACvB0V,MAAM,GAAG,KAAK;MAClB,CAAC,MAAM;QACH;QACA;QACA;QACA,IAAI,CAACrJ,UAAU,CAACnH,IAAI,CAAC;MACzB;IACJ;IACA,IAAIwQ,MAAM,EAAE;MACR1Y,IAAI,GAAG9D,KAAK,CAACyK,EAAE,CAAC,GAAG,IAAI,CAACuR,kBAAkB,CAAChQ,IAAI,CAAC;MAChDlI,IAAI,CAAC+C,KAAK,GAAG,IAAI;MACjBH,IAAI,GAAG,IAAI,CAAC8M,qBAAqB,CAAC1P,IAAI,CAAC,GAAG,IAAI,CAACoP,SAAS,GAAGpP,IAAI,CAACsN,OAAO,CAACnS,MAAM,CAAC6E,IAAI,EAAE,UAAU,CAAC,CAAC;IACrG;IACA,IAAI,CAAC2I,iBAAiB,CAAC3I,IAAI,EAAE4C,IAAI,EAAE5C,IAAI,CAAC4I,eAAe,EAAE9F,GAAG,CAAC;IAC7D,OAAO9C,IAAI;EACf,CAAC;EAED2Y,gBAAgB,EAAE,YAAW;IACzB;IACA;;IAEA,OAAO,KAAK;EAChB,CAAC;EAEDxS,UAAU,EAAE,UAASE,KAAK,EAAEvD,GAAG,EAAE;IAC7BA,GAAG,KAAKA,GAAG,GAAG,CAAC,CAAC,CAAC;IACjBuD,KAAK,KAAKA,KAAK,GAAG,EAAE,CAAC;IACrB,IAAI,CAACK,aAAa,EAAE;IACpB;IACA,IAAI,CAACwM,WAAW,EAAE;IAClB;IACA,MAAM1K,GAAG,GAAG,IAAI,CAACxK,OAAO,CAAC0E,UAAU,GAAG,IAAI,GAAG,OAAO;IACpD,IAAI,CAAC6F,MAAM,CAAC;MAAEC;IAAI,CAAC,CAAC;IACpB,KAAK,IAAIgG,CAAC,GAAG,CAAC,EAAE7B,CAAC,GAAGtG,KAAK,CAACuG,MAAM,EAAE4B,CAAC,GAAG7B,CAAC,EAAE6B,CAAC,EAAE,EAAE;MAC1C,IAAI,CAACnG,UAAU,CAAChC,KAAK,CAACmI,CAAC,CAAC,EAAE1L,GAAG,CAAC;IAClC;IACA,IAAI,CAAC2F,QAAQ,CAAC;MAAED;IAAI,CAAC,CAAC;IACtB,IAAI,CAACS,SAAS,EAAE;EACpB,CAAC;EAEDiK,WAAW,EAAE,YAAW;IAEpB3X,MAAM,CAAC,IAAI,CAACuK,MAAM,EAAE,QAAQ,CAAC;IAE7B,IAAI,CAACA,MAAM,GAAG,CAAC,CAAC;EACpB,CAAC;EAEDmD,SAAS,EAAE,YAAW;IAElB,IAAI,CAAC,IAAI,CAAC+J,cAAc,EAAE,EAAE;MACxB;MACA;IACJ;IACA,IAAI,IAAI,CAACzM,QAAQ,EAAE,EAAE;MACjB;MACA,IAAI,CAAC1B,QAAQ,CAACuC,IAAI,GAAG,IAAI;MACzB;IACJ;IACA,IAAI,CAACwR,cAAc,EAAE;EACzB,CAAC;EAEDA,cAAc,EAAE,YAAW;IAEvB;IACA;;IAEA,IAAIC,MAAM,GAAG9b,CAAC,CAAC,IAAI,CAACsJ,KAAK,CAAC,CAACoD,QAAQ,CAAC,YAAY,CAAC;IACjD,IAAIpD,KAAK,GAAG,IAAI,CAACb,KAAK,CAAC6S,GAAG,CAAC,OAAO,CAAC;IAEnC1d,YAAY,CAACke,MAAM,EAAE,UAASC,CAAC,EAAEC,CAAC,EAAE;MAChC,IAAIC,KAAK,GAAG3S,KAAK,CAACgS,GAAG,CAACS,CAAC,CAAC5X,YAAY,CAAC,UAAU,CAAC,CAAC;MACjD,IAAI+X,KAAK,GAAG5S,KAAK,CAACgS,GAAG,CAACU,CAAC,CAAC7X,YAAY,CAAC,UAAU,CAAC,CAAC;MACjD,IAAIgY,EAAE,GAAGF,KAAK,CAAC5S,UAAU,CAAC+S,CAAC,IAAI,CAAC;MAChC,IAAIC,EAAE,GAAGH,KAAK,CAAC7S,UAAU,CAAC+S,CAAC,IAAI,CAAC;MAChC,OAAQD,EAAE,KAAKE,EAAE,GAAI,CAAC,GAAIF,EAAE,GAAGE,EAAE,GAAI,CAAC,CAAC,GAAG,CAAC;IAC/C,CAAC,CAAC;EACN,CAAC;EAED7J,UAAU,EAAE,UAASvP,IAAI,EAAEsP,eAAe,EAAE;IACxC,MAAMtE,SAAS,GAAG,IAAI,CAACb,YAAY,CAAC1N,WAAW,CAAC8B,KAAK,CAAC;IACtD,MAAM;MAAE8G,EAAE;MAAEG;IAAM,CAAC,GAAGxF,IAAI;IAC1B,QAAQ,IAAI,CAAChC,OAAO,CAACwE,OAAO;MACxB,KAAKvF,YAAY,CAACE,MAAM;QACpB6N,SAAS,CAACqO,gBAAgB,CAAChU,EAAE,EAAEG,KAAK,CAAC6S,GAAG,CAAC,GAAG,CAAC,CAAC;QAC9C;MACJ,KAAKpb,YAAY,CAACG,KAAK;MACvB;QACI4N,SAAS,CAACsO,UAAU,CAACjU,EAAE,CAAC;QACxB;IAAM;IAEdrF,IAAI,CAACuZ,OAAO,CAACjK,eAAe,CAAC;EACjC,CAAC;EAEDuC,UAAU,CAAC7R,IAAI,EAAE;IACbA,IAAI,CAACwZ,OAAO,EAAE;IACdxZ,IAAI,CAACyZ,QAAQ,EAAE;EACnB,CAAC;EAEDhF,KAAK,EAAE,UAASF,EAAE,EAAEC,EAAE,EAAER,EAAE,EAAEC,EAAE,EAAE;IAE5B;IACA,IAAIM,EAAE,KAAKxI,SAAS,EAAE;MAClB,OAAOjS,CAAC,CAAC4f,aAAa,CAAC,IAAI,CAAC7N,MAAM,EAAE,CAAC;IACzC;;IAEA;IACA,IAAI2I,EAAE,KAAKzI,SAAS,EAAE;MAClByI,EAAE,GAAGD,EAAE;IACX;IACA,IAAIP,EAAE,KAAKjI,SAAS,EAAE;MAClBiI,EAAE,GAAG,CAAC;MACNC,EAAE,GAAG,CAAC;IACV;IAEA,IAAIC,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;IAEhC,IAAIF,EAAE,IAAIC,EAAE,IAAIC,SAAS,CAACuB,EAAE,IAAIvB,SAAS,CAACyB,EAAE,EAAE;MAC1C,IAAIgE,KAAK,GAAGzF,SAAS,CAACuB,EAAE,GAAGzB,EAAE,IAAIO,EAAE,GAAG,CAAC,CAAC;MACxC,IAAIqF,KAAK,GAAG1F,SAAS,CAACyB,EAAE,GAAG1B,EAAE,IAAIO,EAAE,GAAG,CAAC,CAAC;MACxC,IAAI,CAACN,SAAS,CAACyF,KAAK,EAAEC,KAAK,CAAC;IAChC;IAEArF,EAAE,GAAGpH,IAAI,CAACC,GAAG,CAACmH,EAAE,IAAI,CAAC,EAAE,IAAI,CAACpP,SAAS,CAAC;IACtCqP,EAAE,GAAGrH,IAAI,CAACC,GAAG,CAACoH,EAAE,IAAI,CAAC,EAAE,IAAI,CAACrP,SAAS,CAAC;IAEtC,IAAI2G,GAAG,GAAG,IAAI,CAACD,MAAM,EAAE;IACvBC,GAAG,CAACgN,CAAC,GAAGvE,EAAE;IACVzI,GAAG,CAAC+N,CAAC,GAAGrF,EAAE;IAEV,IAAI,CAAC3I,MAAM,CAACC,GAAG,CAAC;IAEhB,IAAI,CAACiF,OAAO,CAAC,OAAO,EAAEwD,EAAE,EAAEC,EAAE,EAAER,EAAE,EAAEC,EAAE,CAAC;IAErC,OAAO,IAAI;EACf,CAAC;EAED;EACA6F,MAAM,EAAE,UAASC,KAAK,EAAEC,EAAE,EAAEC,EAAE,EAAE;IAE5B;IACA,IAAIF,KAAK,KAAKhO,SAAS,EAAE;MACrB,OAAOjS,CAAC,CAACogB,cAAc,CAAC,IAAI,CAACrO,MAAM,EAAE,CAAC;IAC1C;;IAEA;;IAEA;IACA;IACA;IACA,IAAImO,EAAE,KAAKjO,SAAS,EAAE;MAClB,IAAIoO,IAAI,GAAG,IAAI,CAAC9T,KAAK,CAACsR,OAAO,EAAE;MAC/BqC,EAAE,GAAGG,IAAI,CAACtb,KAAK,GAAG,CAAC;MACnBob,EAAE,GAAGE,IAAI,CAACrb,MAAM,GAAG,CAAC;IACxB;IAEA,IAAIgN,GAAG,GAAG,IAAI,CAACD,MAAM,EAAE,CAACqI,SAAS,CAAC8F,EAAE,EAAEC,EAAE,CAAC,CAACH,MAAM,CAACC,KAAK,CAAC,CAAC7F,SAAS,CAAC,CAAC8F,EAAE,EAAE,CAACC,EAAE,CAAC;IAC3E,IAAI,CAACpO,MAAM,CAACC,GAAG,CAAC;IAEhB,OAAO,IAAI;EACf,CAAC;EAEDoI,SAAS,EAAE,UAASuB,EAAE,EAAEE,EAAE,EAAE;IAExB;IACA,IAAIF,EAAE,KAAK1J,SAAS,EAAE;MAClB,OAAOjS,CAAC,CAACsgB,iBAAiB,CAAC,IAAI,CAACvO,MAAM,EAAE,CAAC;IAC7C;IAEA,MAAM;MAAE7N;IAAQ,CAAC,GAAG,IAAI;IACxB,MAAM;MAAEe,MAAM;MAAEI;IAAS,CAAC,GAAGnB,OAAO;;IAEpC;IACAyX,EAAE,KAAKA,EAAE,GAAG,CAAC,CAAC;IACdE,EAAE,KAAKA,EAAE,GAAG,CAAC,CAAC;IAEd,MAAM7J,GAAG,GAAG,IAAI,CAACD,MAAM,EAAE;IACzB,IAAIC,GAAG,CAACuO,CAAC,KAAK5E,EAAE,IAAI3J,GAAG,CAACwO,CAAC,KAAK3E,EAAE,EAAE,OAAO,IAAI;IAC7C7J,GAAG,CAACuO,CAAC,GAAG5E,EAAE;IACV3J,GAAG,CAACwO,CAAC,GAAG3E,EAAE;IAEV,IAAI,CAAC9J,MAAM,CAACC,GAAG,CAAC;IAEhB,MAAM;MAAE2J,EAAE,EAAEzB,EAAE;MAAE2B,EAAE,EAAE1B;IAAG,CAAC,GAAG,IAAI,CAACC,SAAS,EAAE;IAC3CnV,MAAM,CAACC,CAAC,GAAGgV,EAAE;IACbjV,MAAM,CAACE,CAAC,GAAGgV,EAAE;IAEb,IAAI,CAAClD,OAAO,CAAC,WAAW,EAAEiD,EAAE,EAAEC,EAAE,CAAC;IAEjC,IAAI9U,QAAQ,EAAE;MACV,IAAI,CAACA,QAAQ,EAAE;IACnB;IAEA,OAAO,IAAI;EACf,CAAC;EAED;EACA;EACAob,QAAQ,EAAE,UAAS1G,GAAG,EAAE;IAEpB,IAAIxO,EAAE,GAAGzK,QAAQ,CAACiZ,GAAG,CAAC,GAChB,IAAI,CAACxN,KAAK,CAACmU,aAAa,CAAC3G,GAAG,CAAC,GAC7BA,GAAG,YAAY9W,CAAC,GAAG8W,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG;IAErC,IAAIlN,EAAE,GAAG,IAAI,CAAC8T,aAAa,CAAC,UAAU,EAAEpV,EAAE,CAAC;IAC3C,IAAIsB,EAAE,EAAE,OAAO,IAAI,CAACb,MAAM,CAACa,EAAE,CAAC;IAE9B,OAAOoF,SAAS;EACpB,CAAC;EAED;EACArD,eAAe,EAAE,UAASR,IAAI,EAAE;IAE5B,IAAIvB,EAAE,GAAI/L,QAAQ,CAACsN,IAAI,CAAC,IAAInO,QAAQ,CAACmO,IAAI,CAAC,GAAIA,IAAI,GAAIA,IAAI,IAAIA,IAAI,CAACvB,EAAG;IAEtE,OAAO,IAAI,CAACb,MAAM,CAACa,EAAE,CAAC;EAC1B,CAAC;EAED;EACA+T,kBAAkB,EAAE,UAASC,CAAC,EAAE;IAE5BA,CAAC,GAAG,IAAI5e,KAAK,CAAC4e,CAAC,CAAC;IAEhB,IAAIze,KAAK,GAAG,IAAI,CAACsJ,KAAK,CAACoV,WAAW,EAAE,CAACC,GAAG,CAAC,IAAI,CAACnS,eAAe,EAAE,IAAI,CAAC;IAEpE,OAAOxM,KAAK,CAACT,MAAM,CAAC,UAASuE,IAAI,EAAE;MAC/B,OAAOA,IAAI,IAAIA,IAAI,CAACqL,GAAG,CAACsM,OAAO,CAAC;QAAEmD,MAAM,EAAE,IAAI,CAACzU;MAAM,CAAC,CAAC,CAAC0U,aAAa,CAACJ,CAAC,CAAC;IAC5E,CAAC,EAAE,IAAI,CAAC;EACZ,CAAC;EAED;EACAK,eAAe,EAAE,UAASC,IAAI,EAAEnY,GAAG,EAAE;IAEjCA,GAAG,GAAG1I,QAAQ,CAAC0I,GAAG,IAAI,CAAC,CAAC,EAAE;MAAEoY,MAAM,EAAE;IAAM,CAAC,CAAC;IAC5CD,IAAI,GAAG,IAAInf,IAAI,CAACmf,IAAI,CAAC;IAErB,IAAI/e,KAAK,GAAG,IAAI,CAACsJ,KAAK,CAACoV,WAAW,EAAE,CAACC,GAAG,CAAC,IAAI,CAACnS,eAAe,EAAE,IAAI,CAAC;IACpE,IAAIyS,MAAM,GAAGrY,GAAG,CAACoY,MAAM,GAAG,cAAc,GAAG,WAAW;IAEtD,OAAOhf,KAAK,CAACT,MAAM,CAAC,UAASuE,IAAI,EAAE;MAC/B,OAAOA,IAAI,IAAIib,IAAI,CAACE,MAAM,CAAC,CAACnb,IAAI,CAACqL,GAAG,CAACsM,OAAO,CAAC;QAAEmD,MAAM,EAAE,IAAI,CAACzU;MAAM,CAAC,CAAC,CAAC;IACzE,CAAC,EAAE,IAAI,CAAC;EACZ,CAAC;EAED+U,WAAW,EAAE,YAAW;IACpB,IAAI,CAACC,kBAAkB,CAAC,QAAQ,CAAC;IACjC,OAAO,IAAI;EACf,CAAC;EAEDC,SAAS,EAAE,YAAW;IAClB,IAAI,CAACD,kBAAkB,CAAC,MAAM,CAAC;IAC/B,OAAO,IAAI;EACf,CAAC;EAEDE,SAAS,EAAE,YAAW;IAClB,IAAI,CAACF,kBAAkB,CAAC,MAAM,CAAC;IAC/B,OAAO,IAAI;EACf,CAAC;EAEDA,kBAAkB,EAAE,UAASrV,KAAK,EAAE,GAAG+R,IAAI,EAAE;IACzC,IAAI,OAAO/R,KAAK,KAAK,QAAQ,EAAE;IAC/B,IAAI,CAAC+K,OAAO,CAAC,aAAa,EAAE/K,KAAK,EAAE,GAAG+R,IAAI,CAAC;EAC/C,CAAC;EAGDyD,YAAY,EAAE,UAAS7U,EAAE,EAAE;IAEvB,OAAO,IAAI,CAACnB,KAAK,CAACiW,OAAO,CAAC9U,EAAE,CAAC;EACjC,CAAC;EAED+U,UAAU,EAAE,UAAS1c,CAAC,EAAEC,CAAC,EAAE;IAEvB;IACA;IACA,OAAO,IAAI,CAAC0c,kBAAkB,CAAC3c,CAAC,EAAEC,CAAC,CAAC,CAACyc,UAAU,CAAC,IAAI,CAAC1d,OAAO,CAACkB,QAAQ,CAAC;EAC1E,CAAC;EAED0c,iBAAiB,EAAE,UAAS5c,CAAC,EAAEC,CAAC,EAAE;IAC9B;IACA,IAAI4c,UAAU,GAAG,IAAI9f,KAAK,CAACiD,CAAC,EAAEC,CAAC,CAAC;IAChC,IAAI6c,UAAU,GAAGhiB,CAAC,CAACiiB,cAAc,CAACF,UAAU,EAAE,IAAI,CAAChQ,MAAM,EAAE,CAAC;IAC5D,OAAOiQ,UAAU;EACrB,CAAC;EAED5F,gBAAgB,EAAE,UAASlX,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,EAAE;IAC5C;IACA,IAAIkd,SAAS,GAAG,IAAIlgB,IAAI,CAACkD,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,CAAC;IAC7C,IAAImd,SAAS,GAAGniB,CAAC,CAACoiB,aAAa,CAACF,SAAS,EAAE,IAAI,CAACnQ,MAAM,EAAE,CAAC;IACzD,OAAOoQ,SAAS;EACpB,CAAC;EAED7F,iBAAiB,EAAE,UAASpX,CAAC,EAAEC,CAAC,EAAE;IAC9B;IACA,IAAI6c,UAAU,GAAG,IAAI/f,KAAK,CAACiD,CAAC,EAAEC,CAAC,CAAC;IAChC,IAAI4c,UAAU,GAAG/hB,CAAC,CAACiiB,cAAc,CAACD,UAAU,EAAE,IAAI,CAACjQ,MAAM,EAAE,CAACsQ,OAAO,EAAE,CAAC;IACtE,OAAON,UAAU;EACrB,CAAC;EAEDhE,gBAAgB,EAAE,UAAS7Y,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,EAAE;IAC5C;IACA,IAAImd,SAAS,GAAG,IAAIngB,IAAI,CAACkD,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,CAAC;IAC7C,IAAIkd,SAAS,GAAGliB,CAAC,CAACoiB,aAAa,CAACD,SAAS,EAAE,IAAI,CAACpQ,MAAM,EAAE,CAACsQ,OAAO,EAAE,CAAC;IACnE,OAAOH,SAAS;EACpB,CAAC;EAEDI,kBAAkB,EAAE,UAASpd,CAAC,EAAEC,CAAC,EAAE;IAC/B;IACA,IAAI4c,UAAU,GAAG,IAAI9f,KAAK,CAACiD,CAAC,EAAEC,CAAC,CAAC;IAChC,IAAIod,WAAW,GAAGviB,CAAC,CAACiiB,cAAc,CAACF,UAAU,EAAE,IAAI,CAACvP,YAAY,EAAE,CAAC;IACnE,OAAO+P,WAAW;EACtB,CAAC;EAEDC,iBAAiB,EAAE,UAAStd,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,EAAE;IAC7C;IACA,IAAIkd,SAAS,GAAG,IAAIlgB,IAAI,CAACkD,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,CAAC;IAC7C,IAAIyd,UAAU,GAAGziB,CAAC,CAACoiB,aAAa,CAACF,SAAS,EAAE,IAAI,CAAC1P,YAAY,EAAE,CAAC;IAChE,OAAOiQ,UAAU;EACrB,CAAC;EAED;EACA;EACA;EACA;EACAZ,kBAAkB,EAAE,UAAS3c,CAAC,EAAEC,CAAC,EAAE;IAC/B;IACA,IAAIod,WAAW,GAAG,IAAItgB,KAAK,CAACiD,CAAC,EAAEC,CAAC,CAAC;IACjC,IAAI4c,UAAU,GAAG/hB,CAAC,CAACiiB,cAAc,CAACM,WAAW,EAAE,IAAI,CAAC/P,YAAY,EAAE,CAAC6P,OAAO,EAAE,CAAC;IAC7E,OAAON,UAAU;EACrB,CAAC;EAEDW,iBAAiB,EAAE,UAASxd,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,EAAE;IAC7C;IACA,IAAIyd,UAAU,GAAG,IAAIzgB,IAAI,CAACkD,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,CAAC;IAC9C,IAAIkd,SAAS,GAAGliB,CAAC,CAACoiB,aAAa,CAACK,UAAU,EAAE,IAAI,CAACjQ,YAAY,EAAE,CAAC6P,OAAO,EAAE,CAAC;IAC1E,OAAOH,SAAS;EACpB,CAAC;EAEDS,gBAAgB,EAAE,UAASzd,CAAC,EAAEC,CAAC,EAAE;IAE7B,OAAO,IAAI,CAAC2c,iBAAiB,CAAC5c,CAAC,EAAEC,CAAC,CAAC,CAACyd,MAAM,CAAC,IAAI,CAACC,UAAU,EAAE,CAAC;EACjE,CAAC;EAEDC,eAAe,EAAE,UAAS5d,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,EAAE;IAE3C,OAAO,IAAI,CAACoX,gBAAgB,CAAClX,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,CAAC,CAAC4d,MAAM,CAAC,IAAI,CAACC,UAAU,EAAE,CAAC;EAC/E,CAAC;EAEDE,gBAAgB,EAAE,UAAS7d,CAAC,EAAEC,CAAC,EAAE;IAE7B,IAAI6d,SAAS,GAAG,IAAI/gB,KAAK,CAACiD,CAAC,EAAEC,CAAC,CAAC;IAC/B,IAAI6c,UAAU,GAAGgB,SAAS,CAACC,UAAU,CAAC,IAAI,CAACJ,UAAU,EAAE,CAAC;IACxD,OAAO,IAAI,CAACvG,iBAAiB,CAAC0F,UAAU,CAAC;EAC7C,CAAC;EAEDkB,eAAe,EAAE,UAAShe,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,EAAE;IAE3C,IAAI6d,UAAU,GAAG,IAAI,CAACA,UAAU,EAAE;IAClC,IAAIV,SAAS,GAAG,IAAIngB,IAAI,CAACkD,CAAC,EAAEC,CAAC,EAAEJ,KAAK,EAAEC,MAAM,CAAC;IAC7Cmd,SAAS,CAACjd,CAAC,IAAI2d,UAAU,CAAC3d,CAAC;IAC3Bid,SAAS,CAAChd,CAAC,IAAI0d,UAAU,CAAC1d,CAAC;IAC3B,OAAO,IAAI,CAAC4Y,gBAAgB,CAACoE,SAAS,CAAC;EAC3C,CAAC;EAEDgB,YAAY,EAAE,YAAW;IAErB,IAAIV,UAAU,GAAG,IAAI,CAACnY,GAAG,CAAC8Y,qBAAqB,EAAE;IACjD,OAAO,IAAInhB,KAAK,CAACwgB,UAAU,CAAC7G,IAAI,EAAE6G,UAAU,CAAC3G,GAAG,CAAC;EACrD,CAAC;EAED+G,UAAU,EAAE,YAAW;IAEnB,OAAO,IAAI,CAACM,YAAY,EAAE,CAACP,MAAM,CAACS,MAAM,CAACC,OAAO,EAAED,MAAM,CAACE,OAAO,CAAC;EACrE,CAAC;EAEDC,WAAW,EAAE,UAAS9d,QAAQ,EAAE;IAE5B,IAAI,EAAEA,QAAQ,YAAYnD,QAAQ,CAAC,EAAE;MACjC,MAAM,IAAI+N,KAAK,CAAC,0BAA0B,CAAC;IAC/C;IAEA,IAAIyC,IAAI,GAAGrN,QAAQ,CAACgG,KAAK;IACzB,IAAI+X,YAAY,GAAG,IAAI,CAACvf,OAAO;IAC/B,IAAIoL,KAAK,GAAG,IAAI,CAAC5D,KAAK;IACtB,IAAIkE,EAAE,GAAGN,KAAK,CAACoU,WAAW,CAACC,WAAW;IAEtC,IAAI,CAACF,YAAY,CAAC1d,UAAU,EAAE;MAC1B,IAAI,CAAC6J,EAAE,CAAC7J,UAAU,CAAC+O,IAAI,CAAC,IAAI,EAAExF,KAAK,EAAEyD,IAAI,CAAC,EAAE,OAAO,KAAK;IAC5D;IAEA,IAAI,CAAC0Q,YAAY,CAACpb,WAAW,EAAE;MAC3B;MACA,IAAI,CAACuH,EAAE,CAACvH,WAAW,CAACyM,IAAI,CAAC,IAAI,EAAExF,KAAK,EAAEyD,IAAI,CAAC,EAAE,OAAO,KAAK;IAC7D;IAEA,IAAI,OAAO0Q,YAAY,CAACnb,SAAS,KAAK,UAAU,EAAE;MAC9C,IAAI,CAACmb,YAAY,CAACnb,SAAS,CAACwM,IAAI,CAAC,IAAI,EAAEpP,QAAQ,EAAE,IAAI,CAAC,EAAE,OAAO,KAAK;IACxE;IAEA,OAAO,IAAI;EACf,CAAC;EAEDke,cAAc,EAAE,UAASjL,QAAQ,EAAEzR,MAAM,EAAE;IAEvC,OAAOxG,UAAU,CAAC,IAAI,CAACwD,OAAO,CAACuC,WAAW;IAC1C;IAAA,EACM,IAAI,CAACvC,OAAO,CAACuC,WAAW,CAACqO,IAAI,CAAC,IAAI,EAAE6D,QAAQ,EAAEzR,MAAM;IAC1D;IAAA,EACM,IAAI,CAAChD,OAAO,CAACuC,WAAW,CAACod,KAAK,EAAE;EAC1C,CAAC;EAED;EACA;;EAEAC,kBAAkB,EAAE,UAAS9a,GAAG,GAAG,CAAC,CAAC,EAAE;IAEnC,IAAI;MAAE+a,WAAW,EAAEC,cAAc;MAAE1P;IAAK,CAAC,GAAGtL,GAAG;IAC/C,MAAM;MAAE7C,YAAY;MAAC4D;IAAsB,CAAC,GAAG,IAAI,CAAC7F,OAAO;;IAE3D;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI8f,cAAc,KAAK/R,SAAS,EAAE;MAE9B;MACA,IAAI,CAAC9L,YAAY,EAAE,OAAO,KAAK;MAC/B;MACA,IAAImO,IAAI,EAAE;QACN0P,cAAc,GAAG7d,YAAY,CAACmO,IAAI,CAAC;QACnC;QACA,IAAI0P,cAAc,KAAK,KAAK,EAAE,OAAO,KAAK;MAC9C;MACA,IAAI,CAACA,cAAc,EAAE;QACjB;QACAA,cAAc,GAAG7d,YAAY,CAAC,SAAS,CAAC;MAC5C;IACJ;;IAEA;IACA;IACA;IACA;IACA,IAAI,CAAC6d,cAAc,EAAE,OAAO,KAAK;;IAEjC;IACA,IAAIljB,QAAQ,CAACkjB,cAAc,CAAC,EAAE;MAC1BA,cAAc,GAAG;QACb/f,IAAI,EAAE+f;MACV,CAAC;IACL;IAEA,MAAM/f,IAAI,GAAG+f,cAAc,CAAC/f,IAAI;IAChC,MAAM8f,WAAW,GAAGha,oBAAoB,CAAC9F,IAAI,CAAC;;IAE9C;IACA,IAAI,CAAC8f,WAAW,EAAE;MACd,MAAM,IAAIzT,KAAK,CAAC,wBAAwB,GAAGrM,IAAI,GAAG,IAAI,CAAC;IAC3D;IACA,IAAI,OAAO8f,WAAW,CAACE,SAAS,KAAK,UAAU,EAAE;MAC7C,MAAM,IAAI3T,KAAK,CAAC,gBAAgB,GAAGrM,IAAI,GAAG,2CAA2C,CAAC;IAC1F;IACA,IAAI,OAAO8f,WAAW,CAACG,WAAW,KAAK,UAAU,EAAE;MAC/C,MAAM,IAAI5T,KAAK,CAAC,gBAAgB,GAAGrM,IAAI,GAAG,6CAA6C,CAAC;IAC5F;IAEA,OAAO;MACH8f,WAAW;MACX7f,OAAO,EAAE8f,cAAc,CAAC9f,OAAO,IAAI,CAAC,CAAC;MACrCD;IACJ,CAAC;EACL,CAAC;EAEDgK,eAAe,EAAE,UAAS0K,QAAQ,EAAEwL,QAAQ,EAAEnb,GAAG,EAAE;IAC/C,MAAMob,qBAAqB,GAAG,IAAI,CAACN,kBAAkB,CAAC9a,GAAG,CAAC;IAC1D,IAAI,CAACob,qBAAqB,EAAE;IAC5B,MAAM;MAAEL,WAAW;MAAE7f;IAAQ,CAAC,GAAGkgB,qBAAqB;IACtDL,WAAW,CAACE,SAAS,CAACtL,QAAQ,EAAEwL,QAAQ,EAAEjgB,OAAO,CAAC;EACtD,CAAC;EAEDgK,iBAAiB,EAAE,UAASyK,QAAQ,EAAEwL,QAAQ,EAAEnb,GAAG,EAAE;IACjD,MAAMob,qBAAqB,GAAG,IAAI,CAACN,kBAAkB,CAAC9a,GAAG,CAAC;IAC1D,IAAI,CAACob,qBAAqB,EAAE;IAC5B,MAAM;MAAEL,WAAW;MAAE7f;IAAQ,CAAC,GAAGkgB,qBAAqB;IACtDL,WAAW,CAACG,WAAW,CAACvL,QAAQ,EAAEwL,QAAQ,EAAEjgB,OAAO,CAAC;EACxD,CAAC;EAED;EACA;;EAEAmgB,eAAe,EAAE,UAASpe,GAAG,EAAE;IAE3BA,GAAG,CAACqe,cAAc,EAAE;;IAEpB;;IAEAre,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;IAEzB,IAAIC,IAAI,GAAG,IAAI,CAACua,QAAQ,CAACxa,GAAG,CAAC+a,MAAM,CAAC;IACpC,IAAI,IAAI,CAAChb,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;IAE3B,IAAI6b,UAAU,GAAG,IAAI,CAACH,UAAU,CAAC3b,GAAG,CAACse,OAAO,EAAEte,GAAG,CAACue,OAAO,CAAC;IAE1D,IAAIte,IAAI,EAAE;MACNA,IAAI,CAACme,eAAe,CAACpe,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;IAEzD,CAAC,MAAM;MACH,IAAI,CAAC8R,OAAO,CAAC,uBAAuB,EAAEhR,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;IAC1E;EACJ,CAAC;EAEDsf,YAAY,EAAE,UAASxe,GAAG,EAAE;IAExB;;IAEA,IAAImJ,IAAI,GAAG,IAAI,CAACsV,SAAS,CAACze,GAAG,CAAC;IAC9B;IACA,IAAImJ,IAAI,CAACuV,UAAU,IAAI,IAAI,CAACzgB,OAAO,CAACqE,cAAc,EAAE;MAEhDtC,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;MAEzB,IAAIC,IAAI,GAAG,IAAI,CAACua,QAAQ,CAACxa,GAAG,CAAC+a,MAAM,CAAC;MACpC,IAAI,IAAI,CAAChb,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;MAE3B,IAAI6b,UAAU,GAAG,IAAI,CAACH,UAAU,CAAC3b,GAAG,CAACse,OAAO,EAAEte,GAAG,CAACue,OAAO,CAAC;MAE1D,IAAIte,IAAI,EAAE;QACNA,IAAI,CAACue,YAAY,CAACxe,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;MAEtD,CAAC,MAAM;QACH,IAAI,CAAC8R,OAAO,CAAC,oBAAoB,EAAEhR,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;MACvE;IACJ;EACJ,CAAC;EAEDyf,WAAW,EAAE,UAAS3e,GAAG,EAAE;IAEvB,IAAI,IAAI,CAAC/B,OAAO,CAACkC,kBAAkB,EAAEH,GAAG,CAACqe,cAAc,EAAE;IAEzD,IAAI,IAAI,CAACO,gBAAgB,EAAE;MACvB,IAAI,CAACA,gBAAgB,GAAG,KAAK;MAC7B;IACJ;IAEA5e,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;IAEzB,IAAI,CAAC6e,kBAAkB,CAAC7e,GAAG,CAAC;EAChC,CAAC;EAED6e,kBAAkB,EAAE,UAAS7e,GAAG,EAAE;IAC9B,IAAIC,IAAI,GAAG,IAAI,CAACua,QAAQ,CAACxa,GAAG,CAAC+a,MAAM,CAAC;IACpC,IAAI,IAAI,CAAChb,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;IAE3B,IAAI6b,UAAU,GAAG,IAAI,CAACH,UAAU,CAAC3b,GAAG,CAACse,OAAO,EAAEte,GAAG,CAACue,OAAO,CAAC;IAE1D,IAAIte,IAAI,EAAE;MACNA,IAAI,CAAC0e,WAAW,CAAC3e,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;IAErD,CAAC,MAAM;MACH,IAAI,CAAC8R,OAAO,CAAC,mBAAmB,EAAEhR,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;IACtE;EACJ,CAAC;EAED4f,WAAW,EAAE,UAAS9e,GAAG,EAAE;IAEvBA,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;IAEzB,MAAM;MAAE+a,MAAM;MAAEgE;IAAO,CAAC,GAAG/e,GAAG;IAC9B,MAAMC,IAAI,GAAG,IAAI,CAACua,QAAQ,CAACO,MAAM,CAAC;IAClC,MAAMiE,aAAa,GAAID,MAAM,KAAK,CAAE;IAEpC,IAAI9e,IAAI,EAAE;MAEN,IAAI,CAAC+e,aAAa,IAAI,IAAI,CAACjf,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;MAE7C,MAAMgf,gBAAgB,GAAG,IAAI,CAAC/Z,sBAAsB,CAACqE,QAAQ,CAACwR,MAAM,CAAChR,OAAO,CAAC;MAE7E,IAAI,IAAI,CAAC9L,OAAO,CAACoC,wBAAwB,IAAI,CAAC4e,gBAAgB,EAAE;QAC5D;QACA;QACA;QACAjf,GAAG,CAACqe,cAAc,EAAE;MACxB;MAEA,IAAIY,gBAAgB,EAAE;QAClB;QACA;QACAhf,IAAI,CAACif,yBAAyB,CAAClf,GAAG,CAAC;MACvC;MAEA,MAAMmf,UAAU,GAAGlf,IAAI,CAACqF,EAAE;;MAE1B;MACA,MAAM8Z,SAAS,GAAGrE,MAAM,CAACsE,OAAO,CAAC,SAAS,CAAC;MAC3C,IAAID,SAAS,IAAID,UAAU,KAAKC,SAAS,IAAInf,IAAI,CAACqF,EAAE,CAACga,QAAQ,CAACF,SAAS,CAAC,EAAE;QACtE,MAAMG,QAAQ,GAAGxkB,cAAc,CAACiC,CAAC,CAACwiB,KAAK,CAACxf,GAAG,CAACyf,aAAa,EAAE;UACvDtW,IAAI,EAAEnJ,GAAG,CAACmJ,IAAI;UACd;UACAuW,aAAa,EAAEN;QACnB,CAAC,CAAC,CAAC;QACH,IAAI,CAACO,OAAO,CAACJ,QAAQ,CAAC;QACtB,IAAIA,QAAQ,CAACK,kBAAkB,EAAE,EAAE;UAC/B5f,GAAG,CAACqe,cAAc,EAAE;QACxB;QACA;QACA,IAAIkB,QAAQ,CAACM,oBAAoB,EAAE,EAAE;QACrC7f,GAAG,CAACmJ,IAAI,GAAGoW,QAAQ,CAACpW,IAAI;MAC5B;;MAEA;MACA,MAAM2W,UAAU,GAAG/E,MAAM,CAACsE,OAAO,CAAC,UAAU,CAAC;MAC7C,IAAIS,UAAU,IAAI7f,IAAI,CAACqF,EAAE,KAAKwa,UAAU,IAAI7f,IAAI,CAACqF,EAAE,CAACga,QAAQ,CAACQ,UAAU,CAAC,EAAE;QACtE,MAAMC,SAAS,GAAGhlB,cAAc,CAACiC,CAAC,CAACwiB,KAAK,CAACxf,GAAG,CAACyf,aAAa,EAAE;UACxDtW,IAAI,EAAEnJ,GAAG,CAACmJ,IAAI;UACd;UACAuW,aAAa,EAAEI;QACnB,CAAC,CAAC,CAAC;QACH,IAAI,CAACE,QAAQ,CAACD,SAAS,CAAC;QACxB,IAAIA,SAAS,CAACH,kBAAkB,EAAE,EAAE;UAChC5f,GAAG,CAACqe,cAAc,EAAE;QACxB;QACA;QACA,IAAI0B,SAAS,CAACF,oBAAoB,EAAE,EAAE;UAClC;UACA,IAAIb,aAAa,EAAE;UACnB,IAAI,CAACiB,kBAAkB,CAAChgB,IAAI,EAAE8f,SAAS,CAAC5W,IAAI,CAAC;UAC7C;QACJ;QACAnJ,GAAG,CAACmJ,IAAI,GAAG4W,SAAS,CAAC5W,IAAI;MAC7B;IACJ;IAEA,IAAI6V,aAAa,EAAE;MACf,IAAI,CAACJ,gBAAgB,GAAG,IAAI;MAC5B,MAAMsB,cAAc,GAAGljB,CAAC,CAACwiB,KAAK,CAACxf,GAAG,CAACyf,aAAa,EAAE;QAAEpR,IAAI,EAAE,aAAa;QAAElF,IAAI,EAAEnJ,GAAG,CAACmJ;MAAK,CAAC,CAAC;MAC1F,IAAI,CAAC0V,kBAAkB,CAACqB,cAAc,CAAC;IAC3C,CAAC,MAAM;MACH,MAAMpE,UAAU,GAAG,IAAI,CAACH,UAAU,CAAC3b,GAAG,CAACse,OAAO,EAAEte,GAAG,CAACue,OAAO,CAAC;MAC5D,IAAIte,IAAI,EAAE;QACNA,IAAI,CAAC6e,WAAW,CAAC9e,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;MACrD,CAAC,MAAM;QACH,IAAI,IAAI,CAACjB,OAAO,CAACmC,yBAAyB,EAAE;UACxCJ,GAAG,CAACqe,cAAc,EAAE;QACxB;QACA,IAAI,CAACrN,OAAO,CAAC,mBAAmB,EAAEhR,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;MACtE;MAEA,IAAI,CAAC+gB,kBAAkB,CAAChgB,IAAI,EAAED,GAAG,CAACmJ,IAAI,CAAC;IAC3C;EAEJ,CAAC;EAEDgX,WAAW,EAAE,UAASngB,GAAG,EAAE;IAEvB;IACA,IAAImJ,IAAI,GAAG,IAAI,CAACsV,SAAS,CAACze,GAAG,CAAC;IAC9B,IAAI,CAACmJ,IAAI,CAACuV,UAAU,EAAE;MAClBvV,IAAI,CAACuV,UAAU,GAAG,CAAC;MACnB;MACA;MACA,IAAI,CAAC0B,gBAAgB,EAAE;MACvB;MACA;IACJ;;IAEA,IAAI1B,UAAU,GAAG,EAAEvV,IAAI,CAACuV,UAAU;IAElC,IAAIA,UAAU,IAAI,IAAI,CAACzgB,OAAO,CAACsE,aAAa,EAAE;IAE9CvC,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;IAEzB,IAAI8b,UAAU,GAAG,IAAI,CAACH,UAAU,CAAC3b,GAAG,CAACse,OAAO,EAAEte,GAAG,CAACue,OAAO,CAAC;IAE1D,IAAIte,IAAI,GAAGkJ,IAAI,CAACyE,UAAU;IAC1B,IAAI3N,IAAI,EAAE;MACNA,IAAI,CAACkgB,WAAW,CAACngB,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;IACrD,CAAC,MAAM;MACH,IAAI,CAAC8R,OAAO,CAAC,mBAAmB,EAAEhR,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;IACtE;IAEA,IAAI,CAACuf,SAAS,CAACze,GAAG,EAAEmJ,IAAI,CAAC;EAC7B,CAAC;EAEDkX,SAAS,EAAE,UAASrgB,GAAG,EAAE;IAErB,IAAI,CAACsgB,wBAAwB,EAAE;IAE/B,IAAIC,aAAa,GAAGxlB,cAAc,CAACiF,GAAG,CAAC;IAEvC,IAAI8b,UAAU,GAAG,IAAI,CAACH,UAAU,CAAC4E,aAAa,CAACjC,OAAO,EAAEiC,aAAa,CAAChC,OAAO,CAAC;IAE9E,IAAIte,IAAI,GAAG,IAAI,CAACwe,SAAS,CAACze,GAAG,CAAC,CAAC4N,UAAU;IACzC,IAAI3N,IAAI,EAAE;MACNA,IAAI,CAACogB,SAAS,CAACE,aAAa,EAAEzE,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;IAC7D,CAAC,MAAM;MACH,IAAI,CAAC8R,OAAO,CAAC,iBAAiB,EAAEuP,aAAa,EAAEzE,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;IAC9E;IAEA,IAAI,CAACqhB,aAAa,CAACV,oBAAoB,EAAE,EAAE;MACvC,IAAI,CAACrB,YAAY,CAACxhB,CAAC,CAACwiB,KAAK,CAACxf,GAAG,CAACyf,aAAa,EAAE;QAAEpR,IAAI,EAAE,OAAO;QAAElF,IAAI,EAAEnJ,GAAG,CAACmJ;MAAK,CAAC,CAAC,CAAC;IACpF;IAEA,IAAI,CAACqX,cAAc,EAAE;EACzB,CAAC;EAEDC,SAAS,EAAE,UAASzgB,GAAG,EAAE;IAErBA,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;IAEzB,IAAIC,IAAI,GAAG,IAAI,CAACua,QAAQ,CAACxa,GAAG,CAAC+a,MAAM,CAAC;IACpC,IAAI,IAAI,CAAChb,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;IAE3B,IAAIA,IAAI,EAAE;MACNA,IAAI,CAACwgB,SAAS,CAACzgB,GAAG,CAAC;IAEvB,CAAC,MAAM;MACH,IAAI,IAAI,CAACsF,EAAE,KAAKtF,GAAG,CAAC+a,MAAM,EAAE,OAAO,CAAC;MACpC,IAAI,CAAC/J,OAAO,CAAC,iBAAiB,EAAEhR,GAAG,CAAC;IACxC;EACJ,CAAC;EAED0gB,QAAQ,EAAE,UAAS1gB,GAAG,EAAE;IAEpBA,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;IAEzB,IAAIC,IAAI,GAAG,IAAI,CAACua,QAAQ,CAACxa,GAAG,CAAC+a,MAAM,CAAC;IACpC,IAAI,IAAI,CAAChb,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;IAE3B,IAAIA,IAAI,EAAE;MACNA,IAAI,CAACygB,QAAQ,CAAC1gB,GAAG,CAAC;IAEtB,CAAC,MAAM;MACH,IAAI,IAAI,CAACsF,EAAE,KAAKtF,GAAG,CAAC+a,MAAM,EAAE,OAAO,CAAC;MACpC,IAAI,CAAC/J,OAAO,CAAC,gBAAgB,EAAEhR,GAAG,CAAC;IACvC;EACJ,CAAC;EAED2gB,UAAU,EAAE,UAAS3gB,GAAG,EAAE;IAEtBA,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;IAEzB,MAAM;MACF+a,MAAM;MAAE;MACR6F,aAAa;MAAE;MACflB,aAAa,CAAC;IAClB,CAAC,GAAG1f,GAAG;IACP,MAAMC,IAAI,GAAG,IAAI,CAACua,QAAQ,CAACO,MAAM,CAAC;IAClC,IAAI,IAAI,CAAChb,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;IAC3B,MAAM4gB,WAAW,GAAG,IAAI,CAACrG,QAAQ,CAACoG,aAAa,CAAC;IAChD,IAAI3gB,IAAI,EAAE;MACN,IAAI4gB,WAAW,KAAK5gB,IAAI,EAAE;QACtB;QACA;MACJ;MACAA,IAAI,CAAC0gB,UAAU,CAAC3gB,GAAG,CAAC;MACpB,IAAI,IAAI,CAACsF,EAAE,CAACga,QAAQ,CAACsB,aAAa,CAAC,EAAE;QACjC;QACA;MACJ;IACJ;IACA,IAAIC,WAAW,EAAE;MACb;IACJ;IACA;IACA;IACA,IAAInB,aAAa,KAAK,IAAI,CAACpa,EAAE,EAAE;MAC3B;MACA,IAAI,CAAC0L,OAAO,CAAC,kBAAkB,EAAEhR,GAAG,CAAC;IACzC;EACJ,CAAC;EAED8gB,UAAU,EAAE,UAAS9gB,GAAG,EAAE;IAEtBA,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;IAEzB,MAAM;MACF+a,MAAM;MAAE;MACR6F,aAAa;MAAE;MACflB,aAAa,CAAC;IAClB,CAAC,GAAG1f,GAAG;IACP,MAAMC,IAAI,GAAG,IAAI,CAACua,QAAQ,CAACO,MAAM,CAAC;IAClC,IAAI,IAAI,CAAChb,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;IAC3B,MAAM4gB,WAAW,GAAG,IAAI,CAACrG,QAAQ,CAACoG,aAAa,CAAC;IAChD,IAAI3gB,IAAI,EAAE;MACN,IAAI4gB,WAAW,KAAK5gB,IAAI,EAAE;QACtB;QACA;MACJ;MACAA,IAAI,CAAC6gB,UAAU,CAAC9gB,GAAG,CAAC;MACpB,IAAI,IAAI,CAACsF,EAAE,CAACga,QAAQ,CAACsB,aAAa,CAAC,EAAE;QACjC;QACA;MACJ;IACJ;IACA,IAAIC,WAAW,EAAE;MACb;MACA;IACJ;IACA;IACA;IACA,IAAInB,aAAa,KAAK,IAAI,CAACpa,EAAE,EAAE;MAC3B;MACA,IAAI,CAAC0L,OAAO,CAAC,kBAAkB,EAAEhR,GAAG,CAAC;IACzC;EACJ,CAAC;EAED+gB,wBAAwB,EAAE7lB,QAAQ,CAAC,YAAW;IAC1C,MAAM;MAAE+K,KAAK;MAAEC;IAAO,CAAC,GAAG,IAAI,CAACF,cAAc;IAC7C,MAAMgb,MAAM,GAAG9a,MAAM,CAAC+a,MAAM,CAAC,CAACC,GAAG,EAAEF,MAAM,KAAKE,GAAG,GAAGjmB,GAAG,CAAC+lB,MAAM,EAAE1jB,SAAS,CAAC,EAAE,CAAC,CAAC;IAE9E,MAAMoX,KAAK,GAAGtH,IAAI,CAAC+T,GAAG,CAAC,KAAK,EAAEH,MAAM,CAAC,CAAC,CAAC;IACvC,MAAM;MAAE/hB,CAAC;MAAEC;IAAE,CAAC,GAAG,IAAI,CAAC0c,kBAAkB,CAAC3V,KAAK,CAACqY,OAAO,EAAErY,KAAK,CAACsY,OAAO,CAAC;IACtE,IAAI,CAACvN,OAAO,CAAC,aAAa,EAAE/K,KAAK,EAAEhH,CAAC,EAAEC,CAAC,EAAEwV,KAAK,CAAC;IAE/C,IAAI,CAAC1O,cAAc,GAAG;MAClBC,KAAK,EAAE,IAAI;MACXC,MAAM,EAAE;IACZ,CAAC;EACL,CAAC,EAAE3I,aAAa,EAAE;IAAE6jB,OAAO,EAAE7jB;EAAc,CAAC,CAAC;EAE7C8jB,UAAU,EAAE,UAASrhB,GAAG,EAAE;IAEtBA,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;IAEzB,MAAMC,IAAI,GAAG,IAAI,CAACua,QAAQ,CAACxa,GAAG,CAAC+a,MAAM,CAAC;IACtC,IAAI,IAAI,CAAChb,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;IAE3B,MAAMwf,aAAa,GAAGzf,GAAG,CAACyf,aAAa;IACvC,MAAM3D,UAAU,GAAG,IAAI,CAACH,UAAU,CAAC8D,aAAa,CAACnB,OAAO,EAAEmB,aAAa,CAAClB,OAAO,CAAC;IAChF,MAAM;MAAE+C,MAAM;MAAEN;IAAO,CAAC,GAAGhmB,cAAc,CAACykB,aAAa,CAAC;IAExD,MAAM8B,aAAa,GAAG,IAAI,CAACC,OAAO,CAAC,aAAa,CAAC;;IAEjD;IACA;IACA;IACA;IACA;IACA,IAAIxhB,GAAG,CAACyhB,OAAO,IAAIF,aAAa,IAAIA,aAAa,CAAC1U,MAAM,GAAG,CAAC,EAAE;MAC1D;MACA4S,aAAa,CAACpB,cAAc,EAAE;MAC9B,IAAI,CAACrY,cAAc,CAACC,KAAK,GAAGwZ,aAAa;MACzC,IAAI,CAACzZ,cAAc,CAACE,MAAM,CAAC+G,IAAI,CAAC+T,MAAM,CAAC;MACvC,IAAI,CAACD,wBAAwB,EAAE;IACnC,CAAC,MAAM;MACH,MAAMW,KAAK,GAAGtU,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC,EAAED,IAAI,CAAC+C,GAAG,CAAC,CAAC,EAAEsP,aAAa,CAACkC,UAAU,CAAC,CAAC;MACjE,IAAI1hB,IAAI,EAAE;QACNA,IAAI,CAACohB,UAAU,CAACrhB,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,EAAEwiB,KAAK,CAAC;MAE3D,CAAC,MAAM;QACH,IAAI,CAAC1Q,OAAO,CAAC,kBAAkB,EAAEhR,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,EAAEwiB,KAAK,CAAC;MAC5E;MAEA,IAAI,CAAC1Q,OAAO,CAAC,WAAW,EAAEhR,GAAG,EAAEshB,MAAM,EAAEN,MAAM,CAAC;IAClD;EACJ,CAAC;EAEDrB,OAAO,EAAE,UAAS3f,GAAG,EAAE;IAEnB,IAAIof,SAAS,GAAGpf,GAAG,CAAC0f,aAAa;IACjC,IAAIkC,SAAS,GAAGxC,SAAS,CAACje,YAAY,CAAC,OAAO,CAAC;IAC/C,IAAIygB,SAAS,EAAE;MACX,IAAI3hB,IAAI,GAAG,IAAI,CAACua,QAAQ,CAAC4E,SAAS,CAAC;MACnC,IAAInf,IAAI,EAAE;QAEND,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;QACzB,IAAI,IAAI,CAACD,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;QAE3B,IAAI6b,UAAU,GAAG,IAAI,CAACH,UAAU,CAAC3b,GAAG,CAACse,OAAO,EAAEte,GAAG,CAACue,OAAO,CAAC;QAC1Dte,IAAI,CAAC0f,OAAO,CAAC3f,GAAG,EAAE4hB,SAAS,EAAE9F,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;MAC5D;IACJ;EACJ,CAAC;EAED2iB,WAAW,EAAE,UAAS7hB,GAAG,EAAE8hB,OAAO,EAAE;IAEhC,IAAIhC,UAAU,GAAG9f,GAAG,CAAC0f,aAAa;IAClC,IAAIqC,WAAW,GAAGjC,UAAU,CAAC3e,YAAY,CAAC,QAAQ,CAAC;IACnD,IAAI4gB,WAAW,EAAE;MACb,IAAI9hB,IAAI,GAAG,IAAI,CAACua,QAAQ,CAACsF,UAAU,CAAC;MACpC,IAAI7f,IAAI,EAAE;QACND,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;QACzB,IAAI,IAAI,CAACD,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;QAC3B,IAAI6b,UAAU,GAAG,IAAI,CAACH,UAAU,CAAC3b,GAAG,CAACse,OAAO,EAAEte,GAAG,CAACue,OAAO,CAAC;QAC1DuD,OAAO,CAACjT,IAAI,CAAC,IAAI,EAAE5O,IAAI,EAAED,GAAG,EAAE8f,UAAU,EAAEhE,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;MACzE;IACJ;EACJ,CAAC;EAED8gB,QAAQ,EAAE,UAAShgB,GAAG,EAAE;IAEpB,IAAIA,GAAG,CAAC+e,MAAM,KAAK,CAAC,EAAE;MAClB,IAAI,CAACH,gBAAgB,GAAG,IAAI;MAC5B,IAAI,CAACoD,sBAAsB,GAAG,IAAI;MAClC,MAAM9B,cAAc,GAAGljB,CAAC,CAACwiB,KAAK,CAACxf,GAAG,CAACyf,aAAa,EAAE;QAC9CpR,IAAI,EAAE,aAAa;QACnBlF,IAAI,EAAEnJ,GAAG,CAACmJ,IAAI;QACduW,aAAa,EAAE1f,GAAG,CAAC0f;MACvB,CAAC,CAAC;MACF,IAAI,CAACuC,wBAAwB,CAAC/B,cAAc,CAAC;MAC7C,IAAIA,cAAc,CAACL,oBAAoB,EAAE,EAAE;QACvC7f,GAAG,CAACkiB,eAAe,EAAE;MACzB;IACJ,CAAC,MAAM;MACH,IAAI,CAACL,WAAW,CAAC7hB,GAAG,EAAE,UAASC,IAAI,EAAED,GAAG,EAAEoI,CAAC,EAAEnJ,CAAC,EAAEC,CAAC,EAAE;QAC/Ce,IAAI,CAAC+f,QAAQ,CAAChgB,GAAG,EAAEf,CAAC,EAAEC,CAAC,CAAC;MAC5B,CAAC,CAAC;IACN;EACJ,CAAC;EAEDijB,qBAAqB,EAAE,UAASniB,GAAG,EAAE;IAEjC,IAAI,CAAC6hB,WAAW,CAAC7hB,GAAG,EAAE,UAASC,IAAI,EAAED,GAAG,EAAEiB,MAAM,EAAEhC,CAAC,EAAEC,CAAC,EAAE;MACpDe,IAAI,CAACkiB,qBAAqB,CAACniB,GAAG,EAAEiB,MAAM,EAAEhC,CAAC,EAAEC,CAAC,CAAC;IACjD,CAAC,CAAC;EACN,CAAC;EAEDkjB,iBAAiB,EAAE,UAASpiB,GAAG,EAAE;IAC7B,IAAI,IAAI,CAAC/B,OAAO,CAACkC,kBAAkB,EAAEH,GAAG,CAACqe,cAAc,EAAE;IAEzD,IAAI,IAAI,CAAC2D,sBAAsB,EAAE;MAC7B,IAAI,CAACA,sBAAsB,GAAG,KAAK;MACnC;IACJ;IAEA,IAAI,CAACC,wBAAwB,CAACjiB,GAAG,CAAC;EACtC,CAAC;EAEDiiB,wBAAwB,EAAE,UAASjiB,GAAG,EAAE;IACpC,IAAI,CAAC6hB,WAAW,CAAC7hB,GAAG,EAAE,UAASC,IAAI,EAAED,GAAG,EAAEiB,MAAM,EAAEhC,CAAC,EAAEC,CAAC,EAAE;MACpDe,IAAI,CAACmiB,iBAAiB,CAACpiB,GAAG,EAAEiB,MAAM,EAAEhC,CAAC,EAAEC,CAAC,CAAC;IAC7C,CAAC,CAAC;EACN,CAAC;EAEDmjB,OAAO,EAAE,UAASriB,GAAG,EAAE;IAEnB,IAAIsiB,SAAS,GAAGtiB,GAAG,CAAC0f,aAAa;IACjC,IAAIzf,IAAI,GAAG,IAAI,CAACua,QAAQ,CAAC8H,SAAS,CAAC;IACnC,IAAIriB,IAAI,EAAE;MAEND,GAAG,GAAGjF,cAAc,CAACiF,GAAG,CAAC;MACzB,IAAI,IAAI,CAACD,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;MAE3B,IAAI6b,UAAU,GAAG,IAAI,CAACH,UAAU,CAAC3b,GAAG,CAACse,OAAO,EAAEte,GAAG,CAACue,OAAO,CAAC;MAC1Dte,IAAI,CAACoiB,OAAO,CAACriB,GAAG,EAAE8b,UAAU,CAAC7c,CAAC,EAAE6c,UAAU,CAAC5c,CAAC,CAAC;IACjD;EACJ,CAAC;EAEDqjB,cAAc,CAACviB,GAAG,EAAE;IAChB,MAAMugB,aAAa,GAAGxlB,cAAc,CAACiF,GAAG,CAAC;IACzC,MAAM;MAAEf,CAAC;MAAEC;IAAE,CAAC,GAAG,IAAI,CAACyc,UAAU,CAAC4E,aAAa,CAACjC,OAAO,EAAEiC,aAAa,CAAChC,OAAO,CAAC;IAC9E,OAAO,CAACgC,aAAa,EAAEthB,CAAC,EAAEC,CAAC,CAAC;EAChC,CAAC;EAED+gB,kBAAkB,EAAE,UAAShgB,IAAI,EAAEkJ,IAAI,EAAE;IAErCA,IAAI,KAAKA,IAAI,GAAG,CAAC,CAAC,CAAC;IACnB,IAAI,CAACsV,SAAS,CAAC;MAAEtV,IAAI,EAAEA;IAAK,CAAC,EAAE;MAAEyE,UAAU,EAAE3N,IAAI,IAAI,IAAI;MAAEye,UAAU,EAAE;IAAE,CAAC,CAAC;IAC3E,IAAI,CAAC8D,sBAAsB,CAAC,IAAI,EAAErZ,IAAI,CAAC;EAC3C,CAAC;EAED;EACA;EACApJ,KAAK,EAAE,UAASC,GAAG,EAAEC,IAAI,EAAE;IAEvB,IAAID,GAAG,CAACqO,IAAI,KAAK,WAAW,IAAIrO,GAAG,CAAC+e,MAAM,KAAK,CAAC,EAAE;MAC9C;MACA,OAAO,IAAI;IACf;IAEA,IAAI,IAAI,CAAC9gB,OAAO,CAAC8B,KAAK,IAAI,IAAI,CAAC9B,OAAO,CAAC8B,KAAK,CAACC,GAAG,EAAEC,IAAI,CAAC,EAAE;MACrD,OAAO,IAAI;IACf;IAEA,IAAID,GAAG,CAACmJ,IAAI,IAAInJ,GAAG,CAACmJ,IAAI,CAACsZ,OAAO,KAAKzW,SAAS,EAAE;MAC5C,OAAOhM,GAAG,CAACmJ,IAAI,CAACsZ,OAAO;IAC3B;IAEA,MAAM;MAAE1H;IAAO,CAAC,GAAG/a,GAAG;IAEtB,IAAI,IAAI,CAACmF,iBAAiB,CAACoE,QAAQ,CAACwR,MAAM,CAAChR,OAAO,CAAC,EAAE;MACjD,OAAO,IAAI;IACf;IAEA,IAAI9J,IAAI,IAAIA,IAAI,CAACwF,KAAK,IAAKxF,IAAI,CAACwF,KAAK,YAAYjJ,IAAK,EAAE;MACpD,OAAO,KAAK;IAChB;IAEA,IAAI,IAAI,CAAC6H,GAAG,KAAK0W,MAAM,IAAI,IAAI,CAACzV,EAAE,KAAKyV,MAAM,IAAI/d,CAAC,CAACsiB,QAAQ,CAAC,IAAI,CAACjb,GAAG,EAAE0W,MAAM,CAAC,EAAE;MAC3E,OAAO,KAAK;IAChB;IAEA,OAAO,IAAI,CAAC,CAAI;EACpB,CAAC;;EAED2H,WAAW,EAAE,UAASvjB,QAAQ,EAAE;IAE5B,MAAM;MAAElB;IAAQ,CAAC,GAAG,IAAI;IACxBA,OAAO,CAACkB,QAAQ,GAAGA,QAAQ;IAE3B,IAAIlB,OAAO,CAACmB,QAAQ,IAAI,CAACnB,OAAO,CAACoB,YAAY,EAAE;MAC3C;MACA,IAAI,CAACD,QAAQ,EAAE;IACnB;IAEA,OAAO,IAAI;EACf,CAAC;EAEDujB,SAAS,EAAE,YAAW;IAElB,IAAI,IAAI,CAACje,KAAK,EAAE;MACZ,IAAI,CAACA,KAAK,CAACqP,GAAG,CAAC,iBAAiB,EAAE,MAAM,CAAC;IAC7C;IACA,OAAO,IAAI;EACf,CAAC;EAED6O,YAAY,EAAE,YAAW;IAErB,IAAI,CAAC,IAAI,CAACC,UAAU,EAAE;MAElB,IAAI,CAACA,UAAU,GAAG;QACdC,IAAI,EAAE/oB,CAAC,CAAC,KAAK,EAAE;UAAE+E,KAAK,EAAE,MAAM;UAAEC,MAAM,EAAE;QAAO,CAAC,EAAEhF,CAAC,CAAC,MAAM,CAAC,CAAC;QAC5DgpB,QAAQ,EAAE,CAAC,CAAC;QACZC,GAAG,EAAE,UAASpc,EAAE,EAAE0E,GAAG,EAAE;UACnBvR,CAAC,CAAC,IAAI,CAAC+oB,IAAI,CAACG,IAAI,CAACzY,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC0Y,MAAM,CAAC5X,GAAG,CAAC;UAC3C,IAAI,CAACyX,QAAQ,CAACnc,EAAE,CAAC,GAAG0E,GAAG;UACvB,IAAI,CAACwX,IAAI,CAACI,MAAM,CAACnpB,CAAC,CAAC,MAAM,EAAE;YAAE+E,KAAK,EAAE,MAAM;YAAEC,MAAM,EAAE,MAAM;YAAEokB,IAAI,EAAE,OAAO,GAAGvc,EAAE,GAAG;UAAI,CAAC,CAAC,CAAC;QAC5F,CAAC;QACD0R,GAAG,EAAE,UAAS1R,EAAE,EAAE;UACd,OAAO,IAAI,CAACmc,QAAQ,CAACnc,EAAE,CAAC;QAC5B,CAAC;QACDwc,KAAK,EAAE,UAASxc,EAAE,EAAE;UAChB,OAAO,IAAI,CAACmc,QAAQ,CAACnc,EAAE,CAAC,KAAKoF,SAAS;QAC1C;MACJ,CAAC;IACL;IAEA,OAAO,IAAI,CAAC6W,UAAU;EAC1B,CAAC;EAEDnd,OAAO,EAAE,UAAStG,QAAQ,EAAE;IAExB,IAAI,CAACujB,SAAS,EAAE;IAEhB,IAAI,CAACE,UAAU,GAAG,IAAI;IACtB,IAAI,CAACQ,aAAa,GAAG,EAAE;IAEvB,IAAIC,WAAW,GAAGnR,KAAK,CAACoR,OAAO,CAACnkB,QAAQ,CAAC,GAAGA,QAAQ,GAAG,CAACA,QAAQ,IAAI,CAAC,CAAC,CAAC;IACvEkkB,WAAW,CAACvY,OAAO,CAAC,UAASyY,IAAI,EAAE;MAC/B,IAAI,CAACH,aAAa,CAACpW,IAAI,CAACiL,KAAK,CAAC,IAAI,CAACmL,aAAa,EAAE,IAAI,CAACI,sBAAsB,CAACD,IAAI,CAAC,CAAC;IACxF,CAAC,EAAE,IAAI,CAAC;IACR,OAAO,IAAI;EACf,CAAC;EAEDC,sBAAsB,EAAE,UAAS1gB,GAAG,EAAE;IAElC,IAAI6G,SAAS,GAAG,IAAI,CAAC6T,WAAW,CAACiG,YAAY;IAC7C,IAAI7oB,QAAQ,CAACkI,GAAG,CAAC,IAAIoP,KAAK,CAACoR,OAAO,CAAC3Z,SAAS,CAAC7G,GAAG,CAAC,CAAC,EAAE;MAChD,OAAO6G,SAAS,CAAC7G,GAAG,CAAC,CAAC+X,GAAG,CAAC,UAAS0I,IAAI,EAAE;QACrC,OAAOvpB,MAAM,CAAC,CAAC,CAAC,EAAEupB,IAAI,CAAC;MAC3B,CAAC,CAAC;IACN;IAEA,IAAIvlB,OAAO,GAAG8E,GAAG,IAAI;MAAEiV,IAAI,EAAE,CAAC,CAAC,CAAC;IAAE,CAAC;IACnC,IAAIuL,OAAO,GAAGpR,KAAK,CAACoR,OAAO,CAACtlB,OAAO,CAAC;IACpC,IAAID,IAAI,GAAGC,OAAO,CAACD,IAAI;IAEvB,IAAI,CAACulB,OAAO,IAAI,CAACvlB,IAAI,IAAI,CAACC,OAAO,CAAC0lB,MAAM,EAAE;MACtC3lB,IAAI,GAAG,KAAK;IAChB;IAEA,IAAIA,IAAI,IAAImU,KAAK,CAACoR,OAAO,CAAC3Z,SAAS,CAAC5L,IAAI,CAAC,CAAC,EAAE;MACxC,IAAI4lB,OAAO,GAAGha,SAAS,CAAC5L,IAAI,CAAC,CAAC8c,GAAG,CAAC,UAAS0I,IAAI,EAAE;QAC7C,OAAOvpB,MAAM,CAAC,CAAC,CAAC,EAAEupB,IAAI,CAAC;MAC3B,CAAC,CAAC;MAEF,IAAIxL,IAAI,GAAG7F,KAAK,CAACoR,OAAO,CAACtlB,OAAO,CAAC+Z,IAAI,CAAC,GAAG/Z,OAAO,CAAC+Z,IAAI,GAAG,CAAC/Z,OAAO,CAAC+Z,IAAI,IAAI,CAAC,CAAC,CAAC;MAE5E3d,QAAQ,CAAC2d,IAAI,CAAC,CAAC,CAAC,EAAE7c,IAAI,CAAC4H,GAAG,EAAE,MAAM,CAAC,CAAC;MACpC,KAAK,IAAI0L,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuJ,IAAI,CAACnL,MAAM,EAAE4B,CAAC,EAAE,EAAE;QAClC,IAAImV,OAAO,CAACnV,CAAC,CAAC,EAAE;UACZxU,MAAM,CAAC2pB,OAAO,CAACnV,CAAC,CAAC,EAAEuJ,IAAI,CAACvJ,CAAC,CAAC,CAAC;QAC/B;MACJ;MACA,OAAOmV,OAAO;IAClB;IAEA,OAAOL,OAAO,GAAGtlB,OAAO,GAAG,CAACA,OAAO,CAAC;EACxC,CAAC;EAEDmB,QAAQ,EAAE,UAAS2D,GAAG,EAAE;IAEpB,MAAM5D,QAAQ,GAAG,IAAI,CAAClB,OAAO,CAACoB,YAAY,IAAI,IAAI,CAACpB,OAAO,CAACkB,QAAQ;IACnE,IAAIA,QAAQ,IAAI,CAAC,EAAE;MACf,OAAO,IAAI,CAACwjB,SAAS,EAAE;IAC3B;IAEA,IAAIkB,YAAY,GAAG1R,KAAK,CAACoR,OAAO,CAACxgB,GAAG,CAAC,GAAGA,GAAG,GAAG,CAACA,GAAG,CAAC;IAEnD,IAAIgJ,GAAG,GAAG,IAAI,CAACD,MAAM,EAAE;IACvB,IAAIgY,IAAI,GAAG,IAAI,CAAClB,YAAY,EAAE;IAE9B,IAAI,CAACS,aAAa,CAACtY,OAAO,CAAC,UAASgZ,gBAAgB,EAAEC,KAAK,EAAE;MAEzD,IAAIpd,EAAE,GAAG,UAAU,GAAGod,KAAK;MAC3B,IAAI/lB,OAAO,GAAG5C,KAAK,CAAC0oB,gBAAgB,EAAEF,YAAY,CAACG,KAAK,CAAC,EAAE;QACvDxP,EAAE,EAAEzI,GAAG,CAACgN,CAAC,IAAI,CAAC;QACdtE,EAAE,EAAE1I,GAAG,CAAC+N,CAAC,IAAI,CAAC;QACd7F,EAAE,EAAElI,GAAG,CAACuO,CAAC,IAAI,CAAC;QACdpG,EAAE,EAAEnI,GAAG,CAACwO,CAAC,IAAI;MACjB,CAAC,CAAC;MAEFtc,OAAO,CAACa,KAAK,GAAGK,QAAQ,IAAI4M,GAAG,CAACgN,CAAC,IAAI,CAAC,CAAC,IAAI9a,OAAO,CAACgmB,WAAW,IAAI,CAAC,CAAC;MACpEhmB,OAAO,CAACc,MAAM,GAAGI,QAAQ,IAAI4M,GAAG,CAAC+N,CAAC,IAAI,CAAC,CAAC,IAAI7b,OAAO,CAACgmB,WAAW,IAAI,CAAC,CAAC;MAErE,IAAI,CAACH,IAAI,CAACV,KAAK,CAACxc,EAAE,CAAC,EAAE;QACjBkd,IAAI,CAACd,GAAG,CAACpc,EAAE,EAAE7M,CAAC,CAAC,SAAS,EAAE;UAAE6M,EAAE,EAAEA,EAAE;UAAEsd,YAAY,EAAE;QAAiB,CAAC,EAAEnqB,CAAC,CAACkE,OAAO,CAAC0lB,MAAM,CAAC,CAAC,CAAC;MAC7F;MAEA,IAAIQ,aAAa,GAAGL,IAAI,CAACxL,GAAG,CAAC1R,EAAE,CAAC;MAEhC,IAAInM,UAAU,CAACwD,OAAO,CAACiK,MAAM,CAAC,EAAE;QAC5BjK,OAAO,CAACiK,MAAM,CAACic,aAAa,CAAClB,IAAI,CAACzY,UAAU,CAAC,CAAC,CAAC,EAAEvM,OAAO,CAAC;MAC7D;MAEA,IAAIgB,CAAC,GAAGhB,OAAO,CAACgW,EAAE,GAAGhW,OAAO,CAACa,KAAK;MAClC,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIhB,OAAO,CAACa,KAAK;MAE7B,IAAII,CAAC,GAAGjB,OAAO,CAACiW,EAAE,GAAGjW,OAAO,CAACc,MAAM;MACnC,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIjB,OAAO,CAACc,MAAM;MAE9BolB,aAAa,CAACC,IAAI,CAAC;QACfnlB,CAAC,EAAEA,CAAC;QACJC,CAAC,EAAEA,CAAC;QACJJ,KAAK,EAAEb,OAAO,CAACa,KAAK;QACpBC,MAAM,EAAEd,OAAO,CAACc;MACpB,CAAC,CAAC;IACN,CAAC,CAAC;IAEF,IAAIslB,UAAU,GAAG,IAAIC,aAAa,EAAE,CAACC,iBAAiB,CAACT,IAAI,CAAChB,IAAI,CAACG,IAAI,CAAC;IACtEoB,UAAU,GAAG,gCAAgC,GAAGG,IAAI,CAACH,UAAU,CAAC,GAAG,GAAG;IAEtE,IAAI,CAAC3f,KAAK,CAACqP,GAAG,CAAC,iBAAiB,EAAEsQ,UAAU,CAAC;IAE7C,OAAO,IAAI;EACf,CAAC;EAEDxY,qBAAqB,EAAE,UAAS9I,GAAG,EAAE;IAEjCA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;IAEf,IAAI0hB,kBAAkB,GAAG1hB,GAAG,CAACsF,QAAQ,IAAI,QAAQ;IACjD,IAAIqc,cAAc,GAAG3hB,GAAG,CAAC4hB,IAAI,IAAI,WAAW;IAE5C,IAAIxN,YAAY,GAAG,IAAI,CAACzC,KAAK,EAAE;IAC/B,IAAIuC,gBAAgB,GAAG,IAAI,CAAC9C,SAAS,EAAE;;IAEvC;IACA,IAAIha,QAAQ,CAACsqB,kBAAkB,CAAC,EAAE;MAC9B,IAAIxlB,CAAC,GAAGgY,gBAAgB,CAACvB,EAAE,GAAIyB,YAAY,CAAC3C,EAAE,IAAIiQ,kBAAkB,CAACxlB,CAAC,IAAI,CAAC,CAAE;MAC7E,IAAIC,CAAC,GAAG+X,gBAAgB,CAACrB,EAAE,GAAIuB,YAAY,CAAC1C,EAAE,IAAIgQ,kBAAkB,CAACvlB,CAAC,IAAI,CAAC,CAAE;MAC7EulB,kBAAkB,GAAGxlB,CAAC,GAAG,KAAK,GAAGC,CAAC,GAAG,IAAI;IAC7C;;IAEA;IACA,IAAI/E,QAAQ,CAACuqB,cAAc,CAAC,EAAE;MAC1BA,cAAc,GAAG,IAAI3oB,IAAI,CAAC2oB,cAAc,CAAC,CAAChQ,KAAK,CAACyC,YAAY,CAAC3C,EAAE,EAAE2C,YAAY,CAAC1C,EAAE,CAAC;MACjFiQ,cAAc,GAAGA,cAAc,CAAC5lB,KAAK,GAAG,KAAK,GAAG4lB,cAAc,CAAC3lB,MAAM,GAAG,IAAI;IAChF;IAEA,IAAI,CAACyF,WAAW,CAACuP,GAAG,CAAC;MACjB2Q,cAAc,EAAEA,cAAc;MAC9BD,kBAAkB,EAAEA;IACxB,CAAC,CAAC;EACN,CAAC;EAEDG,mBAAmB,EAAE,UAASC,GAAG,EAAE9hB,GAAG,EAAE;IAEpC;IACA,IAAI,EAAE8hB,GAAG,YAAYC,gBAAgB,CAAC,EAAE;MACpC,IAAI,CAACtgB,WAAW,CAACuP,GAAG,CAAC,iBAAiB,EAAE,EAAE,CAAC;MAC3C;IACJ;IAEA,IAAI,CAAC,IAAI,CAACnI,WAAW,IAAI,IAAI,CAACA,WAAW,CAAChF,EAAE,KAAK7D,GAAG,CAAC6D,EAAE,EAAE;MACrD;MACA;IACJ;IAEA7D,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;IAEf,IAAIgiB,eAAe;IACnB,IAAIL,cAAc,GAAG3hB,GAAG,CAAC4hB,IAAI;IAC7B,IAAIK,gBAAgB,GAAGjiB,GAAG,CAACkiB,MAAM,IAAI,WAAW;IAChD,IAAIC,iBAAiB,GAAGniB,GAAG,CAACoiB,OAAO,IAAI,CAAC;IACxC,IAAIC,iBAAiB,GAAGhY,IAAI,CAACiY,GAAG,CAACtiB,GAAG,CAACuiB,OAAO,CAAC,IAAI,CAAC;IAClD,IAAIC,iBAAiB,GAAG,IAAI,CAAC9H,WAAW,CAAC+H,kBAAkB,CAAClqB,SAAS,CAAC0pB,gBAAgB,CAAC,CAAC;IAExF,IAAIvqB,UAAU,CAAC8qB,iBAAiB,CAAC,EAAE;MAC/B;MACAV,GAAG,CAAC/lB,KAAK,IAAIsmB,iBAAiB;MAC9BP,GAAG,CAAC9lB,MAAM,IAAIqmB,iBAAiB;MAC/B,IAAIK,MAAM,GAAGF,iBAAiB,CAACV,GAAG,EAAE9hB,GAAG,CAAC;MACxC,IAAI,EAAE0iB,MAAM,YAAYC,iBAAiB,CAAC,EAAE;QACxC,MAAM,IAAIrb,KAAK,CAAC,mEAAmE,CAAC;MACxF;MAEA0a,eAAe,GAAGU,MAAM,CAACE,SAAS,CAAC,WAAW,CAAC;MAC/CX,gBAAgB,GAAG,QAAQ;MAC3B,IAAI7qB,QAAQ,CAACuqB,cAAc,CAAC,EAAE;QAC1B;QACAA,cAAc,CAAC5lB,KAAK,IAAI2mB,MAAM,CAAC3mB,KAAK,GAAG+lB,GAAG,CAAC/lB,KAAK;QAChD4lB,cAAc,CAAC3lB,MAAM,IAAI0mB,MAAM,CAAC1mB,MAAM,GAAG8lB,GAAG,CAAC9lB,MAAM;MACvD,CAAC,MAAM,IAAI2lB,cAAc,KAAK1Y,SAAS,EAAE;QACrC;QACAjJ,GAAG,CAAC4hB,IAAI,GAAG;UACP7lB,KAAK,EAAE2mB,MAAM,CAAC3mB,KAAK,GAAGsmB,iBAAiB;UACvCrmB,MAAM,EAAE0mB,MAAM,CAAC1mB,MAAM,GAAGqmB;QAC5B,CAAC;MACL;IACJ,CAAC,MAAM;MACH;MACA;MACAL,eAAe,GAAGF,GAAG,CAACe,GAAG;MACzB,IAAIlB,cAAc,KAAK1Y,SAAS,EAAE;QAC9B;QACAjJ,GAAG,CAAC4hB,IAAI,GAAG;UACP7lB,KAAK,EAAE+lB,GAAG,CAAC/lB,KAAK;UAChBC,MAAM,EAAE8lB,GAAG,CAAC9lB;QAChB,CAAC;MACL;IACJ;IAEA,IAAI,CAACyF,WAAW,CAACuP,GAAG,CAAC;MACjBoR,OAAO,EAAED,iBAAiB;MAC1BF,gBAAgB,EAAEA,gBAAgB;MAClCD,eAAe,EAAE,MAAM,GAAGA,eAAe,GAAG;IAChD,CAAC,CAAC;IAEF,IAAI,CAAClZ,qBAAqB,CAAC9I,GAAG,CAAC;EACnC,CAAC;EAED8iB,qBAAqB,EAAE,UAASC,KAAK,EAAE;IAEnC,IAAI,CAAChS,GAAG,CAACC,GAAG,CAAC,iBAAiB,EAAE+R,KAAK,IAAI,EAAE,CAAC;EAChD,CAAC;EAEDjb,cAAc,EAAE,UAAS9H,GAAG,EAAE;IAE1BA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;IAEf,IAAI,CAAC8iB,qBAAqB,CAAC9iB,GAAG,CAAC+iB,KAAK,CAAC;IAErC,IAAI/iB,GAAG,CAACgjB,KAAK,EAAE;MACXhjB,GAAG,GAAG,IAAI,CAAC6I,WAAW,GAAGrQ,SAAS,CAACwH,GAAG,CAAC;MACvCjI,IAAI,CAACiI,GAAG,CAAC;MACT,IAAI8hB,GAAG,GAAGmB,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;MACvCpB,GAAG,CAACqB,MAAM,GAAG,IAAI,CAACtB,mBAAmB,CAACuB,IAAI,CAAC,IAAI,EAAEtB,GAAG,EAAE9hB,GAAG,CAAC;MAC1D8hB,GAAG,CAACe,GAAG,GAAG7iB,GAAG,CAACgjB,KAAK;IACvB,CAAC,MAAM;MACH,IAAI,CAACnB,mBAAmB,CAAC,IAAI,CAAC;MAC9B,IAAI,CAAChZ,WAAW,GAAG,IAAI;IAC3B;IAEA,OAAO,IAAI;EACf,CAAC;EAEDwa,gBAAgB,EAAE,UAASC,KAAK,EAAE;IAE9B,IAAI,CAACpoB,OAAO,CAACiE,WAAW,GAAGmkB,KAAK;IAEhC7qB,MAAM,CAAC,IAAI,CAACuK,MAAM,EAAE,kBAAkB,EAAEsgB,KAAK,CAAC;EAClD,CAAC;EAED;EACA;;EAEAC,SAAS,EAAE,UAASC,KAAK,EAAE;IAEvB,OAAO,CAAC,CAAC,IAAI,CAACliB,GAAG,CAACmiB,cAAc,CAACD,KAAK,CAAC;EAC3C,CAAC;EAEDE,YAAY,EAAE,UAAS/qB,MAAM,EAAE;IAE3B,IAAI,CAACvB,QAAQ,CAACuB,MAAM,CAAC,EAAE;MACnB,MAAM,IAAIgrB,SAAS,CAAC,iEAAiE,CAAC;IAC1F;IAEA,IAAIC,QAAQ,GAAGjrB,MAAM,CAACkL,EAAE;IACxB,IAAI5I,IAAI,GAAGtC,MAAM,CAACsC,IAAI;IACtB;IACA;IACA,IAAI,CAAC2oB,QAAQ,EAAE;MACXA,QAAQ,GAAG3oB,IAAI,GAAG,IAAI,CAACqG,GAAG,CAACuC,EAAE,GAAGnL,QAAQ,CAACmrB,IAAI,CAACC,SAAS,CAACnrB,MAAM,CAAC,CAAC;IACpE;IACA;IACA;IACA;IACA,IAAI,CAAC,IAAI,CAAC4qB,SAAS,CAACK,QAAQ,CAAC,EAAE;MAE3B,IAAI/c,SAAS,GAAGjO,OAAO;MACvB,IAAImrB,eAAe,GAAGld,SAAS,CAAC5L,IAAI,CAAC,IAAI4L,SAAS,CAAC5L,IAAI,CAAC,CAACtC,MAAM,CAACsc,IAAI,IAAI,CAAC,CAAC,CAAC;MAC3E,IAAI,CAAC8O,eAAe,EAAE;QAClB,MAAM,IAAIzc,KAAK,CAAC,sBAAsB,GAAGrM,IAAI,CAAC;MAClD;;MAEA;MACA;MACA,IAAI+oB,WAAW,GAAG9sB,MAAM,CAAC;QACrB+sB,WAAW,EAAE,mBAAmB;QAChC/nB,CAAC,EAAE,CAAC,CAAC;QACLC,CAAC,EAAE,CAAC,CAAC;QACLJ,KAAK,EAAE,CAAC;QACRC,MAAM,EAAE;MACZ,CAAC,EAAErD,MAAM,CAACurB,KAAK,EAAE;QACbrgB,EAAE,EAAE+f;MACR,CAAC,CAAC;MAEF5sB,CAAC,CAAC+sB,eAAe,EAAEC,WAAW,CAAC,CAACG,QAAQ,CAAC,IAAI,CAAC5iB,IAAI,CAAC;IACvD;IAEA,OAAOqiB,QAAQ;EACnB,CAAC;EAEDQ,cAAc,EAAE,UAASC,QAAQ,EAAE;IAC/B,IAAI,CAACjtB,QAAQ,CAACitB,QAAQ,CAAC,EAAE;MACrB,MAAM,IAAIV,SAAS,CAAC,mEAAmE,CAAC;IAC5F;IACA,MAAM;MAAEriB,GAAG;MAAEC;IAAK,CAAC,GAAG,IAAI;IAC1B,MAAM;MACF+J,IAAI;MACJ;MACA;MACAzH,EAAE,GAAGyH,IAAI,GAAGhK,GAAG,CAACuC,EAAE,GAAGnL,QAAQ,CAACmrB,IAAI,CAACC,SAAS,CAACO,QAAQ,CAAC,CAAC;MACvDC,KAAK;MACLJ,KAAK,GAAG,CAAC;IACb,CAAC,GAAGG,QAAQ;IACZ;IACA;IACA,IAAI,IAAI,CAACd,SAAS,CAAC1f,EAAE,CAAC,EAAE,OAAOA,EAAE;IACjC;IACA,MAAM0gB,QAAQ,GAAGzrB,OAAO,CAACwrB,KAAK,CAAC,CAACvM,GAAG,CAAC,CAAC;MAAE6B,MAAM;MAAEmJ,KAAK;MAAEX;IAAQ,CAAC,KAAK;MAChE,OAAOprB,CAAC,CAAC,MAAM,CAAC,CAACqqB,IAAI,CAAC;QAClB,QAAQ,EAAEzH,MAAM;QAChB,YAAY,EAAEmJ,KAAK;QACnB,cAAc,EAAEhR,MAAM,CAACyS,QAAQ,CAACpC,OAAO,CAAC,GAAGA,OAAO,GAAG;MACzD,CAAC,CAAC;IACN,CAAC,CAAC;IACF,MAAMqC,WAAW,GAAGztB,CAAC,CAACsU,IAAI,EAAE4Y,KAAK,EAAEK,QAAQ,CAAC;IAC5CE,WAAW,CAAC5gB,EAAE,GAAGA,EAAE;IACnB4gB,WAAW,CAACN,QAAQ,CAAC5iB,IAAI,CAAC;IAC1B,OAAOsC,EAAE;EACb,CAAC;EAED6gB,aAAa,EAAE,UAAS7D,OAAO,EAAE;IAC7B,IAAI,CAACzpB,QAAQ,CAACypB,OAAO,CAAC,EAAE;MACpB,MAAM,IAAI8C,SAAS,CAAC,kEAAkE,CAAC;IAC3F;IACA,MAAM;MAAEriB,GAAG;MAAEC;IAAK,CAAC,GAAG,IAAI;IAC1B,MAAM;MACF;MACA;MACAsC,EAAE,GAAGvC,GAAG,CAACuC,EAAE,GAAGnL,QAAQ,CAACmrB,IAAI,CAACC,SAAS,CAACjD,OAAO,CAAC,CAAC;MAC/CD,MAAM;MACNsD,KAAK,GAAG,CAAC;IACb,CAAC,GAAGrD,OAAO;IACX,IAAI,CAACD,MAAM,EAAE;MACT,MAAM,IAAI+C,SAAS,CAAC,6CAA6C,CAAC;IACtE;IACA;IACA;IACA,IAAI,IAAI,CAACJ,SAAS,CAAC1f,EAAE,CAAC,EAAE,OAAOA,EAAE;IACjC;IACA,MAAM8gB,UAAU,GAAG3tB,CAAC,CAAC,SAAS,EAAE;MAC5BmqB,YAAY,EAAE;IAClB,CAAC,CAAC;IACFwD,UAAU,CAAC9gB,EAAE,GAAGA,EAAE;IAClB8gB,UAAU,CAACtD,IAAI,CAAC6C,KAAK,CAAC;IACtB,IAAI,OAAOtD,MAAM,KAAK,QAAQ,EAAE;MAC5B+D,UAAU,CAACxE,MAAM,CAACnpB,CAAC,CAAC4pB,MAAM,CAAC,CAAC;IAChC,CAAC,MAAM;MACH,MAAM;QAAEgE;MAAS,CAAC,GAAG/rB,YAAY,CAAC+nB,MAAM,CAAC;MACzC+D,UAAU,CAACxE,MAAM,CAACyE,QAAQ,CAAC;IAC/B;IACAD,UAAU,CAACR,QAAQ,CAAC5iB,IAAI,CAAC;IACzB,OAAOsC,EAAE;EACb,CAAC;EAEDghB,YAAY,EAAE,UAASC,MAAM,EAAE;IAC3B,IAAI,CAAC1tB,QAAQ,CAAC0tB,MAAM,CAAC,EAAE;MACnB,MAAM,IAAInB,SAAS,CAAC,wEAAwE,CAAC;IACjG;IACA,MAAM;MAAEriB,GAAG;MAAEC;IAAK,CAAC,GAAG,IAAI;IAC1B,MAAM;MACF;MACA;MACAsC,EAAE,GAAGvC,GAAG,CAACuC,EAAE,GAAGnL,QAAQ,CAACmrB,IAAI,CAACC,SAAS,CAACgB,MAAM,CAAC,CAAC;MAC9C;MACA;MACAlE,MAAM;MACN;MACA;MACA;MACAsD,KAAK,GAAG,CAAC,CAAC;MACV;MACAa,WAAW,GAAG;IAClB,CAAC,GAAGD,MAAM;IACV;IACA;IACA,IAAI,IAAI,CAACvB,SAAS,CAAC1f,EAAE,CAAC,EAAE,OAAOA,EAAE;IACjC;IACA,MAAMmhB,SAAS,GAAGhuB,CAAC,CAAC,QAAQ,EAAE;MAC1BiuB,MAAM,EAAE,MAAM;MACd9jB,QAAQ,EAAE,SAAS;MACnB4jB,WAAW,EAAEA;IACjB,CAAC,CAAC;IACFC,SAAS,CAACnhB,EAAE,GAAGA,EAAE;IACjBmhB,SAAS,CAAC3D,IAAI,CAAC6C,KAAK,CAAC;IACrB,IAAIgB,gBAAgB;IACpB,IAAItE,MAAM,EAAE;MACR,IAAIuE,SAAS;MACb,IAAI,OAAOvE,MAAM,KAAK,QAAQ,EAAE;QAC5B;QACA;QACAuE,SAAS,GAAGnuB,CAAC,CAAC4pB,MAAM,CAAC;QACrB;QACA;QACAuE,SAAS,GAAI/V,KAAK,CAACoR,OAAO,CAAC2E,SAAS,CAAC,GAAGA,SAAS,GAAG,CAACA,SAAS,CAAE;MACpE,CAAC,MAAM;QACH;QACA;QACA,MAAM;UAAEP;QAAS,CAAC,GAAG/rB,YAAY,CAAC+nB,MAAM,CAAC;QACzCuE,SAAS,GAAGnuB,CAAC,CAAC4tB,QAAQ,CAAC,CAACje,QAAQ,EAAE;MACtC;MACA;MACA;MACA,IAAIwe,SAAS,CAACrb,MAAM,GAAG,CAAC,EAAE;QACtBob,gBAAgB,GAAGluB,CAAC,CAAC,GAAG,CAAC,CAACmpB,MAAM,CAACgF,SAAS,CAAC;MAC/C,CAAC,MAAM;QACHD,gBAAgB,GAAGC,SAAS,CAAC,CAAC,CAAC;MACnC;IACJ,CAAC,MAAM;MACH;MACA;MACA,MAAM;QAAE7Z,IAAI,GAAG;MAAO,CAAC,GAAGwZ,MAAM;MAChCI,gBAAgB,GAAGluB,CAAC,CAACsU,IAAI,CAAC;IAC9B;IACA;IACA;IACA;IACA,MAAM8Z,WAAW,GAAGhtB,IAAI,CAAC0sB,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,aAAa,CAAC;IAChF,MAAMO,eAAe,GAAG5c,MAAM,CAACC,IAAI,CAAC0c,WAAW,CAAC;IAChDC,eAAe,CAACrd,OAAO,CAAEtC,GAAG,IAAK;MAC7B,MAAM4d,KAAK,GAAG8B,WAAW,CAAC1f,GAAG,CAAC;MAC9B,MAAM4f,WAAW,GAAGJ,gBAAgB,CAAC7D,IAAI,CAAC3b,GAAG,CAAC,CAAC,CAAC;MAChD,IAAI4f,WAAW,IAAI,IAAI,EAAE;QACrB;QACAJ,gBAAgB,CAAC7D,IAAI,CAAC3b,GAAG,EAAE4d,KAAK,CAAC;MACrC,CAAC,MAAM;QACH;QACA,QAAO5d,GAAG;UACN,KAAK,WAAW;YACZ;YACAwf,gBAAgB,CAAC7D,IAAI,CAAC3b,GAAG,EAAG4d,KAAK,GAAG,GAAG,GAAGgC,WAAW,CAAE;YACvD;QAAM;MAElB;IACJ,CAAC,CAAC;IACFJ,gBAAgB,CAACf,QAAQ,CAACa,SAAS,CAAC;IACpCA,SAAS,CAACb,QAAQ,CAAC5iB,IAAI,CAAC;IACxB,OAAOsC,EAAE;EACb;AAEJ,CAAC,EAAE;EAECnE,OAAO,EAAEvF,YAAY;EAErBorB,MAAM,EAAE5rB,WAAW;EAEnB8oB,kBAAkB,EAAE;IAEhB+C,MAAM,EAAE,UAAS1D,GAAG,EAAE;MAClB;MACA;;MAEA,IAAIY,MAAM,GAAGO,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;MAC7C,IAAIuC,QAAQ,GAAG3D,GAAG,CAAC/lB,KAAK;MACxB,IAAI2pB,SAAS,GAAG5D,GAAG,CAAC9lB,MAAM;MAE1B0mB,MAAM,CAAC3mB,KAAK,GAAG,CAAC,GAAG0pB,QAAQ;MAC3B/C,MAAM,CAAC1mB,MAAM,GAAG,CAAC,GAAG0pB,SAAS;MAE7B,IAAIC,GAAG,GAAGjD,MAAM,CAACkD,UAAU,CAAC,IAAI,CAAC;MACjC;MACAD,GAAG,CAACE,SAAS,CAAC/D,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE2D,QAAQ,EAAEC,SAAS,CAAC;MAC7C;MACAC,GAAG,CAACG,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAEpD,MAAM,CAAC3mB,KAAK,EAAE2mB,MAAM,CAAC1mB,MAAM,CAAC;MAC3D2pB,GAAG,CAACE,SAAS,CAAC/D,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE2D,QAAQ,EAAEC,SAAS,CAAC;MAC7C;MACAC,GAAG,CAACG,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEpD,MAAM,CAAC3mB,KAAK,EAAE,CAAC,CAAC;MAC9C4pB,GAAG,CAACE,SAAS,CAAC/D,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE2D,QAAQ,EAAEC,SAAS,CAAC;MAC7C;MACAC,GAAG,CAACG,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAEpD,MAAM,CAAC1mB,MAAM,CAAC;MAC/C2pB,GAAG,CAACE,SAAS,CAAC/D,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE2D,QAAQ,EAAEC,SAAS,CAAC;MAE7C,OAAOhD,MAAM;IACjB,CAAC;IAEDqD,KAAK,EAAE,UAASjE,GAAG,EAAE;MACjB;MACA;;MAEA,IAAIY,MAAM,GAAGO,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;MAC7C,IAAIuC,QAAQ,GAAG3D,GAAG,CAAC/lB,KAAK;MACxB,IAAI2pB,SAAS,GAAG5D,GAAG,CAAC9lB,MAAM;MAE1B0mB,MAAM,CAAC3mB,KAAK,GAAG0pB,QAAQ,GAAG,CAAC;MAC3B/C,MAAM,CAAC1mB,MAAM,GAAG0pB,SAAS;MAEzB,IAAIC,GAAG,GAAGjD,MAAM,CAACkD,UAAU,CAAC,IAAI,CAAC;MACjC;MACAD,GAAG,CAACE,SAAS,CAAC/D,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE2D,QAAQ,EAAEC,SAAS,CAAC;MAC7C;MACAC,GAAG,CAACvU,SAAS,CAAC,CAAC,GAAGqU,QAAQ,EAAE,CAAC,CAAC;MAC9BE,GAAG,CAAChU,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;MAChBgU,GAAG,CAACE,SAAS,CAAC/D,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE2D,QAAQ,EAAEC,SAAS,CAAC;MAE7C,OAAOhD,MAAM;IACjB,CAAC;IAEDsD,KAAK,EAAE,UAASlE,GAAG,EAAE;MACjB;MACA;;MAEA,IAAIY,MAAM,GAAGO,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;MAC7C,IAAIuC,QAAQ,GAAG3D,GAAG,CAAC/lB,KAAK;MACxB,IAAI2pB,SAAS,GAAG5D,GAAG,CAAC9lB,MAAM;MAE1B0mB,MAAM,CAAC3mB,KAAK,GAAG0pB,QAAQ;MACvB/C,MAAM,CAAC1mB,MAAM,GAAG0pB,SAAS,GAAG,CAAC;MAE7B,IAAIC,GAAG,GAAGjD,MAAM,CAACkD,UAAU,CAAC,IAAI,CAAC;MACjC;MACAD,GAAG,CAACE,SAAS,CAAC/D,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE2D,QAAQ,EAAEC,SAAS,CAAC;MAC7C;MACAC,GAAG,CAACvU,SAAS,CAAC,CAAC,EAAE,CAAC,GAAGsU,SAAS,CAAC;MAC/BC,GAAG,CAAChU,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAChBgU,GAAG,CAACE,SAAS,CAAC/D,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE2D,QAAQ,EAAEC,SAAS,CAAC;MAE7C,OAAOhD,MAAM;IACjB,CAAC;IAEDuD,SAAS,EAAE,UAASnE,GAAG,EAAE9hB,GAAG,EAAE;MAC1B;MACA;;MAEAA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;MAEf,IAAIylB,QAAQ,GAAG3D,GAAG,CAAC/lB,KAAK;MACxB,IAAI2pB,SAAS,GAAG5D,GAAG,CAAC9lB,MAAM;MAE1B,IAAI0mB,MAAM,GAAGO,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;MAC7CR,MAAM,CAAC3mB,KAAK,GAAG0pB,QAAQ,GAAG,CAAC;MAC3B/C,MAAM,CAAC1mB,MAAM,GAAG0pB,SAAS,GAAG,CAAC;MAE7B,IAAIC,GAAG,GAAGjD,MAAM,CAACkD,UAAU,CAAC,IAAI,CAAC;MACjC,IAAI3O,KAAK,GAAGhgB,QAAQ,CAAC+I,GAAG,CAACkmB,cAAc,CAAC,GAAG,CAAClmB,GAAG,CAACkmB,cAAc,GAAG,CAAC,EAAE;MACpE,IAAIC,OAAO,GAAGjtB,KAAK,CAAC+d,KAAK,CAAC;MAC1B,IAAImP,KAAK,GAAG1D,MAAM,CAAC3mB,KAAK,GAAG,CAAC;MAC5B,IAAIsqB,KAAK,GAAG3D,MAAM,CAAC1mB,MAAM,GAAG,CAAC;MAE7B,KAAK,IAAI0P,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACxB,KAAK,IAAI9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;UACxB,IAAI,CAAC8B,CAAC,GAAG9B,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YACjB;YACA+b,GAAG,CAACG,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAGpa,CAAC,GAAG,CAAC,IAAI0a,KAAK,EAAE,CAAC,CAAC,GAAGxc,CAAC,GAAG,CAAC,IAAIyc,KAAK,CAAC;YACtEV,GAAG,CAAC3O,MAAM,CAACmP,OAAO,CAAC;YACnBR,GAAG,CAACE,SAAS,CAAC/D,GAAG,EAAE,CAAC2D,QAAQ,GAAG,CAAC,EAAE,CAACC,SAAS,GAAG,CAAC,EAAED,QAAQ,EAAEC,SAAS,CAAC;UAC1E;QACJ;MACJ;MAEA,OAAOhD,MAAM;IACjB;EACJ,CAAC;EAED/B,YAAY,EAAE;IACV2F,GAAG,EAAE,CAAC;MACFvD,KAAK,EAAE,SAAS;MAChBwD,SAAS,EAAE,CAAC;MACZ3F,MAAM,EAAE,MAAM;MACdzb,MAAM,EAAE,UAAS5C,EAAE,EAAEvC,GAAG,EAAE;QACtBhJ,CAAC,CAACuL,EAAE,CAAC,CAAC8e,IAAI,CAAC;UACPtlB,KAAK,EAAEiE,GAAG,CAACumB,SAAS,GAAGvmB,GAAG,CAACyR,EAAE;UAC7BzV,MAAM,EAAEgE,GAAG,CAACumB,SAAS,GAAGvmB,GAAG,CAAC0R,EAAE;UAC9B0O,IAAI,EAAEpgB,GAAG,CAAC+iB;QACd,CAAC,CAAC;MACN;IACJ,CAAC,CAAC;IACFyD,QAAQ,EAAE,CAAC;MACPzD,KAAK,EAAE,SAAS;MAChBwD,SAAS,EAAE,CAAC;MACZ3F,MAAM,EAAE,MAAM;MACdzb,MAAM,EAAE,UAAS5C,EAAE,EAAEvC,GAAG,EAAE;QACtB,IAAI4hB,IAAI,GAAG5hB,GAAG,CAACyR,EAAE,IAAI,CAAC,GAAGzR,GAAG,CAACumB,SAAS,GAAGvmB,GAAG,CAACyR,EAAE,GAAGzR,GAAG,CAACumB,SAAS;QAC/DvvB,CAAC,CAACuL,EAAE,CAAC,CAAC8e,IAAI,CAAC;UAAEtlB,KAAK,EAAE6lB,IAAI;UAAE5lB,MAAM,EAAE4lB,IAAI;UAAExB,IAAI,EAAEpgB,GAAG,CAAC+iB;QAAM,CAAC,CAAC;MAC9D;IACJ,CAAC,CAAC;IACF0D,IAAI,EAAE,CAAC;MACH1D,KAAK,EAAE,SAAS;MAChBwD,SAAS,EAAE,CAAC;MACZ3F,MAAM,EAAE,MAAM;MACdzb,MAAM,EAAE,UAAS5C,EAAE,EAAEvC,GAAG,EAAE;QAEtB,IAAI+W,CAAC;QACL,IAAIhb,KAAK,GAAGiE,GAAG,CAACjE,KAAK;QACrB,IAAIC,MAAM,GAAGgE,GAAG,CAAChE,MAAM;QACvB,IAAIuqB,SAAS,GAAGvmB,GAAG,CAACumB,SAAS;QAE7B,IAAIxqB,KAAK,GAAGwqB,SAAS,IAAI,CAAC,IAAIvqB,MAAM,GAAGuqB,SAAS,IAAI,CAAC,EAAE;UACnDxP,CAAC,GAAG,CAAC,GAAG,EAAEhb,KAAK,EAAE,CAAC,EAAE,YAAY,EAAEC,MAAM,CAAC,CAAC0qB,IAAI,CAAC,GAAG,CAAC;QACvD,CAAC,MAAM;UACH3P,CAAC,GAAG,WAAW;QACnB;QAEA/f,CAAC,CAACuL,EAAE,CAAC,CAAC8e,IAAI,CAAC;UAAE,GAAG,EAAEtK,CAAC;UAAE4P,MAAM,EAAE3mB,GAAG,CAAC+iB,KAAK;UAAE,cAAc,EAAE/iB,GAAG,CAACumB;QAAU,CAAC,CAAC;MAC5E;IACJ,CAAC,CAAC;IACFK,UAAU,EAAE,CAAC;MACT7D,KAAK,EAAE,SAAS;MAChBwD,SAAS,EAAE,CAAC;MACZ3F,MAAM,EAAE,MAAM;MACdzb,MAAM,EAAE,UAAS5C,EAAE,EAAEvC,GAAG,EAAE;QAEtB,IAAI+W,CAAC;QACL,IAAIhb,KAAK,GAAGiE,GAAG,CAACjE,KAAK;QACrB,IAAIC,MAAM,GAAGgE,GAAG,CAAChE,MAAM;QACvB,IAAIuqB,SAAS,GAAGvmB,GAAG,CAACumB,SAAS;QAE7B,IAAIxqB,KAAK,GAAGwqB,SAAS,IAAI,CAAC,IAAIvqB,MAAM,GAAGuqB,SAAS,IAAI,CAAC,EAAE;UACnDxP,CAAC,GAAG,CAAC,GAAG,EAAEhb,KAAK,EAAE,CAAC,EAAE,YAAY,EAAEC,MAAM,CAAC,CAAC0qB,IAAI,CAAC,GAAG,CAAC;QACvD,CAAC,MAAM;UACH3P,CAAC,GAAG,WAAW;QACnB;QAEA/f,CAAC,CAACuL,EAAE,CAAC,CAAC8e,IAAI,CAAC;UAAE,GAAG,EAAEtK,CAAC;UAAE4P,MAAM,EAAE3mB,GAAG,CAAC+iB,KAAK;UAAE,cAAc,EAAE/iB,GAAG,CAACumB;QAAU,CAAC,CAAC;MAC5E;IACJ,CAAC,EAAE;MACCxD,KAAK,EAAE,SAAS;MAChBwD,SAAS,EAAE,CAAC;MACZrF,WAAW,EAAE,CAAC;MACdN,MAAM,EAAE,MAAM;MACdzb,MAAM,EAAE,UAAS5C,EAAE,EAAEvC,GAAG,EAAE;QAEtB,IAAI+W,CAAC;QACL,IAAIhb,KAAK,GAAGiE,GAAG,CAACjE,KAAK;QACrB,IAAIC,MAAM,GAAGgE,GAAG,CAAChE,MAAM;QACvB,IAAIuqB,SAAS,GAAGvmB,GAAG,CAACumB,SAAS;QAE7B,IAAIxqB,KAAK,GAAGwqB,SAAS,IAAI,CAAC,IAAIvqB,MAAM,GAAGuqB,SAAS,IAAI,CAAC,EAAE;UACnDxP,CAAC,GAAG,CAAC,GAAG,EAAEhb,KAAK,EAAE,CAAC,EAAE,YAAY,EAAEC,MAAM,CAAC,CAAC0qB,IAAI,CAAC,GAAG,CAAC;QACvD,CAAC,MAAM;UACH3P,CAAC,GAAG,WAAW;QACnB;QAEA/f,CAAC,CAACuL,EAAE,CAAC,CAAC8e,IAAI,CAAC;UAAE,GAAG,EAAEtK,CAAC;UAAE4P,MAAM,EAAE3mB,GAAG,CAAC+iB,KAAK;UAAE,cAAc,EAAE/iB,GAAG,CAACumB;QAAU,CAAC,CAAC;MAC5E;IACJ,CAAC;EACL;AACJ,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}