{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n// default radius\nvar RADIUS = 0;\n\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = ['smooth'];\n\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\n\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\nfunction createLines(sourcePoint, targetPoint, route) {\n  // make a flattened array of all points\n  var points = [].concat(sourcePoint, route, targetPoint);\n  return points.reduce(function (resultLines, point, idx) {\n    // if there is a next point, make a line with it\n    var nextPoint = points[idx + 1];\n    if (nextPoint != null) {\n      resultLines[idx] = g.line(point, nextPoint);\n    }\n    return resultLines;\n  }, []);\n}\nfunction setupUpdating(jumpOverLinkView) {\n  var paper = jumpOverLinkView.paper;\n  var updateList = paper._jumpOverUpdateList;\n\n  // first time setup for this paper\n  if (updateList == null) {\n    updateList = paper._jumpOverUpdateList = [];\n    var graph = paper.model;\n    graph.on('batch:stop', function () {\n      if (this.hasActiveBatch()) return;\n      updateJumpOver(paper);\n    });\n    graph.on('reset', function () {\n      updateList = paper._jumpOverUpdateList = [];\n    });\n  }\n\n  // add this link to a list so it can be updated when some other link is updated\n  if (updateList.indexOf(jumpOverLinkView) < 0) {\n    updateList.push(jumpOverLinkView);\n\n    // watch for change of connector type or removal of link itself\n    // to remove the link from a list of jump over connectors\n    jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function () {\n      updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n    });\n  }\n}\n\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\nfunction updateJumpOver(paper) {\n  var updateList = paper._jumpOverUpdateList;\n  for (var i = 0; i < updateList.length; i++) {\n    const linkView = updateList[i];\n    const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n    linkView.requestUpdate(updateFlag);\n  }\n}\n\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\nfunction findLineIntersections(line, crossCheckLines) {\n  return util.toArray(crossCheckLines).reduce(function (res, crossCheckLine) {\n    var intersection = line.intersection(crossCheckLine);\n    if (intersection) {\n      res.push(intersection);\n    }\n    return res;\n  }, []);\n}\n\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\nfunction sortPoints(p1, p2) {\n  return g.line(p1, p2).squaredLength();\n}\n\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\nfunction createJumps(line, intersections, jumpSize) {\n  return intersections.reduce(function (resultLines, point, idx) {\n    // skipping points that were merged with the previous line\n    // to make bigger arc over multiple lines that are close to each other\n    if (point.skip === true) {\n      return resultLines;\n    }\n\n    // always grab the last line from buffer and modify it\n    var lastLine = resultLines.pop() || line;\n\n    // calculate start and end of jump by moving by a given size of jump\n    var jumpStart = g.point(point).move(lastLine.start, -jumpSize);\n    var jumpEnd = g.point(point).move(lastLine.start, +jumpSize);\n\n    // now try to look at the next intersection point\n    var nextPoint = intersections[idx + 1];\n    if (nextPoint != null) {\n      var distance = jumpEnd.distance(nextPoint);\n      if (distance <= jumpSize) {\n        // next point is close enough, move the jump end by this\n        // difference and mark the next point to be skipped\n        jumpEnd = nextPoint.move(lastLine.start, distance);\n        nextPoint.skip = true;\n      }\n    } else {\n      // this block is inside of `else` as an optimization so the distance is\n      // not calculated when we know there are no other intersection points\n      var endDistance = jumpStart.distance(lastLine.end);\n      // if the end is too close to possible jump, draw remaining line instead of a jump\n      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n        resultLines.push(lastLine);\n        return resultLines;\n      }\n    }\n    var startDistance = jumpEnd.distance(lastLine.start);\n    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n      // if the start of line is too close to jump, draw that line instead of a jump\n      resultLines.push(lastLine);\n      return resultLines;\n    }\n\n    // finally create a jump line\n    var jumpLine = g.line(jumpStart, jumpEnd);\n    // it's just simple line but with a `isJump` property\n    jumpLine.isJump = true;\n    resultLines.push(g.line(lastLine.start, jumpStart), jumpLine, g.line(jumpEnd, lastLine.end));\n    return resultLines;\n  }, []);\n}\n\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n  var path = new g.Path();\n  var segment;\n\n  // first move to the start of a first line\n  segment = g.Path.createSegment('M', lines[0].start);\n  path.appendSegment(segment);\n\n  // make a paths from lines\n  util.toArray(lines).forEach(function (line, index) {\n    if (line.isJump) {\n      var angle, diff;\n      var control1, control2;\n      if (jumpType === 'arc') {\n        // approximates semicircle with 2 curves\n        angle = -90;\n        // determine rotation of arc based on difference between points\n        diff = line.start.difference(line.end);\n        // make sure the arc always points up (or right)\n        var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n        if (xAxisRotate) angle += 180;\n        var midpoint = line.midpoint();\n        var centerLine = new g.Line(midpoint, line.end).rotate(midpoint, angle);\n        var halfLine;\n\n        // first half\n        halfLine = new g.Line(line.start, midpoint);\n        control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n        control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n        segment = g.Path.createSegment('C', control1, control2, centerLine.end);\n        path.appendSegment(segment);\n\n        // second half\n        halfLine = new g.Line(midpoint, line.end);\n        control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n        control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n        segment = g.Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'gap') {\n        segment = g.Path.createSegment('M', line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'cubic') {\n        // approximates semicircle with 1 curve\n        angle = line.start.theta(line.end);\n        var xOffset = jumpSize * 0.6;\n        var yOffset = jumpSize * 1.35;\n\n        // determine rotation of arc based on difference between points\n        diff = line.start.difference(line.end);\n        // make sure the arc always points up (or right)\n        xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n        if (xAxisRotate) yOffset *= -1;\n        control1 = g.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n        control2 = g.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n        segment = g.Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      }\n    } else {\n      var nextLine = lines[index + 1];\n      if (radius == 0 || !nextLine || nextLine.isJump) {\n        segment = g.Path.createSegment('L', line.end);\n        path.appendSegment(segment);\n      } else {\n        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n      }\n    }\n  });\n  return path;\n}\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n  var prevDistance = curr.distance(prev) / 2;\n  var nextDistance = curr.distance(next) / 2;\n  var startMove = -Math.min(offset, prevDistance);\n  var endMove = -Math.min(offset, nextDistance);\n  var roundedStart = curr.clone().move(prev, startMove).round();\n  var roundedEnd = curr.clone().move(next, endMove).round();\n  var control1 = new g.Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);\n  var control2 = new g.Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);\n  var segment;\n  segment = g.Path.createSegment('L', roundedStart);\n  path.appendSegment(segment);\n  segment = g.Path.createSegment('C', control1, control2, roundedEnd);\n  path.appendSegment(segment);\n}\n\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\nexport const jumpover = function (sourcePoint, targetPoint, route, opt) {\n  // eslint-disable-line max-params\n\n  setupUpdating(this);\n  var raw = opt.raw;\n  var jumpSize = opt.size || JUMP_SIZE;\n  var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n  var radius = opt.radius || RADIUS;\n  var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n  // grab the first jump type as a default if specified one is invalid\n  if (JUMP_TYPES.indexOf(jumpType) === -1) {\n    jumpType = JUMP_TYPES[0];\n  }\n  var paper = this.paper;\n  var graph = paper.model;\n  var allLinks = graph.getLinks();\n\n  // there is just one link, draw it directly\n  if (allLinks.length === 1) {\n    return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);\n  }\n  var thisModel = this.model;\n  var thisIndex = allLinks.indexOf(thisModel);\n  var defaultConnector = paper.options.defaultConnector || {};\n\n  // not all links are meant to be jumped over.\n  var links = allLinks.filter(function (link, idx) {\n    var connector = link.get('connector') || defaultConnector;\n\n    // avoid jumping over links with connector type listed in `ignored connectors`.\n    if (util.toArray(ignoreConnectors).includes(connector.name)) {\n      return false;\n    }\n    // filter out links that are above this one and  have the same connector type\n    // otherwise there would double hoops for each intersection\n    if (idx > thisIndex) {\n      return connector.name !== 'jumpover';\n    }\n    return true;\n  });\n\n  // find views for all links\n  var linkViews = links.map(function (link) {\n    return paper.findViewByModel(link);\n  });\n\n  // create lines for this link\n  var thisLines = createLines(sourcePoint, targetPoint, route);\n\n  // create lines for all other links\n  var linkLines = linkViews.map(function (linkView) {\n    if (linkView == null) {\n      return [];\n    }\n    if (linkView === this) {\n      return thisLines;\n    }\n    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);\n  }, this);\n\n  // transform lines for this link by splitting with jump lines at\n  // points of intersection with other links\n  var jumpingLines = thisLines.reduce(function (resultLines, thisLine) {\n    // iterate all links and grab the intersections with this line\n    // these are then sorted by distance so the line can be split more easily\n\n    var intersections = links.reduce(function (res, link, i) {\n      // don't intersection with itself\n      if (link !== thisModel) {\n        var lineIntersections = findLineIntersections(thisLine, linkLines[i]);\n        res.push.apply(res, lineIntersections);\n      }\n      return res;\n    }, []).sort(function (a, b) {\n      return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n    });\n    if (intersections.length > 0) {\n      // split the line based on found intersection points\n      resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n    } else {\n      // without any intersection the line goes uninterrupted\n      resultLines.push(thisLine);\n    }\n    return resultLines;\n  }, []);\n  var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n  return raw ? path : path.serialize();\n};","map":{"version":3,"names":["util","g","JUMP_SIZE","JUMP_TYPES","RADIUS","CLOSE_PROXIMITY_PADDING","IGNORED_CONNECTORS","_13","_23","createLines","sourcePoint","targetPoint","route","points","concat","reduce","resultLines","point","idx","nextPoint","line","setupUpdating","jumpOverLinkView","paper","updateList","_jumpOverUpdateList","graph","model","on","hasActiveBatch","updateJumpOver","indexOf","push","listenToOnce","splice","i","length","linkView","updateFlag","getFlag","constructor","Flags","CONNECTOR","requestUpdate","findLineIntersections","crossCheckLines","toArray","res","crossCheckLine","intersection","sortPoints","p1","p2","squaredLength","createJumps","intersections","jumpSize","skip","lastLine","pop","jumpStart","move","start","jumpEnd","distance","endDistance","end","startDistance","jumpLine","isJump","buildPath","lines","jumpType","radius","path","Path","segment","createSegment","appendSegment","forEach","index","angle","diff","control1","control2","difference","xAxisRotate","Number","x","y","midpoint","centerLine","Line","rotate","halfLine","pointAt","theta","xOffset","yOffset","Point","nextLine","buildRoundedSegment","offset","curr","prev","next","prevDistance","nextDistance","startMove","Math","min","endMove","roundedStart","clone","round","roundedEnd","jumpover","opt","raw","size","jump","toLowerCase","ignoreConnectors","allLinks","getLinks","thisModel","thisIndex","defaultConnector","options","links","filter","link","connector","get","includes","name","linkViews","map","findViewByModel","thisLines","linkLines","jumpingLines","thisLine","lineIntersections","apply","sort","a","b","serialize"],"sources":["/Users/lijiaxin/Documents/workspace/hydsoft-mgmt-frontend/node_modules/jointjs/src/connectors/jumpover.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n// default radius\nvar RADIUS = 0;\n\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = ['smooth'];\n\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\n\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\nfunction createLines(sourcePoint, targetPoint, route) {\n    // make a flattened array of all points\n    var points = [].concat(sourcePoint, route, targetPoint);\n    return points.reduce(function(resultLines, point, idx) {\n        // if there is a next point, make a line with it\n        var nextPoint = points[idx + 1];\n        if (nextPoint != null) {\n            resultLines[idx] = g.line(point, nextPoint);\n        }\n        return resultLines;\n    }, []);\n}\n\nfunction setupUpdating(jumpOverLinkView) {\n    var paper = jumpOverLinkView.paper;\n    var updateList = paper._jumpOverUpdateList;\n\n    // first time setup for this paper\n    if (updateList == null) {\n        updateList = paper._jumpOverUpdateList = [];\n        var graph = paper.model;\n        graph.on('batch:stop', function() {\n            if (this.hasActiveBatch()) return;\n            updateJumpOver(paper);\n        });\n        graph.on('reset', function() {\n            updateList = paper._jumpOverUpdateList = [];\n        });\n    }\n\n    // add this link to a list so it can be updated when some other link is updated\n    if (updateList.indexOf(jumpOverLinkView) < 0) {\n        updateList.push(jumpOverLinkView);\n\n        // watch for change of connector type or removal of link itself\n        // to remove the link from a list of jump over connectors\n        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\n            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n        });\n    }\n}\n\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\nfunction updateJumpOver(paper) {\n    var updateList = paper._jumpOverUpdateList;\n    for (var i = 0; i < updateList.length; i++) {\n        const linkView = updateList[i];\n        const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n        linkView.requestUpdate(updateFlag);\n    }\n}\n\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\nfunction findLineIntersections(line, crossCheckLines) {\n    return util.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n        var intersection = line.intersection(crossCheckLine);\n        if (intersection) {\n            res.push(intersection);\n        }\n        return res;\n    }, []);\n}\n\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\nfunction sortPoints(p1, p2) {\n    return g.line(p1, p2).squaredLength();\n}\n\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\nfunction createJumps(line, intersections, jumpSize) {\n    return intersections.reduce(function(resultLines, point, idx) {\n        // skipping points that were merged with the previous line\n        // to make bigger arc over multiple lines that are close to each other\n        if (point.skip === true) {\n            return resultLines;\n        }\n\n        // always grab the last line from buffer and modify it\n        var lastLine = resultLines.pop() || line;\n\n        // calculate start and end of jump by moving by a given size of jump\n        var jumpStart = g.point(point).move(lastLine.start, -(jumpSize));\n        var jumpEnd = g.point(point).move(lastLine.start, +(jumpSize));\n\n        // now try to look at the next intersection point\n        var nextPoint = intersections[idx + 1];\n        if (nextPoint != null) {\n            var distance = jumpEnd.distance(nextPoint);\n            if (distance <= jumpSize) {\n                // next point is close enough, move the jump end by this\n                // difference and mark the next point to be skipped\n                jumpEnd = nextPoint.move(lastLine.start, distance);\n                nextPoint.skip = true;\n            }\n        } else {\n            // this block is inside of `else` as an optimization so the distance is\n            // not calculated when we know there are no other intersection points\n            var endDistance = jumpStart.distance(lastLine.end);\n            // if the end is too close to possible jump, draw remaining line instead of a jump\n            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                resultLines.push(lastLine);\n                return resultLines;\n            }\n        }\n\n        var startDistance = jumpEnd.distance(lastLine.start);\n        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n            // if the start of line is too close to jump, draw that line instead of a jump\n            resultLines.push(lastLine);\n            return resultLines;\n        }\n\n        // finally create a jump line\n        var jumpLine = g.line(jumpStart, jumpEnd);\n        // it's just simple line but with a `isJump` property\n        jumpLine.isJump = true;\n\n        resultLines.push(\n            g.line(lastLine.start, jumpStart),\n            jumpLine,\n            g.line(jumpEnd, lastLine.end)\n        );\n        return resultLines;\n    }, []);\n}\n\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n\n    var path = new g.Path();\n    var segment;\n\n    // first move to the start of a first line\n    segment = g.Path.createSegment('M', lines[0].start);\n    path.appendSegment(segment);\n\n    // make a paths from lines\n    util.toArray(lines).forEach(function(line, index) {\n\n        if (line.isJump) {\n            var angle, diff;\n\n            var control1, control2;\n\n            if (jumpType === 'arc') { // approximates semicircle with 2 curves\n                angle = -90;\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                var xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) angle += 180;\n\n                var midpoint = line.midpoint();\n                var centerLine = new g.Line(midpoint, line.end).rotate(midpoint, angle);\n\n                var halfLine;\n\n                // first half\n                halfLine = new g.Line(line.start, midpoint);\n\n                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, centerLine.end);\n                path.appendSegment(segment);\n\n                // second half\n                halfLine = new g.Line(midpoint, line.end);\n\n                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'gap') {\n                segment = g.Path.createSegment('M', line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'cubic') { // approximates semicircle with 1 curve\n                angle = line.start.theta(line.end);\n\n                var xOffset = jumpSize * 0.6;\n                var yOffset = jumpSize * 1.35;\n\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) yOffset *= -1;\n\n                control1 = g.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n                control2 = g.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n\n        } else {\n            var nextLine = lines[index + 1];\n            if (radius == 0 || !nextLine || nextLine.isJump) {\n                segment = g.Path.createSegment('L', line.end);\n                path.appendSegment(segment);\n            } else {\n                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        }\n    });\n\n    return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n    var prevDistance = curr.distance(prev) / 2;\n    var nextDistance = curr.distance(next) / 2;\n\n    var startMove = -Math.min(offset, prevDistance);\n    var endMove = -Math.min(offset, nextDistance);\n\n    var roundedStart = curr.clone().move(prev, startMove).round();\n    var roundedEnd = curr.clone().move(next, endMove).round();\n\n    var control1 = new g.Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n    var control2 = new g.Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n    var segment;\n    segment = g.Path.createSegment('L', roundedStart);\n    path.appendSegment(segment);\n\n    segment = g.Path.createSegment('C', control1, control2, roundedEnd);\n    path.appendSegment(segment);\n}\n\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\nexport const jumpover = function(sourcePoint, targetPoint, route, opt) { // eslint-disable-line max-params\n\n    setupUpdating(this);\n\n    var raw = opt.raw;\n    var jumpSize = opt.size || JUMP_SIZE;\n    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n    var radius = opt.radius || RADIUS;\n    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n    // grab the first jump type as a default if specified one is invalid\n    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n        jumpType = JUMP_TYPES[0];\n    }\n\n    var paper = this.paper;\n    var graph = paper.model;\n    var allLinks = graph.getLinks();\n\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n        return buildPath(\n            createLines(sourcePoint, targetPoint, route),\n            jumpSize, jumpType, radius\n        );\n    }\n\n    var thisModel = this.model;\n    var thisIndex = allLinks.indexOf(thisModel);\n    var defaultConnector = paper.options.defaultConnector || {};\n\n    // not all links are meant to be jumped over.\n    var links = allLinks.filter(function(link, idx) {\n\n        var connector = link.get('connector') || defaultConnector;\n\n        // avoid jumping over links with connector type listed in `ignored connectors`.\n        if (util.toArray(ignoreConnectors).includes(connector.name)) {\n            return false;\n        }\n        // filter out links that are above this one and  have the same connector type\n        // otherwise there would double hoops for each intersection\n        if (idx > thisIndex) {\n            return connector.name !== 'jumpover';\n        }\n        return true;\n    });\n\n    // find views for all links\n    var linkViews = links.map(function(link) {\n        return paper.findViewByModel(link);\n    });\n\n    // create lines for this link\n    var thisLines = createLines(\n        sourcePoint,\n        targetPoint,\n        route\n    );\n\n    // create lines for all other links\n    var linkLines = linkViews.map(function(linkView) {\n        if (linkView == null) {\n            return [];\n        }\n        if (linkView === this) {\n            return thisLines;\n        }\n        return createLines(\n            linkView.sourcePoint,\n            linkView.targetPoint,\n            linkView.route\n        );\n    }, this);\n\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n        // iterate all links and grab the intersections with this line\n        // these are then sorted by distance so the line can be split more easily\n\n        var intersections = links.reduce(function(res, link, i) {\n            // don't intersection with itself\n            if (link !== thisModel) {\n\n                var lineIntersections = findLineIntersections(thisLine, linkLines[i]);\n                res.push.apply(res, lineIntersections);\n            }\n            return res;\n        }, []).sort(function(a, b) {\n            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n        });\n\n        if (intersections.length > 0) {\n            // split the line based on found intersection points\n            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n        } else {\n            // without any intersection the line goes uninterrupted\n            resultLines.push(thisLine);\n        }\n        return resultLines;\n    }, []);\n\n    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n    return (raw) ? path : path.serialize();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}