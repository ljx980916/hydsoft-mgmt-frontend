{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\\1?|[aA]|\"[^\"]*\"|'[^']*'/g;\nvar twoDigitsOptional = \"\\\\d\\\\d?\";\nvar twoDigits = \"\\\\d\\\\d\";\nvar threeDigits = \"\\\\d{3}\";\nvar fourDigits = \"\\\\d{4}\";\nvar word = \"[^\\\\s]+\";\nvar literal = /\\[([^]*?)\\]/gm;\nfunction shorten(arr, sLen) {\n  var newArr = [];\n  for (var i = 0, len = arr.length; i < len; i++) {\n    newArr.push(arr[i].substr(0, sLen));\n  }\n  return newArr;\n}\nvar monthUpdate = function (arrName) {\n  return function (v, i18n) {\n    var lowerCaseArr = i18n[arrName].map(function (v) {\n      return v.toLowerCase();\n    });\n    var index = lowerCaseArr.indexOf(v.toLowerCase());\n    if (index > -1) {\n      return index;\n    }\n    return null;\n  };\n};\nfunction assign(origObj) {\n  var args = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n  for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n    var obj = args_1[_a];\n    for (var key in obj) {\n      // @ts-ignore ex\n      origObj[key] = obj[key];\n    }\n  }\n  return origObj;\n}\nvar dayNames = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\nvar monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\nvar monthNamesShort = shorten(monthNames, 3);\nvar dayNamesShort = shorten(dayNames, 3);\nvar defaultI18n = {\n  dayNamesShort: dayNamesShort,\n  dayNames: dayNames,\n  monthNamesShort: monthNamesShort,\n  monthNames: monthNames,\n  amPm: [\"am\", \"pm\"],\n  DoFn: function (dayOfMonth) {\n    return dayOfMonth + [\"th\", \"st\", \"nd\", \"rd\"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];\n  }\n};\nvar globalI18n = assign({}, defaultI18n);\nvar setGlobalDateI18n = function (i18n) {\n  return globalI18n = assign(globalI18n, i18n);\n};\nvar regexEscape = function (str) {\n  return str.replace(/[|\\\\{()[^$+*?.-]/g, \"\\\\$&\");\n};\nvar pad = function (val, len) {\n  if (len === void 0) {\n    len = 2;\n  }\n  val = String(val);\n  while (val.length < len) {\n    val = \"0\" + val;\n  }\n  return val;\n};\nvar formatFlags = {\n  D: function (dateObj) {\n    return String(dateObj.getDate());\n  },\n  DD: function (dateObj) {\n    return pad(dateObj.getDate());\n  },\n  Do: function (dateObj, i18n) {\n    return i18n.DoFn(dateObj.getDate());\n  },\n  d: function (dateObj) {\n    return String(dateObj.getDay());\n  },\n  dd: function (dateObj) {\n    return pad(dateObj.getDay());\n  },\n  ddd: function (dateObj, i18n) {\n    return i18n.dayNamesShort[dateObj.getDay()];\n  },\n  dddd: function (dateObj, i18n) {\n    return i18n.dayNames[dateObj.getDay()];\n  },\n  M: function (dateObj) {\n    return String(dateObj.getMonth() + 1);\n  },\n  MM: function (dateObj) {\n    return pad(dateObj.getMonth() + 1);\n  },\n  MMM: function (dateObj, i18n) {\n    return i18n.monthNamesShort[dateObj.getMonth()];\n  },\n  MMMM: function (dateObj, i18n) {\n    return i18n.monthNames[dateObj.getMonth()];\n  },\n  YY: function (dateObj) {\n    return pad(String(dateObj.getFullYear()), 4).substr(2);\n  },\n  YYYY: function (dateObj) {\n    return pad(dateObj.getFullYear(), 4);\n  },\n  h: function (dateObj) {\n    return String(dateObj.getHours() % 12 || 12);\n  },\n  hh: function (dateObj) {\n    return pad(dateObj.getHours() % 12 || 12);\n  },\n  H: function (dateObj) {\n    return String(dateObj.getHours());\n  },\n  HH: function (dateObj) {\n    return pad(dateObj.getHours());\n  },\n  m: function (dateObj) {\n    return String(dateObj.getMinutes());\n  },\n  mm: function (dateObj) {\n    return pad(dateObj.getMinutes());\n  },\n  s: function (dateObj) {\n    return String(dateObj.getSeconds());\n  },\n  ss: function (dateObj) {\n    return pad(dateObj.getSeconds());\n  },\n  S: function (dateObj) {\n    return String(Math.round(dateObj.getMilliseconds() / 100));\n  },\n  SS: function (dateObj) {\n    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);\n  },\n  SSS: function (dateObj) {\n    return pad(dateObj.getMilliseconds(), 3);\n  },\n  a: function (dateObj, i18n) {\n    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];\n  },\n  A: function (dateObj, i18n) {\n    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();\n  },\n  ZZ: function (dateObj) {\n    var offset = dateObj.getTimezoneOffset();\n    return (offset > 0 ? \"-\" : \"+\") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);\n  },\n  Z: function (dateObj) {\n    var offset = dateObj.getTimezoneOffset();\n    return (offset > 0 ? \"-\" : \"+\") + pad(Math.floor(Math.abs(offset) / 60), 2) + \":\" + pad(Math.abs(offset) % 60, 2);\n  }\n};\nvar monthParse = function (v) {\n  return +v - 1;\n};\nvar emptyDigits = [null, twoDigitsOptional];\nvar emptyWord = [null, word];\nvar amPm = [\"isPm\", word, function (v, i18n) {\n  var val = v.toLowerCase();\n  if (val === i18n.amPm[0]) {\n    return 0;\n  } else if (val === i18n.amPm[1]) {\n    return 1;\n  }\n  return null;\n}];\nvar timezoneOffset = [\"timezoneOffset\", \"[^\\\\s]*?[\\\\+\\\\-]\\\\d\\\\d:?\\\\d\\\\d|[^\\\\s]*?Z?\", function (v) {\n  var parts = (v + \"\").match(/([+-]|\\d\\d)/gi);\n  if (parts) {\n    var minutes = +parts[1] * 60 + parseInt(parts[2], 10);\n    return parts[0] === \"+\" ? minutes : -minutes;\n  }\n  return 0;\n}];\nvar parseFlags = {\n  D: [\"day\", twoDigitsOptional],\n  DD: [\"day\", twoDigits],\n  Do: [\"day\", twoDigitsOptional + word, function (v) {\n    return parseInt(v, 10);\n  }],\n  M: [\"month\", twoDigitsOptional, monthParse],\n  MM: [\"month\", twoDigits, monthParse],\n  YY: [\"year\", twoDigits, function (v) {\n    var now = new Date();\n    var cent = +(\"\" + now.getFullYear()).substr(0, 2);\n    return +(\"\" + (+v > 68 ? cent - 1 : cent) + v);\n  }],\n  h: [\"hour\", twoDigitsOptional, undefined, \"isPm\"],\n  hh: [\"hour\", twoDigits, undefined, \"isPm\"],\n  H: [\"hour\", twoDigitsOptional],\n  HH: [\"hour\", twoDigits],\n  m: [\"minute\", twoDigitsOptional],\n  mm: [\"minute\", twoDigits],\n  s: [\"second\", twoDigitsOptional],\n  ss: [\"second\", twoDigits],\n  YYYY: [\"year\", fourDigits],\n  S: [\"millisecond\", \"\\\\d\", function (v) {\n    return +v * 100;\n  }],\n  SS: [\"millisecond\", twoDigits, function (v) {\n    return +v * 10;\n  }],\n  SSS: [\"millisecond\", threeDigits],\n  d: emptyDigits,\n  dd: emptyDigits,\n  ddd: emptyWord,\n  dddd: emptyWord,\n  MMM: [\"month\", word, monthUpdate(\"monthNamesShort\")],\n  MMMM: [\"month\", word, monthUpdate(\"monthNames\")],\n  a: amPm,\n  A: amPm,\n  ZZ: timezoneOffset,\n  Z: timezoneOffset\n};\n// Some common format strings\nvar globalMasks = {\n  default: \"ddd MMM DD YYYY HH:mm:ss\",\n  shortDate: \"M/D/YY\",\n  mediumDate: \"MMM D, YYYY\",\n  longDate: \"MMMM D, YYYY\",\n  fullDate: \"dddd, MMMM D, YYYY\",\n  isoDate: \"YYYY-MM-DD\",\n  isoDateTime: \"YYYY-MM-DDTHH:mm:ssZ\",\n  shortTime: \"HH:mm\",\n  mediumTime: \"HH:mm:ss\",\n  longTime: \"HH:mm:ss.SSS\"\n};\nvar setGlobalDateMasks = function (masks) {\n  return assign(globalMasks, masks);\n};\n/***\n * Format a date\n * @method format\n * @param {Date|number} dateObj\n * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'\n * @returns {string} Formatted date string\n */\nvar format = function (dateObj, mask, i18n) {\n  if (mask === void 0) {\n    mask = globalMasks[\"default\"];\n  }\n  if (i18n === void 0) {\n    i18n = {};\n  }\n  if (typeof dateObj === \"number\") {\n    dateObj = new Date(dateObj);\n  }\n  if (Object.prototype.toString.call(dateObj) !== \"[object Date]\" || isNaN(dateObj.getTime())) {\n    throw new Error(\"Invalid Date pass to format\");\n  }\n  mask = globalMasks[mask] || mask;\n  var literals = [];\n  // Make literals inactive by replacing them with @@@\n  mask = mask.replace(literal, function ($0, $1) {\n    literals.push($1);\n    return \"@@@\";\n  });\n  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);\n  // Apply formatting rules\n  mask = mask.replace(token, function ($0) {\n    return formatFlags[$0](dateObj, combinedI18nSettings);\n  });\n  // Inline literal values back into the formatted value\n  return mask.replace(/@@@/g, function () {\n    return literals.shift();\n  });\n};\n/**\n * Parse a date string into a Javascript Date object /\n * @method parse\n * @param {string} dateStr Date string\n * @param {string} format Date parse format\n * @param {i18n} I18nSettingsOptional Full or subset of I18N settings\n * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format\n */\nfunction parse(dateStr, format, i18n) {\n  if (i18n === void 0) {\n    i18n = {};\n  }\n  if (typeof format !== \"string\") {\n    throw new Error(\"Invalid format in fecha parse\");\n  }\n  // Check to see if the format is actually a mask\n  format = globalMasks[format] || format;\n  // Avoid regular expression denial of service, fail early for really long strings\n  // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\n  if (dateStr.length > 1000) {\n    return null;\n  }\n  // Default to the beginning of the year.\n  var today = new Date();\n  var dateInfo = {\n    year: today.getFullYear(),\n    month: 0,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n    isPm: null,\n    timezoneOffset: null\n  };\n  var parseInfo = [];\n  var literals = [];\n  // Replace all the literals with @@@. Hopefully a string that won't exist in the format\n  var newFormat = format.replace(literal, function ($0, $1) {\n    literals.push(regexEscape($1));\n    return \"@@@\";\n  });\n  var specifiedFields = {};\n  var requiredFields = {};\n  // Change every token that we find into the correct regex\n  newFormat = regexEscape(newFormat).replace(token, function ($0) {\n    var info = parseFlags[$0];\n    var field = info[0],\n      regex = info[1],\n      requiredField = info[3];\n    // Check if the person has specified the same field twice. This will lead to confusing results.\n    if (specifiedFields[field]) {\n      throw new Error(\"Invalid format. \" + field + \" specified twice in format\");\n    }\n    specifiedFields[field] = true;\n    // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified\n    if (requiredField) {\n      requiredFields[requiredField] = true;\n    }\n    parseInfo.push(info);\n    return \"(\" + regex + \")\";\n  });\n  // Check all the required fields are present\n  Object.keys(requiredFields).forEach(function (field) {\n    if (!specifiedFields[field]) {\n      throw new Error(\"Invalid format. \" + field + \" is required in specified format\");\n    }\n  });\n  // Add back all the literals after\n  newFormat = newFormat.replace(/@@@/g, function () {\n    return literals.shift();\n  });\n  // Check if the date string matches the format. If it doesn't return null\n  var matches = dateStr.match(new RegExp(newFormat, \"i\"));\n  if (!matches) {\n    return null;\n  }\n  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);\n  // For each match, call the parser function for that date part\n  for (var i = 1; i < matches.length; i++) {\n    var _a = parseInfo[i - 1],\n      field = _a[0],\n      parser = _a[2];\n    var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];\n    // If the parser can't make sense of the value, return null\n    if (value == null) {\n      return null;\n    }\n    dateInfo[field] = value;\n  }\n  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {\n    dateInfo.hour = +dateInfo.hour + 12;\n  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {\n    dateInfo.hour = 0;\n  }\n  var dateTZ;\n  if (dateInfo.timezoneOffset == null) {\n    dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);\n    var validateFields = [[\"month\", \"getMonth\"], [\"day\", \"getDate\"], [\"hour\", \"getHours\"], [\"minute\", \"getMinutes\"], [\"second\", \"getSeconds\"]];\n    for (var i = 0, len = validateFields.length; i < len; i++) {\n      // Check to make sure the date field is within the allowed range. Javascript dates allows values\n      // outside the allowed range. If the values don't match the value was invalid\n      if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {\n        return null;\n      }\n    }\n  } else {\n    dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));\n    // We can't validate dates in another timezone unfortunately. Do a basic check instead\n    if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {\n      return null;\n    }\n  }\n  // Don't allow invalid dates\n  return dateTZ;\n}\nvar fecha = {\n  format: format,\n  parse: parse,\n  defaultI18n: defaultI18n,\n  setGlobalDateI18n: setGlobalDateI18n,\n  setGlobalDateMasks: setGlobalDateMasks\n};\nexport default fecha;\nexport { assign, format, parse, defaultI18n, setGlobalDateI18n, setGlobalDateMasks };","map":{"version":3,"mappings":"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","names":["token","twoDigitsOptional","twoDigits","threeDigits","fourDigits","word","literal","shorten","arr","sLen","newArr","i","len","length","push","substr","monthUpdate","arrName","v","i18n","lowerCaseArr","map","toLowerCase","index","indexOf","assign","origObj","_i","args","args_1","_a","obj","key","dayNames","monthNames","monthNamesShort","dayNamesShort","defaultI18n","amPm","DoFn","dayOfMonth","globalI18n","setGlobalDateI18n","regexEscape","str","replace","pad","val","String","formatFlags","D","dateObj","getDate","DD","Do","d","getDay","dd","ddd","dddd","M","getMonth","MM","MMM","MMMM","YY","getFullYear","YYYY","h","getHours","hh","H","HH","m","getMinutes","mm","s","getSeconds","ss","S","Math","round","getMilliseconds","SS","SSS","a","A","toUpperCase","ZZ","offset","getTimezoneOffset","floor","abs","Z","monthParse","emptyDigits","emptyWord","timezoneOffset","parts","match","minutes","parseInt","parseFlags","now","Date","cent","undefined","globalMasks","default","shortDate","mediumDate","longDate","fullDate","isoDate","isoDateTime","shortTime","mediumTime","longTime","setGlobalDateMasks","masks","format","mask","Object","prototype","toString","call","isNaN","getTime","Error","literals","$0","$1","combinedI18nSettings","shift","parse","dateStr","today","dateInfo","year","month","day","hour","minute","second","millisecond","isPm","parseInfo","newFormat","specifiedFields","requiredFields","info","regex","requiredField","field","keys","forEach","matches","RegExp","parser","value","dateTZ","validateFields","UTC"],"sources":["../src/fecha.ts"],"sourcesContent":["const token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\\1?|[aA]|\"[^\"]*\"|'[^']*'/g;\nconst twoDigitsOptional = \"\\\\d\\\\d?\";\nconst twoDigits = \"\\\\d\\\\d\";\nconst threeDigits = \"\\\\d{3}\";\nconst fourDigits = \"\\\\d{4}\";\nconst word = \"[^\\\\s]+\";\nconst literal = /\\[([^]*?)\\]/gm;\n\ntype DateInfo = {\n  year: number;\n  month: number;\n  day: number;\n  hour: number;\n  minute: number;\n  second: number;\n  millisecond: number;\n  isPm: number | null;\n  timezoneOffset: number | null;\n};\n\nexport type I18nSettings = {\n  amPm: [string, string];\n  dayNames: Days;\n  dayNamesShort: Days;\n  monthNames: Months;\n  monthNamesShort: Months;\n  DoFn(dayOfMonth: number): string;\n};\n\nexport type I18nSettingsOptional = Partial<I18nSettings>;\n\nexport type Days = [string, string, string, string, string, string, string];\nexport type Months = [\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string,\n  string\n];\n\nfunction shorten<T extends string[]>(arr: T, sLen: number): string[] {\n  const newArr: string[] = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    newArr.push(arr[i].substr(0, sLen));\n  }\n  return newArr;\n}\n\nconst monthUpdate = (\n  arrName: \"monthNames\" | \"monthNamesShort\" | \"dayNames\" | \"dayNamesShort\"\n) => (v: string, i18n: I18nSettings): number | null => {\n  const lowerCaseArr = i18n[arrName].map(v => v.toLowerCase());\n  const index = lowerCaseArr.indexOf(v.toLowerCase());\n  if (index > -1) {\n    return index;\n  }\n  return null;\n};\n\nexport function assign<A>(a: A): A;\nexport function assign<A, B>(a: A, b: B): A & B;\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\nexport function assign(origObj: any, ...args: any[]): any {\n  for (const obj of args) {\n    for (const key in obj) {\n      // @ts-ignore ex\n      origObj[key] = obj[key];\n    }\n  }\n  return origObj;\n}\n\nconst dayNames: Days = [\n  \"Sunday\",\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\"\n];\nconst monthNames: Months = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\"\n];\n\nconst monthNamesShort: Months = shorten(monthNames, 3) as Months;\nconst dayNamesShort: Days = shorten(dayNames, 3) as Days;\n\nconst defaultI18n: I18nSettings = {\n  dayNamesShort,\n  dayNames,\n  monthNamesShort,\n  monthNames,\n  amPm: [\"am\", \"pm\"],\n  DoFn(dayOfMonth: number) {\n    return (\n      dayOfMonth +\n      [\"th\", \"st\", \"nd\", \"rd\"][\n        dayOfMonth % 10 > 3\n          ? 0\n          : ((dayOfMonth - (dayOfMonth % 10) !== 10 ? 1 : 0) * dayOfMonth) % 10\n      ]\n    );\n  }\n};\nlet globalI18n = assign({}, defaultI18n);\nconst setGlobalDateI18n = (i18n: I18nSettingsOptional): I18nSettings =>\n  (globalI18n = assign(globalI18n, i18n));\n\nconst regexEscape = (str: string): string =>\n  str.replace(/[|\\\\{()[^$+*?.-]/g, \"\\\\$&\");\n\nconst pad = (val: string | number, len = 2): string => {\n  val = String(val);\n  while (val.length < len) {\n    val = \"0\" + val;\n  }\n  return val;\n};\n\nconst formatFlags: Record<\n  string,\n  (dateObj: Date, i18n: I18nSettings) => string\n> = {\n  D: (dateObj: Date): string => String(dateObj.getDate()),\n  DD: (dateObj: Date): string => pad(dateObj.getDate()),\n  Do: (dateObj: Date, i18n: I18nSettings): string =>\n    i18n.DoFn(dateObj.getDate()),\n  d: (dateObj: Date): string => String(dateObj.getDay()),\n  dd: (dateObj: Date): string => pad(dateObj.getDay()),\n  ddd: (dateObj: Date, i18n: I18nSettings): string =>\n    i18n.dayNamesShort[dateObj.getDay()],\n  dddd: (dateObj: Date, i18n: I18nSettings): string =>\n    i18n.dayNames[dateObj.getDay()],\n  M: (dateObj: Date): string => String(dateObj.getMonth() + 1),\n  MM: (dateObj: Date): string => pad(dateObj.getMonth() + 1),\n  MMM: (dateObj: Date, i18n: I18nSettings): string =>\n    i18n.monthNamesShort[dateObj.getMonth()],\n  MMMM: (dateObj: Date, i18n: I18nSettings): string =>\n    i18n.monthNames[dateObj.getMonth()],\n  YY: (dateObj: Date): string =>\n    pad(String(dateObj.getFullYear()), 4).substr(2),\n  YYYY: (dateObj: Date): string => pad(dateObj.getFullYear(), 4),\n  h: (dateObj: Date): string => String(dateObj.getHours() % 12 || 12),\n  hh: (dateObj: Date): string => pad(dateObj.getHours() % 12 || 12),\n  H: (dateObj: Date): string => String(dateObj.getHours()),\n  HH: (dateObj: Date): string => pad(dateObj.getHours()),\n  m: (dateObj: Date): string => String(dateObj.getMinutes()),\n  mm: (dateObj: Date): string => pad(dateObj.getMinutes()),\n  s: (dateObj: Date): string => String(dateObj.getSeconds()),\n  ss: (dateObj: Date): string => pad(dateObj.getSeconds()),\n  S: (dateObj: Date): string =>\n    String(Math.round(dateObj.getMilliseconds() / 100)),\n  SS: (dateObj: Date): string =>\n    pad(Math.round(dateObj.getMilliseconds() / 10), 2),\n  SSS: (dateObj: Date): string => pad(dateObj.getMilliseconds(), 3),\n  a: (dateObj: Date, i18n: I18nSettings): string =>\n    dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1],\n  A: (dateObj: Date, i18n: I18nSettings): string =>\n    dateObj.getHours() < 12\n      ? i18n.amPm[0].toUpperCase()\n      : i18n.amPm[1].toUpperCase(),\n  ZZ(dateObj: Date): string {\n    const offset = dateObj.getTimezoneOffset();\n    return (\n      (offset > 0 ? \"-\" : \"+\") +\n      pad(Math.floor(Math.abs(offset) / 60) * 100 + (Math.abs(offset) % 60), 4)\n    );\n  },\n  Z(dateObj: Date): string {\n    const offset = dateObj.getTimezoneOffset();\n    return (\n      (offset > 0 ? \"-\" : \"+\") +\n      pad(Math.floor(Math.abs(offset) / 60), 2) +\n      \":\" +\n      pad(Math.abs(offset) % 60, 2)\n    );\n  }\n};\n\ntype ParseInfo = [\n  keyof DateInfo,\n  string,\n  ((v: string, i18n: I18nSettings) => number | null)?,\n  string?\n];\nconst monthParse = (v: string): number => +v - 1;\nconst emptyDigits: ParseInfo = [null, twoDigitsOptional];\nconst emptyWord: ParseInfo = [null, word];\nconst amPm: ParseInfo = [\n  \"isPm\",\n  word,\n  (v: string, i18n: I18nSettings): number | null => {\n    const val = v.toLowerCase();\n    if (val === i18n.amPm[0]) {\n      return 0;\n    } else if (val === i18n.amPm[1]) {\n      return 1;\n    }\n    return null;\n  }\n];\nconst timezoneOffset: ParseInfo = [\n  \"timezoneOffset\",\n  \"[^\\\\s]*?[\\\\+\\\\-]\\\\d\\\\d:?\\\\d\\\\d|[^\\\\s]*?Z?\",\n  (v: string): number | null => {\n    const parts = (v + \"\").match(/([+-]|\\d\\d)/gi);\n\n    if (parts) {\n      const minutes = +parts[1] * 60 + parseInt(parts[2], 10);\n      return parts[0] === \"+\" ? minutes : -minutes;\n    }\n\n    return 0;\n  }\n];\nconst parseFlags: Record<string, ParseInfo> = {\n  D: [\"day\", twoDigitsOptional],\n  DD: [\"day\", twoDigits],\n  Do: [\"day\", twoDigitsOptional + word, (v: string): number => parseInt(v, 10)],\n  M: [\"month\", twoDigitsOptional, monthParse],\n  MM: [\"month\", twoDigits, monthParse],\n  YY: [\n    \"year\",\n    twoDigits,\n    (v: string): number => {\n      const now = new Date();\n      const cent = +(\"\" + now.getFullYear()).substr(0, 2);\n      return +(\"\" + (+v > 68 ? cent - 1 : cent) + v);\n    }\n  ],\n  h: [\"hour\", twoDigitsOptional, undefined, \"isPm\"],\n  hh: [\"hour\", twoDigits, undefined, \"isPm\"],\n  H: [\"hour\", twoDigitsOptional],\n  HH: [\"hour\", twoDigits],\n  m: [\"minute\", twoDigitsOptional],\n  mm: [\"minute\", twoDigits],\n  s: [\"second\", twoDigitsOptional],\n  ss: [\"second\", twoDigits],\n  YYYY: [\"year\", fourDigits],\n  S: [\"millisecond\", \"\\\\d\", (v: string): number => +v * 100],\n  SS: [\"millisecond\", twoDigits, (v: string): number => +v * 10],\n  SSS: [\"millisecond\", threeDigits],\n  d: emptyDigits,\n  dd: emptyDigits,\n  ddd: emptyWord,\n  dddd: emptyWord,\n  MMM: [\"month\", word, monthUpdate(\"monthNamesShort\")],\n  MMMM: [\"month\", word, monthUpdate(\"monthNames\")],\n  a: amPm,\n  A: amPm,\n  ZZ: timezoneOffset,\n  Z: timezoneOffset\n};\n\n// Some common format strings\nconst globalMasks: { [key: string]: string } = {\n  default: \"ddd MMM DD YYYY HH:mm:ss\",\n  shortDate: \"M/D/YY\",\n  mediumDate: \"MMM D, YYYY\",\n  longDate: \"MMMM D, YYYY\",\n  fullDate: \"dddd, MMMM D, YYYY\",\n  isoDate: \"YYYY-MM-DD\",\n  isoDateTime: \"YYYY-MM-DDTHH:mm:ssZ\",\n  shortTime: \"HH:mm\",\n  mediumTime: \"HH:mm:ss\",\n  longTime: \"HH:mm:ss.SSS\"\n};\nconst setGlobalDateMasks = (masks: {\n  [key: string]: string;\n}): { [key: string]: string } => assign(globalMasks, masks);\n\n/***\n * Format a date\n * @method format\n * @param {Date|number} dateObj\n * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'\n * @returns {string} Formatted date string\n */\nconst format = (\n  dateObj: Date,\n  mask: string = globalMasks[\"default\"],\n  i18n: I18nSettingsOptional = {}\n): string => {\n  if (typeof dateObj === \"number\") {\n    dateObj = new Date(dateObj);\n  }\n\n  if (\n    Object.prototype.toString.call(dateObj) !== \"[object Date]\" ||\n    isNaN(dateObj.getTime())\n  ) {\n    throw new Error(\"Invalid Date pass to format\");\n  }\n\n  mask = globalMasks[mask] || mask;\n\n  const literals: string[] = [];\n\n  // Make literals inactive by replacing them with @@@\n  mask = mask.replace(literal, function($0, $1) {\n    literals.push($1);\n    return \"@@@\";\n  });\n\n  const combinedI18nSettings: I18nSettings = assign(\n    assign({}, globalI18n),\n    i18n\n  );\n  // Apply formatting rules\n  mask = mask.replace(token, $0 =>\n    formatFlags[$0](dateObj, combinedI18nSettings)\n  );\n  // Inline literal values back into the formatted value\n  return mask.replace(/@@@/g, () => literals.shift());\n};\n\n/**\n * Parse a date string into a Javascript Date object /\n * @method parse\n * @param {string} dateStr Date string\n * @param {string} format Date parse format\n * @param {i18n} I18nSettingsOptional Full or subset of I18N settings\n * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format\n */\nfunction parse(\n  dateStr: string,\n  format: string,\n  i18n: I18nSettingsOptional = {}\n): Date | null {\n  if (typeof format !== \"string\") {\n    throw new Error(\"Invalid format in fecha parse\");\n  }\n\n  // Check to see if the format is actually a mask\n  format = globalMasks[format] || format;\n\n  // Avoid regular expression denial of service, fail early for really long strings\n  // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\n  if (dateStr.length > 1000) {\n    return null;\n  }\n\n  // Default to the beginning of the year.\n  const today = new Date();\n  const dateInfo: DateInfo = {\n    year: today.getFullYear(),\n    month: 0,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n    isPm: null,\n    timezoneOffset: null\n  };\n  const parseInfo: ParseInfo[] = [];\n  const literals: string[] = [];\n\n  // Replace all the literals with @@@. Hopefully a string that won't exist in the format\n  let newFormat = format.replace(literal, ($0, $1) => {\n    literals.push(regexEscape($1));\n    return \"@@@\";\n  });\n  const specifiedFields: { [field: string]: boolean } = {};\n  const requiredFields: { [field: string]: boolean } = {};\n\n  // Change every token that we find into the correct regex\n  newFormat = regexEscape(newFormat).replace(token, $0 => {\n    const info = parseFlags[$0];\n    const [field, regex, , requiredField] = info;\n\n    // Check if the person has specified the same field twice. This will lead to confusing results.\n    if (specifiedFields[field]) {\n      throw new Error(`Invalid format. ${field} specified twice in format`);\n    }\n\n    specifiedFields[field] = true;\n\n    // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified\n    if (requiredField) {\n      requiredFields[requiredField] = true;\n    }\n\n    parseInfo.push(info);\n    return \"(\" + regex + \")\";\n  });\n\n  // Check all the required fields are present\n  Object.keys(requiredFields).forEach(field => {\n    if (!specifiedFields[field]) {\n      throw new Error(\n        `Invalid format. ${field} is required in specified format`\n      );\n    }\n  });\n\n  // Add back all the literals after\n  newFormat = newFormat.replace(/@@@/g, () => literals.shift());\n\n  // Check if the date string matches the format. If it doesn't return null\n  const matches = dateStr.match(new RegExp(newFormat, \"i\"));\n  if (!matches) {\n    return null;\n  }\n\n  const combinedI18nSettings: I18nSettings = assign(\n    assign({}, globalI18n),\n    i18n\n  );\n\n  // For each match, call the parser function for that date part\n  for (let i = 1; i < matches.length; i++) {\n    const [field, , parser] = parseInfo[i - 1];\n    const value = parser\n      ? parser(matches[i], combinedI18nSettings)\n      : +matches[i];\n\n    // If the parser can't make sense of the value, return null\n    if (value == null) {\n      return null;\n    }\n\n    dateInfo[field] = value;\n  }\n\n  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {\n    dateInfo.hour = +dateInfo.hour + 12;\n  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {\n    dateInfo.hour = 0;\n  }\n\n  let dateTZ: Date;\n  if (dateInfo.timezoneOffset == null) {\n    dateTZ = new Date(\n      dateInfo.year,\n      dateInfo.month,\n      dateInfo.day,\n      dateInfo.hour,\n      dateInfo.minute,\n      dateInfo.second,\n      dateInfo.millisecond\n    );\n    const validateFields: [\n      \"month\" | \"day\" | \"hour\" | \"minute\" | \"second\",\n      \"getMonth\" | \"getDate\" | \"getHours\" | \"getMinutes\" | \"getSeconds\"\n    ][] = [\n      [\"month\", \"getMonth\"],\n      [\"day\", \"getDate\"],\n      [\"hour\", \"getHours\"],\n      [\"minute\", \"getMinutes\"],\n      [\"second\", \"getSeconds\"]\n    ];\n    for (let i = 0, len = validateFields.length; i < len; i++) {\n      // Check to make sure the date field is within the allowed range. Javascript dates allows values\n      // outside the allowed range. If the values don't match the value was invalid\n      if (\n        specifiedFields[validateFields[i][0]] &&\n        dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()\n      ) {\n        return null;\n      }\n    }\n  } else {\n    dateTZ = new Date(\n      Date.UTC(\n        dateInfo.year,\n        dateInfo.month,\n        dateInfo.day,\n        dateInfo.hour,\n        dateInfo.minute - dateInfo.timezoneOffset,\n        dateInfo.second,\n        dateInfo.millisecond\n      )\n    );\n\n    // We can't validate dates in another timezone unfortunately. Do a basic check instead\n    if (\n      dateInfo.month > 11 ||\n      dateInfo.month < 0 ||\n      dateInfo.day > 31 ||\n      dateInfo.day < 1 ||\n      dateInfo.hour > 23 ||\n      dateInfo.hour < 0 ||\n      dateInfo.minute > 59 ||\n      dateInfo.minute < 0 ||\n      dateInfo.second > 59 ||\n      dateInfo.second < 0\n    ) {\n      return null;\n    }\n  }\n\n  // Don't allow invalid dates\n\n  return dateTZ;\n}\nexport default {\n  format,\n  parse,\n  defaultI18n,\n  setGlobalDateI18n,\n  setGlobalDateMasks\n};\nexport { format, parse, defaultI18n, setGlobalDateI18n, setGlobalDateMasks };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}