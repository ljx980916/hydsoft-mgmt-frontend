{"ast":null,"code":"import * as util from '../../util/index.mjs';\nimport { Graph } from '../../dia/index.mjs';\nimport * as g from '../../g/index.mjs';\nexport const DirectedGraph = {\n  exportElement: function (element) {\n    // The width and height of the element.\n    return element.size();\n  },\n  exportLink: function (link) {\n    var labelSize = link.get('labelSize') || {};\n    var edge = {\n      // The number of ranks to keep between the source and target of the edge.\n      minLen: link.get('minLen') || 1,\n      // The weight to assign edges. Higher weight edges are generally\n      // made shorter and straighter than lower weight edges.\n      weight: link.get('weight') || 1,\n      // Where to place the label relative to the edge.\n      // l = left, c = center r = right.\n      labelpos: link.get('labelPosition') || 'c',\n      // How many pixels to move the label away from the edge.\n      // Applies only when labelpos is l or r.\n      labeloffset: link.get('labelOffset') || 0,\n      // The width of the edge label in pixels.\n      width: labelSize.width || 0,\n      // The height of the edge label in pixels.\n      height: labelSize.height || 0\n    };\n    return edge;\n  },\n  importElement: function (opt, v, gl) {\n    var element = this.getCell(v);\n    var glNode = gl.node(v);\n    if (opt.setPosition) {\n      opt.setPosition(element, glNode);\n    } else {\n      element.set('position', {\n        x: glNode.x - glNode.width / 2,\n        y: glNode.y - glNode.height / 2\n      });\n    }\n  },\n  importLink: function (opt, edgeObj, gl) {\n    const SIMPLIFY_THRESHOLD = 0.001;\n    const link = this.getCell(edgeObj.name);\n    const glEdge = gl.edge(edgeObj);\n    const points = glEdge.points || [];\n    const polyline = new g.Polyline(points);\n\n    // check the `setLinkVertices` here for backwards compatibility\n    if (opt.setVertices || opt.setLinkVertices) {\n      if (util.isFunction(opt.setVertices)) {\n        opt.setVertices(link, points);\n      } else {\n        // simplify the `points` polyline\n        polyline.simplify({\n          threshold: SIMPLIFY_THRESHOLD\n        });\n        const polylinePoints = polyline.points.map(point => point.toJSON()); // JSON of points after simplification\n        const numPolylinePoints = polylinePoints.length; // number of points after simplification\n        // set simplified polyline points as link vertices\n        // remove first and last polyline points (= source/target sonnectionPoints)\n        link.set('vertices', polylinePoints.slice(1, numPolylinePoints - 1));\n      }\n    }\n    if (opt.setLabels && 'x' in glEdge && 'y' in glEdge) {\n      const labelPosition = {\n        x: glEdge.x,\n        y: glEdge.y\n      };\n      if (util.isFunction(opt.setLabels)) {\n        opt.setLabels(link, labelPosition, points);\n      } else {\n        // convert the absolute label position to a relative position\n        // towards the closest point on the edge\n        const length = polyline.closestPointLength(labelPosition);\n        const closestPoint = polyline.pointAtLength(length);\n        const distance = length / polyline.length();\n        const offset = new g.Point(labelPosition).difference(closestPoint).toJSON();\n        link.label(0, {\n          position: {\n            distance: distance,\n            offset: offset\n          }\n        });\n      }\n    }\n  },\n  layout: function (graphOrCells, opt) {\n    var graph;\n    if (graphOrCells instanceof Graph) {\n      graph = graphOrCells;\n    } else {\n      // Reset cells in dry mode so the graph reference is not stored on the cells.\n      // `sort: false` to prevent elements to change their order based on the z-index\n      graph = new Graph().resetCells(graphOrCells, {\n        dry: true,\n        sort: false\n      });\n    }\n\n    // This is not needed anymore.\n    graphOrCells = null;\n    opt = util.defaults(opt || {}, {\n      resizeClusters: true,\n      clusterPadding: 10,\n      exportElement: this.exportElement,\n      exportLink: this.exportLink\n    });\n\n    /* eslint-disable no-undef */\n    const dagreUtil = opt.dagre || (typeof dagre !== 'undefined' ? dagre : undefined);\n    /* eslint-enable no-undef */\n\n    if (dagreUtil === undefined) throw new Error('The the \"dagre\" utility is a mandatory dependency.');\n\n    // create a graphlib.Graph that represents the joint.dia.Graph\n    // var glGraph = graph.toGraphLib({\n    var glGraph = DirectedGraph.toGraphLib(graph, {\n      graphlib: opt.graphlib,\n      directed: true,\n      // We are about to use edge naming feature.\n      multigraph: true,\n      // We are able to layout graphs with embeds.\n      compound: true,\n      setNodeLabel: opt.exportElement,\n      setEdgeLabel: opt.exportLink,\n      setEdgeName: function (link) {\n        // Graphlib edges have no ids. We use edge name property\n        // to store and retrieve ids instead.\n        return link.id;\n      }\n    });\n    var glLabel = {};\n    var marginX = opt.marginX || 0;\n    var marginY = opt.marginY || 0;\n\n    // Dagre layout accepts options as lower case.\n    // Direction for rank nodes. Can be TB, BT, LR, or RL\n    if (opt.rankDir) glLabel.rankdir = opt.rankDir;\n    // Alignment for rank nodes. Can be UL, UR, DL, or DR\n    if (opt.align) glLabel.align = opt.align;\n    // Number of pixels that separate nodes horizontally in the layout.\n    if (opt.nodeSep) glLabel.nodesep = opt.nodeSep;\n    // Number of pixels that separate edges horizontally in the layout.\n    if (opt.edgeSep) glLabel.edgesep = opt.edgeSep;\n    // Number of pixels between each rank in the layout.\n    if (opt.rankSep) glLabel.ranksep = opt.rankSep;\n    // Type of algorithm to assign a rank to each node in the input graph.\n    // Possible values: network-simplex, tight-tree or longest-path\n    if (opt.ranker) glLabel.ranker = opt.ranker;\n    // Number of pixels to use as a margin around the left and right of the graph.\n    if (marginX) glLabel.marginx = marginX;\n    // Number of pixels to use as a margin around the top and bottom of the graph.\n    if (marginY) glLabel.marginy = marginY;\n\n    // Set the option object for the graph label.\n    glGraph.setGraph(glLabel);\n\n    // Executes the layout.\n    dagreUtil.layout(glGraph, {\n      debugTiming: !!opt.debugTiming\n    });\n\n    // Wrap all graph changes into a batch.\n    graph.startBatch('layout');\n    DirectedGraph.fromGraphLib(glGraph, {\n      importNode: this.importElement.bind(graph, opt),\n      importEdge: this.importLink.bind(graph, opt)\n    });\n\n    // // Update the graph.\n    // graph.fromGraphLib(glGraph, {\n    //     importNode: this.importElement.bind(graph, opt),\n    //     importEdge: this.importLink.bind(graph, opt)\n    // });\n\n    if (opt.resizeClusters) {\n      // Resize and reposition cluster elements (parents of other elements)\n      // to fit their children.\n      // 1. filter clusters only\n      // 2. map id on cells\n      // 3. sort cells by their depth (the deepest first)\n      // 4. resize cell to fit their direct children only.\n      var clusters = glGraph.nodes().filter(function (v) {\n        return glGraph.children(v).length > 0;\n      }).map(graph.getCell.bind(graph)).sort(function (aCluster, bCluster) {\n        return bCluster.getAncestors().length - aCluster.getAncestors().length;\n      });\n      util.invoke(clusters, 'fitToChildren', {\n        padding: opt.clusterPadding\n      });\n    }\n    graph.stopBatch('layout');\n\n    // Width and height of the graph extended by margins.\n    var glSize = glGraph.graph();\n    // Return the bounding box of the graph after the layout.\n    return new g.Rect(marginX, marginY, Math.abs(glSize.width - 2 * marginX), Math.abs(glSize.height - 2 * marginY));\n  },\n  fromGraphLib: function (glGraph, opt) {\n    opt = opt || {};\n    var importNode = opt.importNode || util.noop;\n    var importEdge = opt.importEdge || util.noop;\n    var graph = this instanceof Graph ? this : new Graph();\n\n    // Import all nodes.\n    glGraph.nodes().forEach(function (node) {\n      importNode.call(graph, node, glGraph, graph, opt);\n    });\n\n    // Import all edges.\n    glGraph.edges().forEach(function (edge) {\n      importEdge.call(graph, edge, glGraph, graph, opt);\n    });\n    return graph;\n  },\n  // Create new graphlib graph from existing JointJS graph.\n  toGraphLib: function (graph, opt) {\n    opt = opt || {};\n\n    /* eslint-disable no-undef */\n    const graphlibUtil = opt.graphlib || (typeof graphlib !== 'undefined' ? graphlib : undefined);\n    /* eslint-enable no-undef */\n\n    if (graphlibUtil === undefined) throw new Error('The the \"graphlib\" utility is a mandatory dependency.');\n    var glGraphType = util.pick(opt, 'directed', 'compound', 'multigraph');\n    var glGraph = new graphlibUtil.Graph(glGraphType);\n    var setNodeLabel = opt.setNodeLabel || util.noop;\n    var setEdgeLabel = opt.setEdgeLabel || util.noop;\n    var setEdgeName = opt.setEdgeName || util.noop;\n    var collection = graph.get('cells');\n    for (var i = 0, n = collection.length; i < n; i++) {\n      var cell = collection.at(i);\n      if (cell.isLink()) {\n        var source = cell.get('source');\n        var target = cell.get('target');\n\n        // Links that end at a point are ignored.\n        if (!source.id || !target.id) break;\n\n        // Note that if we are creating a multigraph we can name the edges. If\n        // we try to name edges on a non-multigraph an exception is thrown.\n        glGraph.setEdge(source.id, target.id, setEdgeLabel(cell), setEdgeName(cell));\n      } else {\n        glGraph.setNode(cell.id, setNodeLabel(cell));\n\n        // For the compound graphs we have to take embeds into account.\n        if (glGraph.isCompound() && cell.has('parent')) {\n          var parentId = cell.get('parent');\n          if (collection.has(parentId)) {\n            // Make sure the parent cell is included in the graph (this can\n            // happen when the layout is run on part of the graph only).\n            glGraph.setParent(cell.id, parentId);\n          }\n        }\n      }\n    }\n    return glGraph;\n  }\n};\nGraph.prototype.toGraphLib = function (opt) {\n  return DirectedGraph.toGraphLib(this, opt);\n};\nGraph.prototype.fromGraphLib = function (glGraph, opt) {\n  return DirectedGraph.fromGraphLib.call(this, glGraph, opt);\n};","map":{"version":3,"names":["util","Graph","g","DirectedGraph","exportElement","element","size","exportLink","link","labelSize","get","edge","minLen","weight","labelpos","labeloffset","width","height","importElement","opt","v","gl","getCell","glNode","node","setPosition","set","x","y","importLink","edgeObj","SIMPLIFY_THRESHOLD","name","glEdge","points","polyline","Polyline","setVertices","setLinkVertices","isFunction","simplify","threshold","polylinePoints","map","point","toJSON","numPolylinePoints","length","slice","setLabels","labelPosition","closestPointLength","closestPoint","pointAtLength","distance","offset","Point","difference","label","position","layout","graphOrCells","graph","resetCells","dry","sort","defaults","resizeClusters","clusterPadding","dagreUtil","dagre","undefined","Error","glGraph","toGraphLib","graphlib","directed","multigraph","compound","setNodeLabel","setEdgeLabel","setEdgeName","id","glLabel","marginX","marginY","rankDir","rankdir","align","nodeSep","nodesep","edgeSep","edgesep","rankSep","ranksep","ranker","marginx","marginy","setGraph","debugTiming","startBatch","fromGraphLib","importNode","bind","importEdge","clusters","nodes","filter","children","aCluster","bCluster","getAncestors","invoke","padding","stopBatch","glSize","Rect","Math","abs","noop","forEach","call","edges","graphlibUtil","glGraphType","pick","collection","i","n","cell","at","isLink","source","target","setEdge","setNode","isCompound","has","parentId","setParent","prototype"],"sources":["/Users/lijiaxin/Documents/workspace/hydsoft-oms-frontend/node_modules/jointjs/src/layout/DirectedGraph/DirectedGraph.mjs"],"sourcesContent":["import * as util from '../../util/index.mjs';\nimport { Graph } from '../../dia/index.mjs';\nimport * as g from '../../g/index.mjs';\n\nexport const DirectedGraph = {\n\n    exportElement: function(element) {\n\n        // The width and height of the element.\n        return element.size();\n    },\n\n    exportLink: function(link) {\n\n        var labelSize = link.get('labelSize') || {};\n        var edge = {\n            // The number of ranks to keep between the source and target of the edge.\n            minLen: link.get('minLen') || 1,\n            // The weight to assign edges. Higher weight edges are generally\n            // made shorter and straighter than lower weight edges.\n            weight: link.get('weight') || 1,\n            // Where to place the label relative to the edge.\n            // l = left, c = center r = right.\n            labelpos: link.get('labelPosition') || 'c',\n            // How many pixels to move the label away from the edge.\n            // Applies only when labelpos is l or r.\n            labeloffset: link.get('labelOffset') || 0,\n            // The width of the edge label in pixels.\n            width: labelSize.width || 0,\n            // The height of the edge label in pixels.\n            height: labelSize.height || 0\n        };\n\n        return edge;\n    },\n\n    importElement: function(opt, v, gl) {\n\n        var element = this.getCell(v);\n        var glNode = gl.node(v);\n\n        if (opt.setPosition) {\n            opt.setPosition(element, glNode);\n        } else {\n            element.set('position', {\n                x: glNode.x - glNode.width / 2,\n                y: glNode.y - glNode.height / 2\n            });\n        }\n    },\n\n    importLink: function(opt, edgeObj, gl) {\n\n        const SIMPLIFY_THRESHOLD = 0.001;\n\n        const link = this.getCell(edgeObj.name);\n        const glEdge = gl.edge(edgeObj);\n        const points = glEdge.points || [];\n        const polyline = new g.Polyline(points);\n\n        // check the `setLinkVertices` here for backwards compatibility\n        if (opt.setVertices || opt.setLinkVertices) {\n            if (util.isFunction(opt.setVertices)) {\n                opt.setVertices(link, points);\n            } else {\n                // simplify the `points` polyline\n                polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n                const polylinePoints = polyline.points.map((point) => (point.toJSON())); // JSON of points after simplification\n                const numPolylinePoints = polylinePoints.length; // number of points after simplification\n                // set simplified polyline points as link vertices\n                // remove first and last polyline points (= source/target sonnectionPoints)\n                link.set('vertices', polylinePoints.slice(1, numPolylinePoints - 1));\n            }\n        }\n\n        if (opt.setLabels && ('x' in glEdge) && ('y' in glEdge)) {\n            const labelPosition = { x: glEdge.x, y: glEdge.y };\n            if (util.isFunction(opt.setLabels)) {\n                opt.setLabels(link, labelPosition, points);\n            } else {\n                // convert the absolute label position to a relative position\n                // towards the closest point on the edge\n                const length = polyline.closestPointLength(labelPosition);\n                const closestPoint = polyline.pointAtLength(length);\n                const distance = (length / polyline.length());\n                const offset = new g.Point(labelPosition).difference(closestPoint).toJSON();\n                link.label(0, {\n                    position: {\n                        distance: distance,\n                        offset: offset\n                    }\n                });\n            }\n        }\n    },\n\n    layout: function(graphOrCells, opt) {\n\n        var graph;\n\n        if (graphOrCells instanceof Graph) {\n            graph = graphOrCells;\n        } else {\n            // Reset cells in dry mode so the graph reference is not stored on the cells.\n            // `sort: false` to prevent elements to change their order based on the z-index\n            graph = (new Graph()).resetCells(graphOrCells, { dry: true, sort: false });\n        }\n\n        // This is not needed anymore.\n        graphOrCells = null;\n\n        opt = util.defaults(opt || {}, {\n            resizeClusters: true,\n            clusterPadding: 10,\n            exportElement: this.exportElement,\n            exportLink: this.exportLink\n        });\n\n        /* eslint-disable no-undef */\n        const dagreUtil = opt.dagre || (typeof dagre !== 'undefined' ? dagre : undefined);\n        /* eslint-enable no-undef */\n\n        if (dagreUtil === undefined) throw new Error('The the \"dagre\" utility is a mandatory dependency.');\n\n        // create a graphlib.Graph that represents the joint.dia.Graph\n        // var glGraph = graph.toGraphLib({\n        var glGraph = DirectedGraph.toGraphLib(graph, {\n            graphlib: opt.graphlib,\n            directed: true,\n            // We are about to use edge naming feature.\n            multigraph: true,\n            // We are able to layout graphs with embeds.\n            compound: true,\n            setNodeLabel: opt.exportElement,\n            setEdgeLabel: opt.exportLink,\n            setEdgeName: function(link) {\n                // Graphlib edges have no ids. We use edge name property\n                // to store and retrieve ids instead.\n                return link.id;\n            }\n        });\n\n        var glLabel = {};\n        var marginX = opt.marginX || 0;\n        var marginY = opt.marginY || 0;\n\n        // Dagre layout accepts options as lower case.\n        // Direction for rank nodes. Can be TB, BT, LR, or RL\n        if (opt.rankDir) glLabel.rankdir = opt.rankDir;\n        // Alignment for rank nodes. Can be UL, UR, DL, or DR\n        if (opt.align) glLabel.align = opt.align;\n        // Number of pixels that separate nodes horizontally in the layout.\n        if (opt.nodeSep) glLabel.nodesep = opt.nodeSep;\n        // Number of pixels that separate edges horizontally in the layout.\n        if (opt.edgeSep) glLabel.edgesep = opt.edgeSep;\n        // Number of pixels between each rank in the layout.\n        if (opt.rankSep) glLabel.ranksep = opt.rankSep;\n        // Type of algorithm to assign a rank to each node in the input graph.\n        // Possible values: network-simplex, tight-tree or longest-path\n        if (opt.ranker) glLabel.ranker = opt.ranker;\n        // Number of pixels to use as a margin around the left and right of the graph.\n        if (marginX) glLabel.marginx = marginX;\n        // Number of pixels to use as a margin around the top and bottom of the graph.\n        if (marginY) glLabel.marginy = marginY;\n\n        // Set the option object for the graph label.\n        glGraph.setGraph(glLabel);\n\n        // Executes the layout.\n        dagreUtil.layout(glGraph, { debugTiming: !!opt.debugTiming });\n\n        // Wrap all graph changes into a batch.\n        graph.startBatch('layout');\n\n        DirectedGraph.fromGraphLib(glGraph, {\n            importNode: this.importElement.bind(graph, opt),\n            importEdge: this.importLink.bind(graph, opt)\n        });\n\n        // // Update the graph.\n        // graph.fromGraphLib(glGraph, {\n        //     importNode: this.importElement.bind(graph, opt),\n        //     importEdge: this.importLink.bind(graph, opt)\n        // });\n\n        if (opt.resizeClusters) {\n            // Resize and reposition cluster elements (parents of other elements)\n            // to fit their children.\n            // 1. filter clusters only\n            // 2. map id on cells\n            // 3. sort cells by their depth (the deepest first)\n            // 4. resize cell to fit their direct children only.\n            var clusters = glGraph.nodes()\n                .filter(function(v) { return glGraph.children(v).length > 0; })\n                .map(graph.getCell.bind(graph))\n                .sort(function(aCluster, bCluster) {\n                    return bCluster.getAncestors().length - aCluster.getAncestors().length;\n                });\n\n            util.invoke(clusters, 'fitToChildren', { padding: opt.clusterPadding });\n        }\n\n        graph.stopBatch('layout');\n\n        // Width and height of the graph extended by margins.\n        var glSize = glGraph.graph();\n        // Return the bounding box of the graph after the layout.\n        return new g.Rect(\n            marginX,\n            marginY,\n            Math.abs(glSize.width - 2 * marginX),\n            Math.abs(glSize.height - 2 * marginY)\n        );\n    },\n\n    fromGraphLib: function(glGraph, opt) {\n\n        opt = opt || {};\n\n        var importNode = opt.importNode || util.noop;\n        var importEdge = opt.importEdge || util.noop;\n        var graph = (this instanceof Graph) ? this : new Graph;\n\n        // Import all nodes.\n        glGraph.nodes().forEach(function(node) {\n            importNode.call(graph, node, glGraph, graph, opt);\n        });\n\n        // Import all edges.\n        glGraph.edges().forEach(function(edge) {\n            importEdge.call(graph, edge, glGraph, graph, opt);\n        });\n\n        return graph;\n    },\n\n    // Create new graphlib graph from existing JointJS graph.\n    toGraphLib: function(graph, opt) {\n\n        opt = opt || {};\n\n        /* eslint-disable no-undef */\n        const graphlibUtil = opt.graphlib || (typeof graphlib !== 'undefined' ? graphlib : undefined);\n        /* eslint-enable no-undef */\n\n        if (graphlibUtil === undefined) throw new Error('The the \"graphlib\" utility is a mandatory dependency.');\n\n        var glGraphType = util.pick(opt, 'directed', 'compound', 'multigraph');\n        var glGraph = new graphlibUtil.Graph(glGraphType);\n        var setNodeLabel = opt.setNodeLabel || util.noop;\n        var setEdgeLabel = opt.setEdgeLabel || util.noop;\n        var setEdgeName = opt.setEdgeName || util.noop;\n        var collection = graph.get('cells');\n\n        for (var i = 0, n = collection.length; i < n; i++) {\n\n            var cell = collection.at(i);\n            if (cell.isLink()) {\n\n                var source = cell.get('source');\n                var target = cell.get('target');\n\n                // Links that end at a point are ignored.\n                if (!source.id || !target.id) break;\n\n                // Note that if we are creating a multigraph we can name the edges. If\n                // we try to name edges on a non-multigraph an exception is thrown.\n                glGraph.setEdge(source.id, target.id, setEdgeLabel(cell), setEdgeName(cell));\n\n            } else {\n\n                glGraph.setNode(cell.id, setNodeLabel(cell));\n\n                // For the compound graphs we have to take embeds into account.\n                if (glGraph.isCompound() && cell.has('parent')) {\n                    var parentId = cell.get('parent');\n                    if (collection.has(parentId)) {\n                        // Make sure the parent cell is included in the graph (this can\n                        // happen when the layout is run on part of the graph only).\n                        glGraph.setParent(cell.id, parentId);\n                    }\n                }\n            }\n        }\n\n        return glGraph;\n    }\n};\n\nGraph.prototype.toGraphLib = function(opt) {\n\n    return DirectedGraph.toGraphLib(this, opt);\n};\n\nGraph.prototype.fromGraphLib = function(glGraph, opt) {\n\n    return DirectedGraph.fromGraphLib.call(this, glGraph, opt);\n};\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,sBAAsB;AAC5C,SAASC,KAAK,QAAQ,qBAAqB;AAC3C,OAAO,KAAKC,CAAC,MAAM,mBAAmB;AAEtC,OAAO,MAAMC,aAAa,GAAG;EAEzBC,aAAa,EAAE,SAAAA,CAASC,OAAO,EAAE;IAE7B;IACA,OAAOA,OAAO,CAACC,IAAI,CAAC,CAAC;EACzB,CAAC;EAEDC,UAAU,EAAE,SAAAA,CAASC,IAAI,EAAE;IAEvB,IAAIC,SAAS,GAAGD,IAAI,CAACE,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAC3C,IAAIC,IAAI,GAAG;MACP;MACAC,MAAM,EAAEJ,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC;MAC/B;MACA;MACAG,MAAM,EAAEL,IAAI,CAACE,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC;MAC/B;MACA;MACAI,QAAQ,EAAEN,IAAI,CAACE,GAAG,CAAC,eAAe,CAAC,IAAI,GAAG;MAC1C;MACA;MACAK,WAAW,EAAEP,IAAI,CAACE,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC;MACzC;MACAM,KAAK,EAAEP,SAAS,CAACO,KAAK,IAAI,CAAC;MAC3B;MACAC,MAAM,EAAER,SAAS,CAACQ,MAAM,IAAI;IAChC,CAAC;IAED,OAAON,IAAI;EACf,CAAC;EAEDO,aAAa,EAAE,SAAAA,CAASC,GAAG,EAAEC,CAAC,EAAEC,EAAE,EAAE;IAEhC,IAAIhB,OAAO,GAAG,IAAI,CAACiB,OAAO,CAACF,CAAC,CAAC;IAC7B,IAAIG,MAAM,GAAGF,EAAE,CAACG,IAAI,CAACJ,CAAC,CAAC;IAEvB,IAAID,GAAG,CAACM,WAAW,EAAE;MACjBN,GAAG,CAACM,WAAW,CAACpB,OAAO,EAAEkB,MAAM,CAAC;IACpC,CAAC,MAAM;MACHlB,OAAO,CAACqB,GAAG,CAAC,UAAU,EAAE;QACpBC,CAAC,EAAEJ,MAAM,CAACI,CAAC,GAAGJ,MAAM,CAACP,KAAK,GAAG,CAAC;QAC9BY,CAAC,EAAEL,MAAM,CAACK,CAAC,GAAGL,MAAM,CAACN,MAAM,GAAG;MAClC,CAAC,CAAC;IACN;EACJ,CAAC;EAEDY,UAAU,EAAE,SAAAA,CAASV,GAAG,EAAEW,OAAO,EAAET,EAAE,EAAE;IAEnC,MAAMU,kBAAkB,GAAG,KAAK;IAEhC,MAAMvB,IAAI,GAAG,IAAI,CAACc,OAAO,CAACQ,OAAO,CAACE,IAAI,CAAC;IACvC,MAAMC,MAAM,GAAGZ,EAAE,CAACV,IAAI,CAACmB,OAAO,CAAC;IAC/B,MAAMI,MAAM,GAAGD,MAAM,CAACC,MAAM,IAAI,EAAE;IAClC,MAAMC,QAAQ,GAAG,IAAIjC,CAAC,CAACkC,QAAQ,CAACF,MAAM,CAAC;;IAEvC;IACA,IAAIf,GAAG,CAACkB,WAAW,IAAIlB,GAAG,CAACmB,eAAe,EAAE;MACxC,IAAItC,IAAI,CAACuC,UAAU,CAACpB,GAAG,CAACkB,WAAW,CAAC,EAAE;QAClClB,GAAG,CAACkB,WAAW,CAAC7B,IAAI,EAAE0B,MAAM,CAAC;MACjC,CAAC,MAAM;QACH;QACAC,QAAQ,CAACK,QAAQ,CAAC;UAAEC,SAAS,EAAEV;QAAmB,CAAC,CAAC;QACpD,MAAMW,cAAc,GAAGP,QAAQ,CAACD,MAAM,CAACS,GAAG,CAAEC,KAAK,IAAMA,KAAK,CAACC,MAAM,CAAC,CAAE,CAAC,CAAC,CAAC;QACzE,MAAMC,iBAAiB,GAAGJ,cAAc,CAACK,MAAM,CAAC,CAAC;QACjD;QACA;QACAvC,IAAI,CAACkB,GAAG,CAAC,UAAU,EAAEgB,cAAc,CAACM,KAAK,CAAC,CAAC,EAAEF,iBAAiB,GAAG,CAAC,CAAC,CAAC;MACxE;IACJ;IAEA,IAAI3B,GAAG,CAAC8B,SAAS,IAAK,GAAG,IAAIhB,MAAO,IAAK,GAAG,IAAIA,MAAO,EAAE;MACrD,MAAMiB,aAAa,GAAG;QAAEvB,CAAC,EAAEM,MAAM,CAACN,CAAC;QAAEC,CAAC,EAAEK,MAAM,CAACL;MAAE,CAAC;MAClD,IAAI5B,IAAI,CAACuC,UAAU,CAACpB,GAAG,CAAC8B,SAAS,CAAC,EAAE;QAChC9B,GAAG,CAAC8B,SAAS,CAACzC,IAAI,EAAE0C,aAAa,EAAEhB,MAAM,CAAC;MAC9C,CAAC,MAAM;QACH;QACA;QACA,MAAMa,MAAM,GAAGZ,QAAQ,CAACgB,kBAAkB,CAACD,aAAa,CAAC;QACzD,MAAME,YAAY,GAAGjB,QAAQ,CAACkB,aAAa,CAACN,MAAM,CAAC;QACnD,MAAMO,QAAQ,GAAIP,MAAM,GAAGZ,QAAQ,CAACY,MAAM,CAAC,CAAE;QAC7C,MAAMQ,MAAM,GAAG,IAAIrD,CAAC,CAACsD,KAAK,CAACN,aAAa,CAAC,CAACO,UAAU,CAACL,YAAY,CAAC,CAACP,MAAM,CAAC,CAAC;QAC3ErC,IAAI,CAACkD,KAAK,CAAC,CAAC,EAAE;UACVC,QAAQ,EAAE;YACNL,QAAQ,EAAEA,QAAQ;YAClBC,MAAM,EAAEA;UACZ;QACJ,CAAC,CAAC;MACN;IACJ;EACJ,CAAC;EAEDK,MAAM,EAAE,SAAAA,CAASC,YAAY,EAAE1C,GAAG,EAAE;IAEhC,IAAI2C,KAAK;IAET,IAAID,YAAY,YAAY5D,KAAK,EAAE;MAC/B6D,KAAK,GAAGD,YAAY;IACxB,CAAC,MAAM;MACH;MACA;MACAC,KAAK,GAAI,IAAI7D,KAAK,CAAC,CAAC,CAAE8D,UAAU,CAACF,YAAY,EAAE;QAAEG,GAAG,EAAE,IAAI;QAAEC,IAAI,EAAE;MAAM,CAAC,CAAC;IAC9E;;IAEA;IACAJ,YAAY,GAAG,IAAI;IAEnB1C,GAAG,GAAGnB,IAAI,CAACkE,QAAQ,CAAC/C,GAAG,IAAI,CAAC,CAAC,EAAE;MAC3BgD,cAAc,EAAE,IAAI;MACpBC,cAAc,EAAE,EAAE;MAClBhE,aAAa,EAAE,IAAI,CAACA,aAAa;MACjCG,UAAU,EAAE,IAAI,CAACA;IACrB,CAAC,CAAC;;IAEF;IACA,MAAM8D,SAAS,GAAGlD,GAAG,CAACmD,KAAK,KAAK,OAAOA,KAAK,KAAK,WAAW,GAAGA,KAAK,GAAGC,SAAS,CAAC;IACjF;;IAEA,IAAIF,SAAS,KAAKE,SAAS,EAAE,MAAM,IAAIC,KAAK,CAAC,oDAAoD,CAAC;;IAElG;IACA;IACA,IAAIC,OAAO,GAAGtE,aAAa,CAACuE,UAAU,CAACZ,KAAK,EAAE;MAC1Ca,QAAQ,EAAExD,GAAG,CAACwD,QAAQ;MACtBC,QAAQ,EAAE,IAAI;MACd;MACAC,UAAU,EAAE,IAAI;MAChB;MACAC,QAAQ,EAAE,IAAI;MACdC,YAAY,EAAE5D,GAAG,CAACf,aAAa;MAC/B4E,YAAY,EAAE7D,GAAG,CAACZ,UAAU;MAC5B0E,WAAW,EAAE,SAAAA,CAASzE,IAAI,EAAE;QACxB;QACA;QACA,OAAOA,IAAI,CAAC0E,EAAE;MAClB;IACJ,CAAC,CAAC;IAEF,IAAIC,OAAO,GAAG,CAAC,CAAC;IAChB,IAAIC,OAAO,GAAGjE,GAAG,CAACiE,OAAO,IAAI,CAAC;IAC9B,IAAIC,OAAO,GAAGlE,GAAG,CAACkE,OAAO,IAAI,CAAC;;IAE9B;IACA;IACA,IAAIlE,GAAG,CAACmE,OAAO,EAAEH,OAAO,CAACI,OAAO,GAAGpE,GAAG,CAACmE,OAAO;IAC9C;IACA,IAAInE,GAAG,CAACqE,KAAK,EAAEL,OAAO,CAACK,KAAK,GAAGrE,GAAG,CAACqE,KAAK;IACxC;IACA,IAAIrE,GAAG,CAACsE,OAAO,EAAEN,OAAO,CAACO,OAAO,GAAGvE,GAAG,CAACsE,OAAO;IAC9C;IACA,IAAItE,GAAG,CAACwE,OAAO,EAAER,OAAO,CAACS,OAAO,GAAGzE,GAAG,CAACwE,OAAO;IAC9C;IACA,IAAIxE,GAAG,CAAC0E,OAAO,EAAEV,OAAO,CAACW,OAAO,GAAG3E,GAAG,CAAC0E,OAAO;IAC9C;IACA;IACA,IAAI1E,GAAG,CAAC4E,MAAM,EAAEZ,OAAO,CAACY,MAAM,GAAG5E,GAAG,CAAC4E,MAAM;IAC3C;IACA,IAAIX,OAAO,EAAED,OAAO,CAACa,OAAO,GAAGZ,OAAO;IACtC;IACA,IAAIC,OAAO,EAAEF,OAAO,CAACc,OAAO,GAAGZ,OAAO;;IAEtC;IACAZ,OAAO,CAACyB,QAAQ,CAACf,OAAO,CAAC;;IAEzB;IACAd,SAAS,CAACT,MAAM,CAACa,OAAO,EAAE;MAAE0B,WAAW,EAAE,CAAC,CAAChF,GAAG,CAACgF;IAAY,CAAC,CAAC;;IAE7D;IACArC,KAAK,CAACsC,UAAU,CAAC,QAAQ,CAAC;IAE1BjG,aAAa,CAACkG,YAAY,CAAC5B,OAAO,EAAE;MAChC6B,UAAU,EAAE,IAAI,CAACpF,aAAa,CAACqF,IAAI,CAACzC,KAAK,EAAE3C,GAAG,CAAC;MAC/CqF,UAAU,EAAE,IAAI,CAAC3E,UAAU,CAAC0E,IAAI,CAACzC,KAAK,EAAE3C,GAAG;IAC/C,CAAC,CAAC;;IAEF;IACA;IACA;IACA;IACA;;IAEA,IAAIA,GAAG,CAACgD,cAAc,EAAE;MACpB;MACA;MACA;MACA;MACA;MACA;MACA,IAAIsC,QAAQ,GAAGhC,OAAO,CAACiC,KAAK,CAAC,CAAC,CACzBC,MAAM,CAAC,UAASvF,CAAC,EAAE;QAAE,OAAOqD,OAAO,CAACmC,QAAQ,CAACxF,CAAC,CAAC,CAAC2B,MAAM,GAAG,CAAC;MAAE,CAAC,CAAC,CAC9DJ,GAAG,CAACmB,KAAK,CAACxC,OAAO,CAACiF,IAAI,CAACzC,KAAK,CAAC,CAAC,CAC9BG,IAAI,CAAC,UAAS4C,QAAQ,EAAEC,QAAQ,EAAE;QAC/B,OAAOA,QAAQ,CAACC,YAAY,CAAC,CAAC,CAAChE,MAAM,GAAG8D,QAAQ,CAACE,YAAY,CAAC,CAAC,CAAChE,MAAM;MAC1E,CAAC,CAAC;MAEN/C,IAAI,CAACgH,MAAM,CAACP,QAAQ,EAAE,eAAe,EAAE;QAAEQ,OAAO,EAAE9F,GAAG,CAACiD;MAAe,CAAC,CAAC;IAC3E;IAEAN,KAAK,CAACoD,SAAS,CAAC,QAAQ,CAAC;;IAEzB;IACA,IAAIC,MAAM,GAAG1C,OAAO,CAACX,KAAK,CAAC,CAAC;IAC5B;IACA,OAAO,IAAI5D,CAAC,CAACkH,IAAI,CACbhC,OAAO,EACPC,OAAO,EACPgC,IAAI,CAACC,GAAG,CAACH,MAAM,CAACnG,KAAK,GAAG,CAAC,GAAGoE,OAAO,CAAC,EACpCiC,IAAI,CAACC,GAAG,CAACH,MAAM,CAAClG,MAAM,GAAG,CAAC,GAAGoE,OAAO,CACxC,CAAC;EACL,CAAC;EAEDgB,YAAY,EAAE,SAAAA,CAAS5B,OAAO,EAAEtD,GAAG,EAAE;IAEjCA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;IAEf,IAAImF,UAAU,GAAGnF,GAAG,CAACmF,UAAU,IAAItG,IAAI,CAACuH,IAAI;IAC5C,IAAIf,UAAU,GAAGrF,GAAG,CAACqF,UAAU,IAAIxG,IAAI,CAACuH,IAAI;IAC5C,IAAIzD,KAAK,GAAI,IAAI,YAAY7D,KAAK,GAAI,IAAI,GAAG,IAAIA,KAAK,CAAD,CAAC;;IAEtD;IACAwE,OAAO,CAACiC,KAAK,CAAC,CAAC,CAACc,OAAO,CAAC,UAAShG,IAAI,EAAE;MACnC8E,UAAU,CAACmB,IAAI,CAAC3D,KAAK,EAAEtC,IAAI,EAAEiD,OAAO,EAAEX,KAAK,EAAE3C,GAAG,CAAC;IACrD,CAAC,CAAC;;IAEF;IACAsD,OAAO,CAACiD,KAAK,CAAC,CAAC,CAACF,OAAO,CAAC,UAAS7G,IAAI,EAAE;MACnC6F,UAAU,CAACiB,IAAI,CAAC3D,KAAK,EAAEnD,IAAI,EAAE8D,OAAO,EAAEX,KAAK,EAAE3C,GAAG,CAAC;IACrD,CAAC,CAAC;IAEF,OAAO2C,KAAK;EAChB,CAAC;EAED;EACAY,UAAU,EAAE,SAAAA,CAASZ,KAAK,EAAE3C,GAAG,EAAE;IAE7BA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;;IAEf;IACA,MAAMwG,YAAY,GAAGxG,GAAG,CAACwD,QAAQ,KAAK,OAAOA,QAAQ,KAAK,WAAW,GAAGA,QAAQ,GAAGJ,SAAS,CAAC;IAC7F;;IAEA,IAAIoD,YAAY,KAAKpD,SAAS,EAAE,MAAM,IAAIC,KAAK,CAAC,uDAAuD,CAAC;IAExG,IAAIoD,WAAW,GAAG5H,IAAI,CAAC6H,IAAI,CAAC1G,GAAG,EAAE,UAAU,EAAE,UAAU,EAAE,YAAY,CAAC;IACtE,IAAIsD,OAAO,GAAG,IAAIkD,YAAY,CAAC1H,KAAK,CAAC2H,WAAW,CAAC;IACjD,IAAI7C,YAAY,GAAG5D,GAAG,CAAC4D,YAAY,IAAI/E,IAAI,CAACuH,IAAI;IAChD,IAAIvC,YAAY,GAAG7D,GAAG,CAAC6D,YAAY,IAAIhF,IAAI,CAACuH,IAAI;IAChD,IAAItC,WAAW,GAAG9D,GAAG,CAAC8D,WAAW,IAAIjF,IAAI,CAACuH,IAAI;IAC9C,IAAIO,UAAU,GAAGhE,KAAK,CAACpD,GAAG,CAAC,OAAO,CAAC;IAEnC,KAAK,IAAIqH,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGF,UAAU,CAAC/E,MAAM,EAAEgF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAE/C,IAAIE,IAAI,GAAGH,UAAU,CAACI,EAAE,CAACH,CAAC,CAAC;MAC3B,IAAIE,IAAI,CAACE,MAAM,CAAC,CAAC,EAAE;QAEf,IAAIC,MAAM,GAAGH,IAAI,CAACvH,GAAG,CAAC,QAAQ,CAAC;QAC/B,IAAI2H,MAAM,GAAGJ,IAAI,CAACvH,GAAG,CAAC,QAAQ,CAAC;;QAE/B;QACA,IAAI,CAAC0H,MAAM,CAAClD,EAAE,IAAI,CAACmD,MAAM,CAACnD,EAAE,EAAE;;QAE9B;QACA;QACAT,OAAO,CAAC6D,OAAO,CAACF,MAAM,CAAClD,EAAE,EAAEmD,MAAM,CAACnD,EAAE,EAAEF,YAAY,CAACiD,IAAI,CAAC,EAAEhD,WAAW,CAACgD,IAAI,CAAC,CAAC;MAEhF,CAAC,MAAM;QAEHxD,OAAO,CAAC8D,OAAO,CAACN,IAAI,CAAC/C,EAAE,EAAEH,YAAY,CAACkD,IAAI,CAAC,CAAC;;QAE5C;QACA,IAAIxD,OAAO,CAAC+D,UAAU,CAAC,CAAC,IAAIP,IAAI,CAACQ,GAAG,CAAC,QAAQ,CAAC,EAAE;UAC5C,IAAIC,QAAQ,GAAGT,IAAI,CAACvH,GAAG,CAAC,QAAQ,CAAC;UACjC,IAAIoH,UAAU,CAACW,GAAG,CAACC,QAAQ,CAAC,EAAE;YAC1B;YACA;YACAjE,OAAO,CAACkE,SAAS,CAACV,IAAI,CAAC/C,EAAE,EAAEwD,QAAQ,CAAC;UACxC;QACJ;MACJ;IACJ;IAEA,OAAOjE,OAAO;EAClB;AACJ,CAAC;AAEDxE,KAAK,CAAC2I,SAAS,CAAClE,UAAU,GAAG,UAASvD,GAAG,EAAE;EAEvC,OAAOhB,aAAa,CAACuE,UAAU,CAAC,IAAI,EAAEvD,GAAG,CAAC;AAC9C,CAAC;AAEDlB,KAAK,CAAC2I,SAAS,CAACvC,YAAY,GAAG,UAAS5B,OAAO,EAAEtD,GAAG,EAAE;EAElD,OAAOhB,aAAa,CAACkG,YAAY,CAACoB,IAAI,CAAC,IAAI,EAAEhD,OAAO,EAAEtD,GAAG,CAAC;AAC9D,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}