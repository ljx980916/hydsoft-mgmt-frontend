{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { CellView } from './CellView.mjs';\nimport { Link } from './Link.mjs';\nimport V from '../V/index.mjs';\nimport { addClassNamePrefix, removeClassNamePrefix, merge, template, assign, toArray, isObject, isFunction, clone, isPercentage, result, isEqual } from '../util/index.mjs';\nimport { Point, Line, Path, normalizeAngle, Rect, Polyline } from '../g/index.mjs';\nimport * as routers from '../routers/index.mjs';\nimport * as connectors from '../connectors/index.mjs';\nimport $ from 'jquery';\nconst Flags = {\n  TOOLS: CellView.Flags.TOOLS,\n  RENDER: 'RENDER',\n  UPDATE: 'UPDATE',\n  LEGACY_TOOLS: 'LEGACY_TOOLS',\n  LABELS: 'LABELS',\n  VERTICES: 'VERTICES',\n  SOURCE: 'SOURCE',\n  TARGET: 'TARGET',\n  CONNECTOR: 'CONNECTOR'\n};\n\n// Link base view and controller.\n// ----------------------------------------\n\nexport const LinkView = CellView.extend({\n  className: function () {\n    var classNames = CellView.prototype.className.apply(this).split(' ');\n    classNames.push('link');\n    return classNames.join(' ');\n  },\n  options: {\n    shortLinkLength: 105,\n    doubleLinkTools: false,\n    longLinkLength: 155,\n    linkToolsOffset: 40,\n    doubleLinkToolsOffset: 65,\n    sampleInterval: 50\n  },\n  _labelCache: null,\n  _labelSelectors: null,\n  _markerCache: null,\n  _V: null,\n  _dragData: null,\n  // deprecated\n\n  metrics: null,\n  decimalsRounding: 2,\n  initialize: function () {\n    CellView.prototype.initialize.apply(this, arguments);\n\n    // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n    // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n    // nodes in `updateLabelPosition()` in order to update the label positions.\n    this._labelCache = {};\n\n    // a cache of label selectors\n    this._labelSelectors = {};\n\n    // keeps markers bboxes and positions again for quicker access\n    this._markerCache = {};\n\n    // cache of default markup nodes\n    this._V = {};\n\n    // connection path metrics\n    this.cleanNodesCache();\n  },\n  presentationAttributes: {\n    markup: [Flags.RENDER],\n    attrs: [Flags.UPDATE],\n    router: [Flags.UPDATE],\n    connector: [Flags.CONNECTOR],\n    smooth: [Flags.UPDATE],\n    manhattan: [Flags.UPDATE],\n    toolMarkup: [Flags.LEGACY_TOOLS],\n    labels: [Flags.LABELS],\n    labelMarkup: [Flags.LABELS],\n    vertices: [Flags.VERTICES, Flags.UPDATE],\n    vertexMarkup: [Flags.VERTICES],\n    source: [Flags.SOURCE, Flags.UPDATE],\n    target: [Flags.TARGET, Flags.UPDATE]\n  },\n  initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n  UPDATE_PRIORITY: 1,\n  confirmUpdate: function (flags, opt) {\n    opt || (opt = {});\n    if (this.hasFlag(flags, Flags.SOURCE)) {\n      if (!this.updateEndProperties('source')) return flags;\n      flags = this.removeFlag(flags, Flags.SOURCE);\n    }\n    if (this.hasFlag(flags, Flags.TARGET)) {\n      if (!this.updateEndProperties('target')) return flags;\n      flags = this.removeFlag(flags, Flags.TARGET);\n    }\n    const {\n      paper,\n      sourceView,\n      targetView\n    } = this;\n    if (paper && (sourceView && !paper.isViewMounted(sourceView) || targetView && !paper.isViewMounted(targetView))) {\n      // Wait for the sourceView and targetView to be rendered\n      return flags;\n    }\n    if (this.hasFlag(flags, Flags.RENDER)) {\n      this.render();\n      this.updateHighlighters(true);\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.VERTICES, Flags.LABELS, Flags.TOOLS, Flags.LEGACY_TOOLS, Flags.CONNECTOR]);\n      return flags;\n    }\n    let updateHighlighters = false;\n    if (this.hasFlag(flags, Flags.VERTICES)) {\n      this.renderVertexMarkers();\n      flags = this.removeFlag(flags, Flags.VERTICES);\n    }\n    const {\n      model\n    } = this;\n    const {\n      attributes\n    } = model;\n    let updateLabels = this.hasFlag(flags, Flags.LABELS);\n    let updateLegacyTools = this.hasFlag(flags, Flags.LEGACY_TOOLS);\n    if (updateLabels) {\n      this.onLabelsChange(model, attributes.labels, opt);\n      flags = this.removeFlag(flags, Flags.LABELS);\n      updateHighlighters = true;\n    }\n    if (updateLegacyTools) {\n      this.renderTools();\n      flags = this.removeFlag(flags, Flags.LEGACY_TOOLS);\n    }\n    const updateAll = this.hasFlag(flags, Flags.UPDATE);\n    const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n    if (updateAll || updateConnector) {\n      if (!updateAll) {\n        // Keep the current route and update the geometry\n        this.updatePath();\n        this.updateDOM();\n      } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n        // The link is being translated by an ancestor that will\n        // shift source point, target point and all vertices\n        // by an equal distance.\n        this.translate(opt.tx, opt.ty);\n      } else {\n        this.update();\n      }\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n      updateLabels = false;\n      updateLegacyTools = false;\n      updateHighlighters = true;\n    }\n    if (updateLabels) {\n      this.updateLabelPositions();\n    }\n    if (updateLegacyTools) {\n      this.updateToolsPosition();\n    }\n    if (updateHighlighters) {\n      this.updateHighlighters();\n    }\n    if (this.hasFlag(flags, Flags.TOOLS)) {\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, Flags.TOOLS);\n    }\n    return flags;\n  },\n  requestConnectionUpdate: function (opt) {\n    this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n  },\n  isLabelsRenderRequired: function (opt = {}) {\n    const previousLabels = this.model.previous('labels');\n    if (!previousLabels) return true;\n\n    // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n    if ('propertyPathArray' in opt && 'propertyValue' in opt) {\n      // The label is setting by `prop()` method\n      var pathArray = opt.propertyPathArray || [];\n      var pathLength = pathArray.length;\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        var labelExists = !!previousLabels[pathArray[1]];\n        if (labelExists) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return 'markup' in Object(opt.propertyValue);\n          } else if (pathArray[2] !== 'markup') {\n            // We are changing a label property but not the markup\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  },\n  onLabelsChange: function (_link, _labels, opt) {\n    // Note: this optimization works in async=false mode only\n    if (this.isLabelsRenderRequired(opt)) {\n      this.renderLabels();\n    } else {\n      this.updateLabels();\n    }\n  },\n  // Rendering.\n  // ----------\n\n  render: function () {\n    this.vel.empty();\n    this.unmountLabels();\n    this._V = {};\n    this.renderMarkup();\n    // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n    // returns zero values)\n    this.renderLabels();\n    this.update();\n    return this;\n  },\n  renderMarkup: function () {\n    var link = this.model;\n    var markup = link.get('markup') || link.markup;\n    if (!markup) throw new Error('dia.LinkView: markup required');\n    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n    throw new Error('dia.LinkView: invalid markup');\n  },\n  renderJSONMarkup: function (markup) {\n    var doc = this.parseDOMJSON(markup, this.el);\n    // Selectors\n    this.selectors = doc.selectors;\n    // Fragment\n    this.vel.append(doc.fragment);\n  },\n  renderStringMarkup: function (markup) {\n    // A special markup can be given in the `properties.markup` property. This might be handy\n    // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n    // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n    // of elements with special meaning though. Therefore, those classes should be preserved in any\n    // special markup passed in `properties.markup`.\n    var children = V(markup);\n    // custom markup may contain only one children\n    if (!Array.isArray(children)) children = [children];\n    // Cache all children elements for quicker access.\n    var cache = this._V; // vectorized markup;\n    for (var i = 0, n = children.length; i < n; i++) {\n      var child = children[i];\n      var className = child.attr('class');\n      if (className) {\n        // Strip the joint class name prefix, if there is one.\n        className = removeClassNamePrefix(className);\n        cache[$.camelCase(className)] = child;\n      }\n    }\n    // partial rendering\n    this.renderTools();\n    this.renderVertexMarkers();\n    this.renderArrowheadMarkers();\n    this.vel.append(children);\n  },\n  _getLabelMarkup: function (labelMarkup) {\n    if (!labelMarkup) return undefined;\n    if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n    if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n    throw new Error('dia.linkView: invalid label markup');\n  },\n  _getLabelStringMarkup: function (labelMarkup) {\n    var children = V(labelMarkup);\n    var fragment = document.createDocumentFragment();\n    if (!Array.isArray(children)) {\n      fragment.appendChild(children.node);\n    } else {\n      for (var i = 0, n = children.length; i < n; i++) {\n        var currentChild = children[i].node;\n        fragment.appendChild(currentChild);\n      }\n    }\n    return {\n      fragment: fragment,\n      selectors: {}\n    }; // no selectors\n  },\n  // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n  // If it doesn't, add the <g /> container here.\n  _normalizeLabelMarkup: function (markup) {\n    if (!markup) return undefined;\n    var fragment = markup.fragment;\n    if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n    var vNode;\n    var childNodes = fragment.childNodes;\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      // default markup fragment is not wrapped in <g />\n      // add a <g /> container\n      vNode = V('g').append(fragment);\n    } else {\n      vNode = V(childNodes[0]);\n    }\n    vNode.addClass('label');\n    return {\n      node: vNode.node,\n      selectors: markup.selectors\n    };\n  },\n  renderLabels: function () {\n    var cache = this._V;\n    var vLabels = cache.labels;\n    var labelCache = this._labelCache = {};\n    var labelSelectors = this._labelSelectors = {};\n    var model = this.model;\n    var labels = model.attributes.labels || [];\n    var labelsCount = labels.length;\n    if (labelsCount === 0) {\n      if (vLabels) vLabels.remove();\n      return this;\n    }\n    if (vLabels) {\n      vLabels.empty();\n    } else {\n      // there is no label container in the markup but some labels are defined\n      // add a <g class=\"labels\" /> container\n      vLabels = cache.labels = V('g').addClass('labels');\n      if (this.options.labelsLayer) {\n        vLabels.addClass(addClassNamePrefix(result(this, 'className')));\n        vLabels.attr('model-id', model.id);\n      }\n    }\n    for (var i = 0; i < labelsCount; i++) {\n      var label = labels[i];\n      var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n      var labelNode;\n      var selectors;\n      if (labelMarkup) {\n        labelNode = labelMarkup.node;\n        selectors = labelMarkup.selectors;\n      } else {\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n        var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n        labelNode = defaultMarkup.node;\n        selectors = defaultMarkup.selectors;\n      }\n      labelNode.setAttribute('label-idx', i); // assign label-idx\n      vLabels.append(labelNode);\n      labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n      var rootSelector = this.selector;\n      if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n      selectors[rootSelector] = labelNode;\n      labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n    }\n    if (!vLabels.parent()) {\n      this.mountLabels();\n    }\n    this.updateLabels();\n    return this;\n  },\n  mountLabels: function () {\n    const {\n      el,\n      paper,\n      model,\n      _V,\n      options\n    } = this;\n    const {\n      labels: vLabels\n    } = _V;\n    if (!vLabels || !model.hasLabels()) return;\n    const {\n      node\n    } = vLabels;\n    if (options.labelsLayer) {\n      paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n    } else {\n      if (node.parentNode !== el) {\n        el.appendChild(node);\n      }\n    }\n  },\n  unmountLabels: function () {\n    const {\n      options,\n      _V\n    } = this;\n    if (!_V) return;\n    const {\n      labels: vLabels\n    } = _V;\n    if (vLabels && options.labelsLayer) {\n      vLabels.remove();\n    }\n  },\n  findLabelNode: function (labelIndex, selector) {\n    const labelRoot = this._labelCache[labelIndex];\n    if (!labelRoot) return null;\n    const labelSelectors = this._labelSelectors[labelIndex];\n    const [node = null] = this.findBySelector(selector, labelRoot, labelSelectors);\n    return node;\n  },\n  // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n  // keep `undefined` or `null` because `{}` means something else\n  _mergeLabelAttrs: function (hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n    if (labelAttrs === null) return null;\n    if (labelAttrs === undefined) {\n      if (defaultLabelAttrs === null) return null;\n      if (defaultLabelAttrs === undefined) {\n        if (hasCustomMarkup) return undefined;\n        return builtinDefaultLabelAttrs;\n      }\n      if (hasCustomMarkup) return defaultLabelAttrs;\n      return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n    }\n    if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n    return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n  },\n  // merge default label size into label size (no built-in default)\n  // keep `undefined` or `null` because `{}` means something else\n  _mergeLabelSize: function (labelSize, defaultLabelSize) {\n    if (labelSize === null) return null;\n    if (labelSize === undefined) {\n      if (defaultLabelSize === null) return null;\n      if (defaultLabelSize === undefined) return undefined;\n      return defaultLabelSize;\n    }\n    return merge({}, defaultLabelSize, labelSize);\n  },\n  updateLabels: function () {\n    if (!this._V.labels) return this;\n    var model = this.model;\n    var labels = model.get('labels') || [];\n    var canLabelMove = this.can('labelMove');\n    var builtinDefaultLabel = model._builtins.defaultLabel;\n    var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n    var defaultLabel = model._getDefaultLabel();\n    var defaultLabelMarkup = defaultLabel.markup;\n    var defaultLabelAttrs = defaultLabel.attrs;\n    var defaultLabelSize = defaultLabel.size;\n    for (var i = 0, n = labels.length; i < n; i++) {\n      var labelNode = this._labelCache[i];\n      labelNode.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n      var selectors = this._labelSelectors[i];\n      var label = labels[i];\n      var labelMarkup = label.markup;\n      var labelAttrs = label.attrs;\n      var labelSize = label.size;\n      var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);\n      var size = this._mergeLabelSize(labelSize, defaultLabelSize);\n      this.updateDOMSubtreeAttributes(labelNode, attrs, {\n        rootBBox: new Rect(size),\n        selectors: selectors\n      });\n    }\n    return this;\n  },\n  renderTools: function () {\n    if (!this._V.linkTools) return this;\n\n    // Tools are a group of clickable elements that manipulate the whole link.\n    // A good example of this is the remove tool that removes the whole link.\n    // Tools appear after hovering the link close to the `source` element/point of the link\n    // but are offset a bit so that they don't cover the `marker-arrowhead`.\n\n    var $tools = $(this._V.linkTools.node).empty();\n    var toolTemplate = template(this.model.get('toolMarkup') || this.model.toolMarkup);\n    var tool = V(toolTemplate());\n    $tools.append(tool.node);\n\n    // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\n    this._toolCache = tool;\n\n    // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\n    // link as well but only if the link is longer than `longLinkLength`.\n    if (this.options.doubleLinkTools) {\n      var tool2;\n      if (this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup) {\n        toolTemplate = template(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup);\n        tool2 = V(toolTemplate());\n      } else {\n        tool2 = tool.clone();\n      }\n      $tools.append(tool2.node);\n      this._tool2Cache = tool2;\n    }\n    return this;\n  },\n  renderVertexMarkers: function () {\n    if (!this._V.markerVertices) return this;\n    var $markerVertices = $(this._V.markerVertices.node).empty();\n\n    // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n    // if default styling (elements) are not desired. This makes it possible to use any\n    // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n    var markupTemplate = template(this.model.get('vertexMarkup') || this.model.vertexMarkup);\n    this.model.vertices().forEach(function (vertex, idx) {\n      $markerVertices.append(V(markupTemplate(assign({\n        idx: idx\n      }, vertex))).node);\n    });\n    return this;\n  },\n  renderArrowheadMarkers: function () {\n    // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\n    if (!this._V.markerArrowheads) return this;\n    var $markerArrowheads = $(this._V.markerArrowheads.node);\n    $markerArrowheads.empty();\n\n    // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n    // if default styling (elements) are not desired. This makes it possible to use any\n    // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n    var markupTemplate = template(this.model.get('arrowheadMarkup') || this.model.arrowheadMarkup);\n    this._V.sourceArrowhead = V(markupTemplate({\n      end: 'source'\n    }));\n    this._V.targetArrowhead = V(markupTemplate({\n      end: 'target'\n    }));\n    $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\n    return this;\n  },\n  // remove vertices that lie on (or nearly on) straight lines within the link\n  // return the number of removed points\n  removeRedundantLinearVertices: function (opt) {\n    const SIMPLIFY_THRESHOLD = 0.001;\n    const link = this.model;\n    const vertices = link.vertices();\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n    const numRoutePoints = routePoints.length;\n\n    // put routePoints into a polyline and try to simplify\n    const polyline = new Polyline(routePoints);\n    polyline.simplify({\n      threshold: SIMPLIFY_THRESHOLD\n    });\n    const polylinePoints = polyline.points.map(point => point.toJSON()); // JSON of points after simplification\n    const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n    // shortcut if simplification did not remove any redundant vertices:\n    if (numRoutePoints === numPolylinePoints) return 0;\n\n    // else: set simplified polyline points as link vertices\n    // remove first and last polyline points again (= source/target anchors)\n    link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n    return numRoutePoints - numPolylinePoints;\n  },\n  updateDefaultConnectionPath: function () {\n    var cache = this._V;\n    if (cache.connection) {\n      cache.connection.attr('d', this.getSerializedConnection());\n    }\n    if (cache.connectionWrap) {\n      cache.connectionWrap.attr('d', this.getSerializedConnection());\n    }\n    if (cache.markerSource && cache.markerTarget) {\n      this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);\n    }\n  },\n  getEndView: function (type) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null;\n      case 'target':\n        return this.targetView || null;\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndAnchor: function (type) {\n    switch (type) {\n      case 'source':\n        return new Point(this.sourceAnchor);\n      case 'target':\n        return new Point(this.targetAnchor);\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndConnectionPoint: function (type) {\n    switch (type) {\n      case 'source':\n        return new Point(this.sourcePoint);\n      case 'target':\n        return new Point(this.targetPoint);\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndMagnet: function (type) {\n    switch (type) {\n      case 'source':\n        var sourceView = this.sourceView;\n        if (!sourceView) break;\n        return this.sourceMagnet || sourceView.el;\n      case 'target':\n        var targetView = this.targetView;\n        if (!targetView) break;\n        return this.targetMagnet || targetView.el;\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n    return null;\n  },\n  // Updating.\n  // ---------\n\n  update: function () {\n    this.updateRoute();\n    this.updatePath();\n    this.updateDOM();\n    return this;\n  },\n  translate: function (tx = 0, ty = 0) {\n    const {\n      route,\n      path\n    } = this;\n    if (!route || !path) return;\n    // translate the route\n    const polyline = new Polyline(route);\n    polyline.translate(tx, ty);\n    this.route = polyline.points;\n    // translate source and target connection and marker points.\n    this._translateConnectionPoints(tx, ty);\n    // translate the geometry path\n    path.translate(tx, ty);\n    this.updateDOM();\n  },\n  updateDOM() {\n    const {\n      el,\n      model,\n      selectors\n    } = this;\n    this.cleanNodesCache();\n    // update SVG attributes defined by 'attrs/'.\n    this.updateDOMSubtreeAttributes(el, model.attr(), {\n      selectors\n    });\n    // legacy link path update\n    this.updateDefaultConnectionPath();\n    // update the label position etc.\n    this.updateLabelPositions();\n    this.updateToolsPosition();\n    this.updateArrowheadMarkers();\n    // *Deprecated*\n    // Local perpendicular flag (as opposed to one defined on paper).\n    // Could be enabled inside a connector/router. It's valid only\n    // during the update execution.\n    this.options.perpendicular = null;\n  },\n  updateRoute: function () {\n    const {\n      model\n    } = this;\n    const vertices = model.vertices();\n    // 1. Find Anchors\n    const anchors = this.findAnchors(vertices);\n    const sourceAnchor = this.sourceAnchor = anchors.source;\n    const targetAnchor = this.targetAnchor = anchors.target;\n    // 2. Find Route\n    const route = this.findRoute(vertices);\n    this.route = route;\n    // 3. Find Connection Points\n    var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n    this.sourcePoint = connectionPoints.source;\n    this.targetPoint = connectionPoints.target;\n  },\n  updatePath: function () {\n    const {\n      route,\n      sourcePoint,\n      targetPoint\n    } = this;\n    // 3b. Find Marker Connection Point - Backwards Compatibility\n    const markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint);\n    // 4. Find Connection\n    const path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);\n    this.path = path;\n  },\n  findMarkerPoints: function (route, sourcePoint, targetPoint) {\n    var firstWaypoint = route[0];\n    var lastWaypoint = route[route.length - 1];\n\n    // Move the source point by the width of the marker taking into account\n    // its scale around x-axis. Note that scale is the only transform that\n    // makes sense to be set in `.marker-source` attributes object\n    // as all other transforms (translate/rotate) will be replaced\n    // by the `translateAndAutoOrient()` function.\n    var cache = this._markerCache;\n    // cache source and target points\n    var sourceMarkerPoint, targetMarkerPoint;\n    if (this._V.markerSource) {\n      cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();\n      sourceMarkerPoint = Point(sourcePoint).move(firstWaypoint || targetPoint, cache.sourceBBox.width * this._V.markerSource.scale().sx * -1).round();\n    }\n    if (this._V.markerTarget) {\n      cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();\n      targetMarkerPoint = Point(targetPoint).move(lastWaypoint || sourcePoint, cache.targetBBox.width * this._V.markerTarget.scale().sx * -1).round();\n    }\n\n    // if there was no markup for the marker, use the connection point.\n    cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n    cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n    return {\n      source: sourceMarkerPoint,\n      target: targetMarkerPoint\n    };\n  },\n  findAnchorsOrdered: function (firstEndType, firstRef, secondEndType, secondRef) {\n    var firstAnchor, secondAnchor;\n    var firstAnchorRef, secondAnchorRef;\n    var model = this.model;\n    var firstDef = model.get(firstEndType);\n    var secondDef = model.get(secondEndType);\n    var firstView = this.getEndView(firstEndType);\n    var secondView = this.getEndView(secondEndType);\n    var firstMagnet = this.getEndMagnet(firstEndType);\n    var secondMagnet = this.getEndMagnet(secondEndType);\n\n    // Anchor first\n    if (firstView) {\n      if (firstRef) {\n        firstAnchorRef = new Point(firstRef);\n      } else if (secondView) {\n        firstAnchorRef = secondMagnet;\n      } else {\n        firstAnchorRef = new Point(secondDef);\n      }\n      firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n    } else {\n      firstAnchor = new Point(firstDef);\n    }\n\n    // Anchor second\n    if (secondView) {\n      secondAnchorRef = new Point(secondRef || firstAnchor);\n      secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n    } else {\n      secondAnchor = new Point(secondDef);\n    }\n    var res = {};\n    res[firstEndType] = firstAnchor;\n    res[secondEndType] = secondAnchor;\n    return res;\n  },\n  findAnchors: function (vertices) {\n    var model = this.model;\n    var firstVertex = vertices[0];\n    var lastVertex = vertices[vertices.length - 1];\n    if (model.target().priority && !model.source().priority) {\n      // Reversed order\n      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n    }\n\n    // Usual order\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n  },\n  findConnectionPoints: function (route, sourceAnchor, targetAnchor) {\n    var firstWaypoint = route[0];\n    var lastWaypoint = route[route.length - 1];\n    var model = this.model;\n    var sourceDef = model.get('source');\n    var targetDef = model.get('target');\n    var sourceView = this.sourceView;\n    var targetView = this.targetView;\n    var paperOptions = this.paper.options;\n    var sourceMagnet, targetMagnet;\n\n    // Connection Point Source\n    var sourcePoint;\n    if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n      sourceMagnet = this.sourceMagnet || sourceView.el;\n      var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n      var sourcePointRef = firstWaypoint || targetAnchor;\n      var sourceLine = new Line(sourcePointRef, sourceAnchor);\n      sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n    } else {\n      sourcePoint = sourceAnchor;\n    }\n    // Connection Point Target\n    var targetPoint;\n    if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n      targetMagnet = this.targetMagnet || targetView.el;\n      var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n      var targetPointRef = lastWaypoint || sourceAnchor;\n      var targetLine = new Line(targetPointRef, targetAnchor);\n      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n    } else {\n      targetPoint = targetAnchor;\n    }\n    return {\n      source: sourcePoint,\n      target: targetPoint\n    };\n  },\n  getAnchor: function (anchorDef, cellView, magnet, ref, endType) {\n    var isConnection = cellView.isNodeConnection(magnet);\n    var paperOptions = this.paper.options;\n    if (!anchorDef) {\n      if (isConnection) {\n        anchorDef = paperOptions.defaultLinkAnchor;\n      } else {\n        if (paperOptions.perpendicularLinks || this.options.perpendicular) {\n          // Backwards compatibility\n          // If `perpendicularLinks` flag is set on the paper and there are vertices\n          // on the link, then try to find a connection point that makes the link perpendicular\n          // even though the link won't point to the center of the targeted object.\n          anchorDef = {\n            name: 'perpendicular'\n          };\n        } else {\n          anchorDef = paperOptions.defaultAnchor;\n        }\n      }\n    }\n    if (!anchorDef) throw new Error('Anchor required.');\n    var anchorFn;\n    if (typeof anchorDef === 'function') {\n      anchorFn = anchorDef;\n    } else {\n      var anchorName = anchorDef.name;\n      var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n      anchorFn = paperOptions[anchorNamespace][anchorName];\n      if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n    }\n    var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);\n    if (!anchor) return new Point();\n    return anchor.round(this.decimalsRounding);\n  },\n  getConnectionPoint: function (connectionPointDef, view, magnet, line, endType) {\n    var connectionPoint;\n    var anchor = line.end;\n    var paperOptions = this.paper.options;\n\n    // Backwards compatibility\n    if (typeof paperOptions.linkConnectionPoint === 'function') {\n      var linkConnectionMagnet = magnet === view.el ? undefined : magnet;\n      connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);\n      if (connectionPoint) return connectionPoint;\n    }\n    if (!connectionPointDef) return anchor;\n    var connectionPointFn;\n    if (typeof connectionPointDef === 'function') {\n      connectionPointFn = connectionPointDef;\n    } else {\n      var connectionPointName = connectionPointDef.name;\n      connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n      if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n    }\n    connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n    if (!connectionPoint) return anchor;\n    return connectionPoint.round(this.decimalsRounding);\n  },\n  _translateConnectionPoints: function (tx, ty) {\n    var cache = this._markerCache;\n    cache.sourcePoint.offset(tx, ty);\n    cache.targetPoint.offset(tx, ty);\n    this.sourcePoint.offset(tx, ty);\n    this.targetPoint.offset(tx, ty);\n    this.sourceAnchor.offset(tx, ty);\n    this.targetAnchor.offset(tx, ty);\n  },\n  // combine default label position with built-in default label position\n  _getDefaultLabelPositionProperty: function () {\n    var model = this.model;\n    var builtinDefaultLabel = model._builtins.defaultLabel;\n    var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n    var defaultLabel = model._getDefaultLabel();\n    var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n    return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n  },\n  // if label position is a number, normalize it to a position object\n  // this makes sure that label positions can be merged properly\n  _normalizeLabelPosition: function (labelPosition) {\n    if (typeof labelPosition === 'number') return {\n      distance: labelPosition,\n      offset: null,\n      angle: 0,\n      args: null\n    };\n    return labelPosition;\n  },\n  // expects normalized position properties\n  // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n  _mergeLabelPositionProperty: function (normalizedLabelPosition, normalizedDefaultLabelPosition) {\n    if (normalizedLabelPosition === null) return null;\n    if (normalizedLabelPosition === undefined) {\n      if (normalizedDefaultLabelPosition === null) return null;\n      return normalizedDefaultLabelPosition;\n    }\n    return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n  },\n  updateLabelPositions: function () {\n    if (!this._V.labels) return this;\n    var path = this.path;\n    if (!path) return this;\n\n    // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n    // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n    var model = this.model;\n    var labels = model.get('labels') || [];\n    if (!labels.length) return this;\n    var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n    for (var idx = 0, n = labels.length; idx < n; idx++) {\n      var labelNode = this._labelCache[idx];\n      if (!labelNode) continue;\n      var label = labels[idx];\n      var labelPosition = this._normalizeLabelPosition(label.position);\n      var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n      var transformationMatrix = this._getLabelTransformationMatrix(position);\n      labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n      this._cleanLabelMatrices(idx);\n    }\n    return this;\n  },\n  _cleanLabelMatrices: function (index) {\n    // Clean magnetMatrix for all nodes of the label.\n    // Cached BoundingRect does not need to updated when the position changes\n    // TODO: this doesn't work for labels with XML String markups.\n    const {\n      metrics,\n      _labelSelectors\n    } = this;\n    const selectors = _labelSelectors[index];\n    if (!selectors) return;\n    for (let selector in selectors) {\n      const {\n        id\n      } = selectors[selector];\n      if (id && id in metrics) delete metrics[id].magnetMatrix;\n    }\n  },\n  updateToolsPosition: function () {\n    if (!this._V.linkTools) return this;\n\n    // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\n    // Note that the offset is hardcoded here. The offset should be always\n    // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n    // this up all the time would be slow.\n\n    var scale = '';\n    var offset = this.options.linkToolsOffset;\n    var connectionLength = this.getConnectionLength();\n\n    // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\n    // In that case we won't update tools position at all.\n    if (!Number.isNaN(connectionLength)) {\n      // If the link is too short, make the tools half the size and the offset twice as low.\n      if (connectionLength < this.options.shortLinkLength) {\n        scale = 'scale(.5)';\n        offset /= 2;\n      }\n      var toolPosition = this.getPointAtLength(offset);\n      this._toolCache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n      if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\n        var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\n        toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\n        this._tool2Cache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n        this._tool2Cache.attr('display', 'inline');\n      } else if (this.options.doubleLinkTools) {\n        this._tool2Cache.attr('display', 'none');\n      }\n    }\n    return this;\n  },\n  updateArrowheadMarkers: function () {\n    if (!this._V.markerArrowheads) return this;\n\n    // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\n    if ($.css(this._V.markerArrowheads.node, 'display') === 'none') return this;\n    var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n    this._V.sourceArrowhead.scale(sx);\n    this._V.targetArrowhead.scale(sx);\n    this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\n    return this;\n  },\n  updateEndProperties: function (endType) {\n    const {\n      model,\n      paper\n    } = this;\n    const endViewProperty = `${endType}View`;\n    const endDef = model.get(endType);\n    const endId = endDef && endDef.id;\n    if (!endId) {\n      // the link end is a point ~ rect 0x0\n      this[endViewProperty] = null;\n      this.updateEndMagnet(endType);\n      return true;\n    }\n    const endModel = paper.getModelById(endId);\n    if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n    const endView = endModel.findView(paper);\n    if (!endView) {\n      // A view for a model should always exist\n      return false;\n    }\n    this[endViewProperty] = endView;\n    this.updateEndMagnet(endType);\n    return true;\n  },\n  updateEndMagnet: function (endType) {\n    const endMagnetProperty = `${endType}Magnet`;\n    const endView = this.getEndView(endType);\n    if (endView) {\n      let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n      if (connectedMagnet === endView.el) connectedMagnet = null;\n      this[endMagnetProperty] = connectedMagnet;\n    } else {\n      this[endMagnetProperty] = null;\n    }\n  },\n  _translateAndAutoOrientArrows: function (sourceArrow, targetArrow) {\n    // Make the markers \"point\" to their sticky points being auto-oriented towards\n    // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\n    var route = toArray(this.route);\n    if (sourceArrow) {\n      sourceArrow.translateAndAutoOrient(this.sourcePoint, route[0] || this.targetPoint, this.paper.cells);\n    }\n    if (targetArrow) {\n      targetArrow.translateAndAutoOrient(this.targetPoint, route[route.length - 1] || this.sourcePoint, this.paper.cells);\n    }\n  },\n  _getLabelPositionProperty: function (idx) {\n    return this.model.label(idx).position || {};\n  },\n  _getLabelPositionAngle: function (idx) {\n    var labelPosition = this._getLabelPositionProperty(idx);\n    return labelPosition.angle || 0;\n  },\n  _getLabelPositionArgs: function (idx) {\n    var labelPosition = this._getLabelPositionProperty(idx);\n    return labelPosition.args;\n  },\n  _getDefaultLabelPositionArgs: function () {\n    var defaultLabel = this.model._getDefaultLabel();\n    var defaultLabelPosition = defaultLabel.position || {};\n    return defaultLabelPosition.args;\n  },\n  // merge default label position args into label position args\n  // keep `undefined` or `null` because `{}` means something else\n  _mergeLabelPositionArgs: function (labelPositionArgs, defaultLabelPositionArgs) {\n    if (labelPositionArgs === null) return null;\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) return null;\n      return defaultLabelPositionArgs;\n    }\n    return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n  },\n  // Add default label at given position at end of `labels` array.\n  // Four signatures:\n  // - obj, obj = point, opt\n  // - obj, num, obj = point, angle, opt\n  // - num, num, obj = x, y, opt\n  // - num, num, num, obj = x, y, angle, opt\n  // Assigns relative coordinates by default:\n  // `opt.absoluteDistance` forces absolute coordinates.\n  // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n  // `opt.absoluteOffset` forces absolute coordinates for offset.\n  // Additional args:\n  // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n  // `opt.ensureLegibility` rotates labels so they are never upside-down.\n  addLabel: function (p1, p2, p3, p4) {\n    // normalize data from the four possible signatures\n    var localX;\n    var localY;\n    var localAngle = 0;\n    var localOpt;\n    if (typeof p1 !== 'number') {\n      // {x, y} object provided as first parameter\n      localX = p1.x;\n      localY = p1.y;\n      if (typeof p2 === 'number') {\n        // angle and opt provided as second and third parameters\n        localAngle = p2;\n        localOpt = p3;\n      } else {\n        // opt provided as second parameter\n        localOpt = p2;\n      }\n    } else {\n      // x and y provided as first and second parameters\n      localX = p1;\n      localY = p2;\n      if (typeof p3 === 'number') {\n        // angle and opt provided as third and fourth parameters\n        localAngle = p3;\n        localOpt = p4;\n      } else {\n        // opt provided as third parameter\n        localOpt = p3;\n      }\n    }\n\n    // merge label position arguments\n    var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n    var labelPositionArgs = localOpt;\n    var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n    // append label to labels array\n    var label = {\n      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n    };\n    var idx = -1;\n    this.model.insertLabel(idx, label, localOpt);\n    return idx;\n  },\n  // Add a new vertex at calculated index to the `vertices` array.\n  addVertex: function (x, y, opt) {\n    // accept input in form `{ x, y }, opt` or `x, y, opt`\n    var isPointProvided = typeof x !== 'number';\n    var localX = isPointProvided ? x.x : x;\n    var localY = isPointProvided ? x.y : y;\n    var localOpt = isPointProvided ? y : opt;\n    var vertex = {\n      x: localX,\n      y: localY\n    };\n    var idx = this.getVertexIndex(localX, localY);\n    this.model.insertVertex(idx, vertex, localOpt);\n    return idx;\n  },\n  // Send a token (an SVG element, usually a circle) along the connection path.\n  // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n  // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n  // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n  // `opt.connection` is an optional selector to the connection path.\n  // `callback` is optional and is a function to be called once the token reaches the target.\n  sendToken: function (token, opt, callback) {\n    function onAnimationEnd(vToken, callback) {\n      return function () {\n        vToken.remove();\n        if (typeof callback === 'function') {\n          callback();\n        }\n      };\n    }\n    var duration, isReversed, selector;\n    if (isObject(opt)) {\n      duration = opt.duration;\n      isReversed = opt.direction === 'reverse';\n      selector = opt.connection;\n    } else {\n      // Backwards compatibility\n      duration = opt;\n      isReversed = false;\n      selector = null;\n    }\n    duration = duration || 1000;\n    var animationAttributes = {\n      dur: duration + 'ms',\n      repeatCount: 1,\n      calcMode: 'linear',\n      fill: 'freeze'\n    };\n    if (isReversed) {\n      animationAttributes.keyPoints = '1;0';\n      animationAttributes.keyTimes = '0;1';\n    }\n    var vToken = V(token);\n    var connection;\n    if (typeof selector === 'string') {\n      // Use custom connection path.\n      connection = this.findBySelector(selector, this.el, this.selectors)[0];\n    } else {\n      // Select connection path automatically.\n      var cache = this._V;\n      connection = cache.connection ? cache.connection.node : this.el.querySelector('path');\n    }\n    if (!(connection instanceof SVGPathElement)) {\n      throw new Error('dia.LinkView: token animation requires a valid connection path.');\n    }\n    vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);\n    setTimeout(onAnimationEnd(vToken, callback), duration);\n  },\n  findRoute: function (vertices) {\n    vertices || (vertices = []);\n    var namespace = this.paper.options.routerNamespace || routers;\n    var router = this.model.router();\n    var defaultRouter = this.paper.options.defaultRouter;\n    if (!router) {\n      if (defaultRouter) router = defaultRouter;else return vertices.map(Point); // no router specified\n    }\n    var routerFn = isFunction(router) ? router : namespace[router.name];\n    if (!isFunction(routerFn)) {\n      throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n    }\n    var args = router.args || {};\n    var route = routerFn.call(this,\n    // context\n    vertices,\n    // vertices\n    args,\n    // options\n    this // linkView\n    );\n    if (!route) return vertices.map(Point);\n    return route;\n  },\n  // Return the `d` attribute value of the `<path>` element representing the link\n  // between `source` and `target`.\n  findPath: function (route, sourcePoint, targetPoint) {\n    var namespace = this.paper.options.connectorNamespace || connectors;\n    var connector = this.model.connector();\n    var defaultConnector = this.paper.options.defaultConnector;\n    if (!connector) {\n      connector = defaultConnector || {};\n    }\n    var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n    if (!isFunction(connectorFn)) {\n      throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n    }\n    var args = clone(connector.args || {});\n    args.raw = true; // Request raw g.Path as the result.\n\n    var path = connectorFn.call(this,\n    // context\n    sourcePoint,\n    // start point\n    targetPoint,\n    // end point\n    route,\n    // vertices\n    args,\n    // options\n    this // linkView\n    );\n    if (typeof path === 'string') {\n      // Backwards compatibility for connectors not supporting `raw` option.\n      path = new Path(V.normalizePathData(path));\n    }\n    return path;\n  },\n  // Public API.\n  // -----------\n\n  getConnection: function () {\n    var path = this.path;\n    if (!path) return null;\n    return path.clone();\n  },\n  getSerializedConnection: function () {\n    var path = this.path;\n    if (!path) return null;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('data')) return metrics.data;\n    var data = path.serialize();\n    metrics.data = data;\n    return data;\n  },\n  getConnectionSubdivisions: function () {\n    var path = this.path;\n    if (!path) return null;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n    var subdivisions = path.getSegmentSubdivisions();\n    metrics.segmentSubdivisions = subdivisions;\n    return subdivisions;\n  },\n  getConnectionLength: function () {\n    var path = this.path;\n    if (!path) return 0;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('length')) return metrics.length;\n    var length = path.length({\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n    metrics.length = length;\n    return length;\n  },\n  getPointAtLength: function (length) {\n    var path = this.path;\n    if (!path) return null;\n    return path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getPointAtRatio: function (ratio) {\n    var path = this.path;\n    if (!path) return null;\n    if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n    return path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getTangentAtLength: function (length) {\n    var path = this.path;\n    if (!path) return null;\n    return path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getTangentAtRatio: function (ratio) {\n    var path = this.path;\n    if (!path) return null;\n    return path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPoint: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPointLength: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPointRatio: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  // Get label position object based on two provided coordinates, x and y.\n  // (Used behind the scenes when user moves labels around.)\n  // Two signatures:\n  // - num, num, obj = x, y, options\n  // - num, num, num, obj = x, y, angle, options\n  // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n  // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n  // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n  getLabelPosition: function (x, y, p3, p4) {\n    var position = {};\n\n    // normalize data from the two possible signatures\n    var localAngle = 0;\n    var localOpt;\n    if (typeof p3 === 'number') {\n      // angle and opt provided as third and fourth argument\n      localAngle = p3;\n      localOpt = p4;\n    } else {\n      // opt provided as third argument\n      localOpt = p3;\n    }\n\n    // save localOpt as `args` of the position object that is passed along\n    if (localOpt) position.args = localOpt;\n\n    // identify distance/offset settings\n    var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n    var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default\n    var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n    // find closest point t\n    var path = this.path;\n    var pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    var labelPoint = new Point(x, y);\n    var t = path.closestPointT(labelPoint, pathOpt);\n\n    // DISTANCE:\n    var labelDistance = path.lengthAtT(t, pathOpt);\n    if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0; // fix to prevent NaN for 0 length\n    if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1; // fix for end point (-0 => 1)\n    position.distance = labelDistance;\n\n    // OFFSET:\n    // use absolute offset if:\n    // - opt.absoluteOffset is true,\n    // - opt.absoluteOffset is not true but there is no tangent\n    var tangent;\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n    var labelOffset;\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint);\n    } else {\n      var closestPoint = path.pointAtT(t);\n      var labelOffsetDiff = labelPoint.difference(closestPoint);\n      labelOffset = {\n        x: labelOffsetDiff.x,\n        y: labelOffsetDiff.y\n      };\n    }\n    position.offset = labelOffset;\n\n    // ANGLE:\n    position.angle = localAngle;\n    return position;\n  },\n  _getLabelTransformationMatrix: function (labelPosition) {\n    var labelDistance;\n    var labelAngle = 0;\n    var args = {};\n    if (typeof labelPosition === 'number') {\n      labelDistance = labelPosition;\n    } else if (typeof labelPosition.distance === 'number') {\n      args = labelPosition.args || {};\n      labelDistance = labelPosition.distance;\n      labelAngle = labelPosition.angle || 0;\n    } else {\n      throw new Error('dia.LinkView: invalid label position distance.');\n    }\n    var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n    var labelOffset = 0;\n    var labelOffsetCoordinates = {\n      x: 0,\n      y: 0\n    };\n    if (labelPosition.offset) {\n      var positionOffset = labelPosition.offset;\n      if (typeof positionOffset === 'number') labelOffset = positionOffset;\n      if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n      if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n    }\n    var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;\n    var isKeepGradient = args.keepGradient;\n    var isEnsureLegibility = args.ensureLegibility;\n    var path = this.path;\n    var pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n    var tangent = path.tangentAtLength(distance, pathOpt);\n    var translation;\n    var angle = labelAngle;\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start.clone();\n        translation.offset(labelOffsetCoordinates);\n      } else {\n        var normal = tangent.clone();\n        normal.rotate(tangent.start, -90);\n        normal.setLength(labelOffset);\n        translation = normal.end;\n      }\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle;\n        if (isEnsureLegibility) {\n          angle = normalizeAngle((angle + 90) % 180 - 90);\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start.clone();\n      if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n    }\n    return V.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n  },\n  getLabelCoordinates: function (labelPosition) {\n    var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n    return new Point(transformationMatrix.e, transformationMatrix.f);\n  },\n  getVertexIndex: function (x, y) {\n    var model = this.model;\n    var vertices = model.vertices();\n    var vertexLength = this.getClosestPointLength(new Point(x, y));\n    var idx = 0;\n    for (var n = vertices.length; idx < n; idx++) {\n      var currentVertex = vertices[idx];\n      var currentVertexLength = this.getClosestPointLength(currentVertex);\n      if (vertexLength < currentVertexLength) break;\n    }\n    return idx;\n  },\n  // Interaction. The controller part.\n  // ---------------------------------\n\n  notifyPointerdown(evt, x, y) {\n    CellView.prototype.pointerdown.call(this, evt, x, y);\n    this.notify('link:pointerdown', evt, x, y);\n  },\n  notifyPointermove(evt, x, y) {\n    CellView.prototype.pointermove.call(this, evt, x, y);\n    this.notify('link:pointermove', evt, x, y);\n  },\n  notifyPointerup(evt, x, y) {\n    this.notify('link:pointerup', evt, x, y);\n    CellView.prototype.pointerup.call(this, evt, x, y);\n  },\n  pointerdblclick: function (evt, x, y) {\n    CellView.prototype.pointerdblclick.apply(this, arguments);\n    this.notify('link:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    CellView.prototype.pointerclick.apply(this, arguments);\n    this.notify('link:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    CellView.prototype.contextmenu.apply(this, arguments);\n    this.notify('link:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    this.notifyPointerdown(evt, x, y);\n\n    // Backwards compatibility for the default markup\n    var className = evt.target.getAttribute('class');\n    switch (className) {\n      case 'marker-vertex':\n        this.dragVertexStart(evt, x, y);\n        return;\n      case 'marker-vertex-remove':\n      case 'marker-vertex-remove-area':\n        this.dragVertexRemoveStart(evt, x, y);\n        return;\n      case 'marker-arrowhead':\n        this.dragArrowheadStart(evt, x, y);\n        return;\n      case 'connection':\n      case 'connection-wrap':\n        this.dragConnectionStart(evt, x, y);\n        return;\n      case 'marker-source':\n      case 'marker-target':\n        return;\n    }\n    this.dragStart(evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    // Backwards compatibility\n    var dragData = this._dragData;\n    if (dragData) this.eventData(evt, dragData);\n    var data = this.eventData(evt);\n    switch (data.action) {\n      case 'vertex-move':\n        this.dragVertex(evt, x, y);\n        break;\n      case 'label-move':\n        this.dragLabel(evt, x, y);\n        break;\n      case 'arrowhead-move':\n        this.dragArrowhead(evt, x, y);\n        break;\n      case 'move':\n        this.drag(evt, x, y);\n        break;\n    }\n\n    // Backwards compatibility\n    if (dragData) assign(dragData, this.eventData(evt));\n    this.notifyPointermove(evt, x, y);\n  },\n  pointerup: function (evt, x, y) {\n    // Backwards compatibility\n    var dragData = this._dragData;\n    if (dragData) {\n      this.eventData(evt, dragData);\n      this._dragData = null;\n    }\n    var data = this.eventData(evt);\n    switch (data.action) {\n      case 'vertex-move':\n        this.dragVertexEnd(evt, x, y);\n        break;\n      case 'label-move':\n        this.dragLabelEnd(evt, x, y);\n        break;\n      case 'arrowhead-move':\n        this.dragArrowheadEnd(evt, x, y);\n        break;\n      case 'move':\n        this.dragEnd(evt, x, y);\n    }\n    this.notifyPointerup(evt, x, y);\n    this.checkMouseleave(evt);\n  },\n  mouseover: function (evt) {\n    CellView.prototype.mouseover.apply(this, arguments);\n    this.notify('link:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    CellView.prototype.mouseout.apply(this, arguments);\n    this.notify('link:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    CellView.prototype.mouseenter.apply(this, arguments);\n    this.notify('link:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    CellView.prototype.mouseleave.apply(this, arguments);\n    this.notify('link:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    CellView.prototype.mousewheel.apply(this, arguments);\n    this.notify('link:mousewheel', evt, x, y, delta);\n  },\n  onevent: function (evt, eventName, x, y) {\n    // Backwards compatibility\n    var linkTool = V(evt.target).findParentByClass('link-tool', this.el);\n    if (linkTool) {\n      // No further action to be executed\n      evt.stopPropagation();\n\n      // Allow `interactive.useLinkTools=false`\n      if (this.can('useLinkTools')) {\n        if (eventName === 'remove') {\n          // Built-in remove event\n          this.model.remove({\n            ui: true\n          });\n          // Do not trigger link pointerdown\n          return;\n        } else {\n          // link:options and other custom events inside the link tools\n          this.notify(eventName, evt, x, y);\n        }\n      }\n      this.notifyPointerdown(evt, x, y);\n      this.paper.delegateDragEvents(this, evt.data);\n    } else {\n      CellView.prototype.onevent.apply(this, arguments);\n    }\n  },\n  onlabel: function (evt, x, y) {\n    this.notifyPointerdown(evt, x, y);\n    this.dragLabelStart(evt, x, y);\n    var stopPropagation = this.eventData(evt).stopPropagation;\n    if (stopPropagation) evt.stopPropagation();\n  },\n  // Drag Start Handlers\n\n  dragConnectionStart: function (evt, x, y) {\n    if (!this.can('vertexAdd')) return;\n\n    // Store the index at which the new vertex has just been placed.\n    // We'll be update the very same vertex position in `pointermove()`.\n    var vertexIdx = this.addVertex({\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n    this.eventData(evt, {\n      action: 'vertex-move',\n      vertexIdx: vertexIdx\n    });\n  },\n  dragLabelStart: function (evt, x, y) {\n    if (this.can('labelMove')) {\n      if (this.isDefaultInteractionPrevented(evt)) return;\n      var labelNode = evt.currentTarget;\n      var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n      var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n      var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n      var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n      var coords = this.getLabelCoordinates(position);\n      var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n      var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n\n      var positionAngle = this._getLabelPositionAngle(labelIdx);\n      var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n      var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n      var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n      this.eventData(evt, {\n        action: 'label-move',\n        labelIdx: labelIdx,\n        dx: dx,\n        dy: dy,\n        positionAngle: positionAngle,\n        positionArgs: positionArgs,\n        stopPropagation: true\n      });\n    } else {\n      // Backwards compatibility:\n      // If labels can't be dragged no default action is triggered.\n      this.eventData(evt, {\n        stopPropagation: true\n      });\n    }\n    this.paper.delegateDragEvents(this, evt.data);\n  },\n  dragVertexStart: function (evt, x, y) {\n    if (!this.can('vertexMove')) return;\n    var vertexNode = evt.target;\n    var vertexIdx = parseInt(vertexNode.getAttribute('idx'), 10);\n    this.eventData(evt, {\n      action: 'vertex-move',\n      vertexIdx: vertexIdx\n    });\n  },\n  dragVertexRemoveStart: function (evt, x, y) {\n    if (!this.can('vertexRemove')) return;\n    var removeNode = evt.target;\n    var vertexIdx = parseInt(removeNode.getAttribute('idx'), 10);\n    this.model.removeVertex(vertexIdx);\n  },\n  dragArrowheadStart: function (evt, x, y) {\n    if (!this.can('arrowheadMove')) return;\n    var arrowheadNode = evt.target;\n    var arrowheadType = arrowheadNode.getAttribute('end');\n    var data = this.startArrowheadMove(arrowheadType, {\n      ignoreBackwardsCompatibility: true\n    });\n    this.eventData(evt, data);\n  },\n  dragStart: function (evt, x, y) {\n    if (this.isDefaultInteractionPrevented(evt)) return;\n    if (!this.can('linkMove')) return;\n    this.eventData(evt, {\n      action: 'move',\n      dx: x,\n      dy: y\n    });\n  },\n  // Drag Handlers\n  dragLabel: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var label = {\n      position: this.getLabelPosition(x + data.dx, y + data.dy, data.positionAngle, data.positionArgs)\n    };\n    if (this.paper.options.snapLabels) delete label.position.offset;\n    // The `touchmove' events are not fired\n    // when the original event target is removed from the DOM.\n    // The labels are currently re-rendered completely when only\n    // the position changes. This is why we need to make sure that\n    // the label is updated synchronously.\n    // TODO: replace `touchmove` with `pointermove` (breaking change).\n    const setOptions = {\n      ui: true\n    };\n    if (this.paper.isAsync() && evt.type === 'touchmove') {\n      setOptions.async = false;\n    }\n    this.model.label(data.labelIdx, label, setOptions);\n  },\n  dragVertex: function (evt, x, y) {\n    var data = this.eventData(evt);\n    this.model.vertex(data.vertexIdx, {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n  },\n  dragArrowhead: function (evt, x, y) {\n    if (this.paper.options.snapLinks) {\n      const isSnapped = this._snapArrowhead(evt, x, y);\n      if (!isSnapped && this.paper.options.snapLinksSelf) {\n        this._snapArrowheadSelf(evt, x, y);\n      }\n    } else {\n      if (this.paper.options.snapLinksSelf) {\n        this._snapArrowheadSelf(evt, x, y);\n      } else {\n        this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n      }\n    }\n  },\n  drag: function (evt, x, y) {\n    var data = this.eventData(evt);\n    this.model.translate(x - data.dx, y - data.dy, {\n      ui: true\n    });\n    this.eventData(evt, {\n      dx: x,\n      dy: y\n    });\n  },\n  // Drag End Handlers\n\n  dragLabelEnd: function () {\n    // noop\n  },\n  dragVertexEnd: function () {\n    // noop\n  },\n  dragArrowheadEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var paper = this.paper;\n    if (paper.options.snapLinks) {\n      this._snapArrowheadEnd(data);\n    } else {\n      this._connectArrowheadEnd(data, x, y);\n    }\n    if (!paper.linkAllowed(this)) {\n      // If the changed link is not allowed, revert to its previous state.\n      this._disallow(data);\n    } else {\n      this._finishEmbedding(data);\n      this._notifyConnectEvent(data, evt);\n    }\n    this._afterArrowheadMove(data);\n  },\n  dragEnd: function () {\n    // noop\n  },\n  _disallow: function (data) {\n    switch (data.whenNotAllowed) {\n      case 'remove':\n        this.model.remove({\n          ui: true\n        });\n        break;\n      case 'revert':\n      default:\n        this.model.set(data.arrowhead, data.initialEnd, {\n          ui: true\n        });\n        break;\n    }\n  },\n  _finishEmbedding: function (data) {\n    // Reparent the link if embedding is enabled\n    if (this.paper.options.embeddingMode && this.model.reparent()) {\n      // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n      data.z = null;\n    }\n  },\n  _notifyConnectEvent: function (data, evt) {\n    var arrowhead = data.arrowhead;\n    var initialEnd = data.initialEnd;\n    var currentEnd = this.model.prop(arrowhead);\n    var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n    if (endChanged) {\n      var paper = this.paper;\n      if (initialEnd.id) {\n        this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n      }\n      if (currentEnd.id) {\n        this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n      }\n    }\n  },\n  _snapToPoints: function (snapPoint, points, radius) {\n    let closestPointX = null;\n    let closestDistanceX = Infinity;\n    let closestPointY = null;\n    let closestDistanceY = Infinity;\n    let x = snapPoint.x;\n    let y = snapPoint.y;\n    for (let i = 0; i < points.length; i++) {\n      const distX = Math.abs(points[i].x - snapPoint.x);\n      if (distX < closestDistanceX) {\n        closestDistanceX = distX;\n        closestPointX = points[i];\n      }\n      const distY = Math.abs(points[i].y - snapPoint.y);\n      if (distY < closestDistanceY) {\n        closestDistanceY = distY;\n        closestPointY = points[i];\n      }\n    }\n    if (closestDistanceX < radius) {\n      x = closestPointX.x;\n    }\n    if (closestDistanceY < radius) {\n      y = closestPointY.y;\n    }\n    return {\n      x,\n      y\n    };\n  },\n  _snapArrowheadSelf: function (evt, x, y) {\n    const {\n      paper,\n      model\n    } = this;\n    const {\n      snapLinksSelf\n    } = paper.options;\n    const data = this.eventData(evt);\n    const radius = snapLinksSelf.radius || 20;\n    const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');\n    const vertices = model.vertices();\n    const points = [anchor, ...vertices];\n    const snapPoint = this._snapToPoints({\n      x: x,\n      y: y\n    }, points, radius);\n    const point = paper.localToClientPoint(snapPoint);\n    this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n  },\n  _snapArrowhead: function (evt, x, y) {\n    const {\n      paper\n    } = this;\n    const {\n      snapLinks,\n      connectionStrategy\n    } = paper.options;\n    const data = this.eventData(evt);\n    let isSnapped = false;\n    // checking view in close area of the pointer\n\n    var r = snapLinks.radius || 50;\n    var viewsInArea = paper.findViewsInArea({\n      x: x - r,\n      y: y - r,\n      width: 2 * r,\n      height: 2 * r\n    });\n    var prevClosestView = data.closestView || null;\n    var prevClosestMagnet = data.closestMagnet || null;\n    var prevMagnetProxy = data.magnetProxy || null;\n    data.closestView = data.closestMagnet = data.magnetProxy = null;\n    var minDistance = Number.MAX_VALUE;\n    var pointer = new Point(x, y);\n    viewsInArea.forEach(function (view) {\n      const candidates = [];\n      // skip connecting to the element in case '.': { magnet: false } attribute present\n      if (view.el.getAttribute('magnet') !== 'false') {\n        candidates.push({\n          bbox: view.model.getBBox(),\n          magnet: view.el\n        });\n      }\n      view.$('[magnet]').toArray().forEach(magnet => {\n        candidates.push({\n          bbox: view.getNodeBBox(magnet),\n          magnet\n        });\n      });\n      candidates.forEach(candidate => {\n        const {\n          magnet,\n          bbox\n        } = candidate;\n        // find distance from the center of the model to pointer coordinates\n        const distance = bbox.center().squaredDistance(pointer);\n        // the connection is looked up in a circle area by `distance < r`\n        if (distance < minDistance) {\n          const isAlreadyValidated = prevClosestMagnet === magnet;\n          if (isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet))) {\n            minDistance = distance;\n            data.closestView = view;\n            data.closestMagnet = magnet;\n          }\n        }\n      });\n    }, this);\n    var end;\n    var magnetProxy = null;\n    var closestView = data.closestView;\n    var closestMagnet = data.closestMagnet;\n    if (closestMagnet) {\n      magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n    }\n    var endType = data.arrowhead;\n    var newClosestMagnet = prevClosestMagnet !== closestMagnet;\n    if (prevClosestView && newClosestMagnet) {\n      prevClosestView.unhighlight(prevMagnetProxy, {\n        connecting: true,\n        snapping: true\n      });\n    }\n    if (closestView) {\n      const {\n        prevEnd,\n        prevX,\n        prevY\n      } = data;\n      data.prevX = x;\n      data.prevY = y;\n      isSnapped = true;\n      if (!newClosestMagnet) {\n        if (typeof connectionStrategy !== 'function' || prevX === x && prevY === y) {\n          // the magnet has not changed and the link's end does not depend on the x and y\n          return isSnapped;\n        }\n      }\n      end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n      if (!newClosestMagnet && isEqual(prevEnd, end)) {\n        // the source/target json has not changed\n        return isSnapped;\n      }\n      data.prevEnd = end;\n      if (newClosestMagnet) {\n        closestView.highlight(magnetProxy, {\n          connecting: true,\n          snapping: true\n        });\n      }\n    } else {\n      end = {\n        x: x,\n        y: y\n      };\n    }\n    this.model.set(endType, end || {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n    if (prevClosestView) {\n      this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n    }\n    if (closestView) {\n      this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n    }\n    return isSnapped;\n  },\n  _snapArrowheadEnd: function (data) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    var closestView = data.closestView;\n    var closestMagnet = data.closestMagnet;\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(data.magnetProxy, {\n        connecting: true,\n        snapping: true\n      });\n      data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n    }\n    data.closestView = data.closestMagnet = null;\n  },\n  _connectArrowhead: function (target, x, y, data) {\n    // checking views right under the pointer\n    const {\n      paper,\n      model\n    } = this;\n    if (data.eventTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.magnetProxy) {\n        data.viewUnderPointer.unhighlight(data.magnetProxy, {\n          connecting: true\n        });\n      }\n      const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n      if (viewUnderPointer) {\n        // If we found a view that is under the pointer, we need to find the closest\n        // magnet based on the real target element of the event.\n        const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n        const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n        if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) {\n          // If there was no magnet found, do not highlight anything and assume there\n          // is no view under pointer we're interested in reconnecting to.\n          // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n          if (magnetProxy) {\n            viewUnderPointer.highlight(magnetProxy, {\n              connecting: true\n            });\n          }\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.magnetUnderPointer = null;\n          data.magnetProxy = null;\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.magnetUnderPointer = null;\n        data.magnetProxy = null;\n      }\n    }\n    data.eventTarget = target;\n    model.set(data.arrowhead, {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n  },\n  _connectArrowheadEnd: function (data = {}, x, y) {\n    const {\n      model\n    } = this;\n    const {\n      viewUnderPointer,\n      magnetUnderPointer,\n      magnetProxy,\n      arrowhead\n    } = data;\n    if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n    viewUnderPointer.unhighlight(magnetProxy, {\n      connecting: true\n    });\n\n    // The link end is taken from the magnet under the pointer, not the proxy.\n    const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n    model.set(arrowhead, end, {\n      ui: true\n    });\n  },\n  _beforeArrowheadMove: function (data) {\n    data.z = this.model.get('z');\n    this.model.toFront();\n\n    // Let the pointer propagate through the link view elements so that\n    // the `evt.target` is another element under the pointer, not the link itself.\n    var style = this.el.style;\n    data.pointerEvents = style.pointerEvents;\n    style.pointerEvents = 'none';\n    if (this.paper.options.markAvailable) {\n      this._markAvailableMagnets(data);\n    }\n  },\n  _afterArrowheadMove: function (data) {\n    if (data.z !== null) {\n      this.model.set('z', data.z, {\n        ui: true\n      });\n      data.z = null;\n    }\n\n    // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n    this.el.style.pointerEvents = data.pointerEvents;\n    if (this.paper.options.markAvailable) {\n      this._unmarkAvailableMagnets(data);\n    }\n  },\n  _createValidateConnectionArgs: function (arrowhead) {\n    // It makes sure the arguments for validateConnection have the following form:\n    // (source view, source magnet, target view, target magnet and link view)\n    var args = [];\n    args[4] = arrowhead;\n    args[5] = this;\n    var oppositeArrowhead;\n    var i = 0;\n    var j = 0;\n    if (arrowhead === 'source') {\n      i = 2;\n      oppositeArrowhead = 'target';\n    } else {\n      j = 2;\n      oppositeArrowhead = 'source';\n    }\n    var end = this.model.get(oppositeArrowhead);\n    if (end.id) {\n      var view = args[i] = this.paper.findViewByModel(end.id);\n      var magnet = view.getMagnetFromLinkEnd(end);\n      if (magnet === view.el) magnet = undefined;\n      args[i + 1] = magnet;\n    }\n    function validateConnectionArgs(cellView, magnet) {\n      args[j] = cellView;\n      args[j + 1] = cellView.el === magnet ? undefined : magnet;\n      return args;\n    }\n    return validateConnectionArgs;\n  },\n  _markAvailableMagnets: function (data) {\n    function isMagnetAvailable(view, magnet) {\n      var paper = view.paper;\n      var validate = paper.options.validateConnection;\n      return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n    }\n    var paper = this.paper;\n    var elements = paper.model.getCells();\n    data.marked = {};\n    for (var i = 0, n = elements.length; i < n; i++) {\n      var view = elements[i].findView(paper);\n      if (!view) {\n        continue;\n      }\n      var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n      if (view.el.getAttribute('magnet') !== 'false') {\n        // Element wrapping group is also a magnet\n        magnets.push(view.el);\n      }\n      var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (var j = 0, m = availableMagnets.length; j < m; j++) {\n          view.highlight(availableMagnets[j], {\n            magnetAvailability: true\n          });\n        }\n        // highlight the entire view\n        view.highlight(null, {\n          elementAvailability: true\n        });\n        data.marked[view.model.id] = availableMagnets;\n      }\n    }\n  },\n  _unmarkAvailableMagnets: function (data) {\n    var markedKeys = Object.keys(data.marked);\n    var id;\n    var markedMagnets;\n    for (var i = 0, n = markedKeys.length; i < n; i++) {\n      id = markedKeys[i];\n      markedMagnets = data.marked[id];\n      var view = this.paper.findViewByModel(id);\n      if (view) {\n        for (var j = 0, m = markedMagnets.length; j < m; j++) {\n          view.unhighlight(markedMagnets[j], {\n            magnetAvailability: true\n          });\n        }\n        view.unhighlight(null, {\n          elementAvailability: true\n        });\n      }\n    }\n    data.marked = null;\n  },\n  startArrowheadMove: function (end, opt) {\n    opt || (opt = {});\n\n    // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n    // move without need to click on the actual arrowhead dom element.\n    var data = {\n      action: 'arrowhead-move',\n      arrowhead: end,\n      whenNotAllowed: opt.whenNotAllowed || 'revert',\n      initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n      initialEnd: clone(this.model.get(end)),\n      validateConnectionArgs: this._createValidateConnectionArgs(end)\n    };\n    this._beforeArrowheadMove(data);\n    if (opt.ignoreBackwardsCompatibility !== true) {\n      this._dragData = data;\n    }\n    return data;\n  },\n  // Lifecycle methods\n\n  onMount: function () {\n    CellView.prototype.onMount.apply(this, arguments);\n    this.mountLabels();\n  },\n  onDetach: function () {\n    CellView.prototype.onDetach.apply(this, arguments);\n    this.unmountLabels();\n  },\n  onRemove: function () {\n    CellView.prototype.onRemove.apply(this, arguments);\n    this.unmountLabels();\n  }\n}, {\n  Flags: Flags\n});\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n  enumerable: true,\n  get: function () {\n    var sourceView = this.sourceView;\n    if (!sourceView) {\n      var sourceDef = this.model.source();\n      return new Rect(sourceDef.x, sourceDef.y);\n    }\n    var sourceMagnet = this.sourceMagnet;\n    if (sourceView.isNodeConnection(sourceMagnet)) {\n      return new Rect(this.sourceAnchor);\n    }\n    return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n  }\n});\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n  enumerable: true,\n  get: function () {\n    var targetView = this.targetView;\n    if (!targetView) {\n      var targetDef = this.model.target();\n      return new Rect(targetDef.x, targetDef.y);\n    }\n    var targetMagnet = this.targetMagnet;\n    if (targetView.isNodeConnection(targetMagnet)) {\n      return new Rect(this.targetAnchor);\n    }\n    return targetView.getNodeBBox(targetMagnet || targetView.el);\n  }\n});","map":{"version":3,"names":["CellView","Link","V","addClassNamePrefix","removeClassNamePrefix","merge","template","assign","toArray","isObject","isFunction","clone","isPercentage","result","isEqual","Point","Line","Path","normalizeAngle","Rect","Polyline","routers","connectors","$","Flags","TOOLS","RENDER","UPDATE","LEGACY_TOOLS","LABELS","VERTICES","SOURCE","TARGET","CONNECTOR","LinkView","extend","className","classNames","prototype","apply","split","push","join","options","shortLinkLength","doubleLinkTools","longLinkLength","linkToolsOffset","doubleLinkToolsOffset","sampleInterval","_labelCache","_labelSelectors","_markerCache","_V","_dragData","metrics","decimalsRounding","initialize","arguments","cleanNodesCache","presentationAttributes","markup","attrs","router","connector","smooth","manhattan","toolMarkup","labels","labelMarkup","vertices","vertexMarkup","source","target","initFlag","UPDATE_PRIORITY","confirmUpdate","flags","opt","hasFlag","updateEndProperties","removeFlag","paper","sourceView","targetView","isViewMounted","render","updateHighlighters","updateTools","renderVertexMarkers","model","attributes","updateLabels","updateLegacyTools","onLabelsChange","renderTools","updateAll","updateConnector","updatePath","updateDOM","translateBy","isRelationshipEmbeddedIn","translate","tx","ty","update","updateLabelPositions","updateToolsPosition","requestConnectionUpdate","requestUpdate","getFlag","isLabelsRenderRequired","previousLabels","previous","pathArray","propertyPathArray","pathLength","length","labelExists","Object","propertyValue","_link","_labels","renderLabels","vel","empty","unmountLabels","renderMarkup","link","get","Error","Array","isArray","renderJSONMarkup","renderStringMarkup","doc","parseDOMJSON","el","selectors","append","fragment","children","cache","i","n","child","attr","camelCase","renderArrowheadMarkers","_getLabelMarkup","undefined","_getLabelStringMarkup","document","createDocumentFragment","appendChild","node","currentChild","_normalizeLabelMarkup","DocumentFragment","hasChildNodes","vNode","childNodes","nodeName","toUpperCase","addClass","vLabels","labelCache","labelSelectors","labelsCount","remove","labelsLayer","id","label","labelNode","builtinDefaultLabel","_builtins","defaultLabel","builtinDefaultLabelMarkup","_getDefaultLabel","defaultLabelMarkup","defaultMarkup","setAttribute","rootSelector","selector","parent","mountLabels","hasLabels","getLayerView","insertSortedNode","parentNode","findLabelNode","labelIndex","labelRoot","findBySelector","_mergeLabelAttrs","hasCustomMarkup","labelAttrs","defaultLabelAttrs","builtinDefaultLabelAttrs","_mergeLabelSize","labelSize","defaultLabelSize","canLabelMove","can","size","updateDOMSubtreeAttributes","rootBBox","linkTools","$tools","toolTemplate","tool","_toolCache","tool2","doubleToolMarkup","_tool2Cache","markerVertices","$markerVertices","markupTemplate","forEach","vertex","idx","markerArrowheads","$markerArrowheads","arrowheadMarkup","sourceArrowhead","end","targetArrowhead","removeRedundantLinearVertices","SIMPLIFY_THRESHOLD","routePoints","sourceAnchor","targetAnchor","numRoutePoints","polyline","simplify","threshold","polylinePoints","points","map","point","toJSON","numPolylinePoints","slice","updateDefaultConnectionPath","connection","getSerializedConnection","connectionWrap","markerSource","markerTarget","_translateAndAutoOrientArrows","getEndView","type","getEndAnchor","getEndConnectionPoint","sourcePoint","targetPoint","getEndMagnet","sourceMagnet","targetMagnet","updateRoute","route","path","_translateConnectionPoints","updateArrowheadMarkers","perpendicular","anchors","findAnchors","findRoute","connectionPoints","findConnectionPoints","markerPoints","findMarkerPoints","findPath","firstWaypoint","lastWaypoint","sourceMarkerPoint","targetMarkerPoint","sourceBBox","getBBox","move","width","scale","sx","round","targetBBox","findAnchorsOrdered","firstEndType","firstRef","secondEndType","secondRef","firstAnchor","secondAnchor","firstAnchorRef","secondAnchorRef","firstDef","secondDef","firstView","secondView","firstMagnet","secondMagnet","getAnchor","anchor","res","firstVertex","lastVertex","priority","sourceDef","targetDef","paperOptions","isNodeConnection","sourceConnectionPointDef","connectionPoint","defaultConnectionPoint","sourcePointRef","sourceLine","getConnectionPoint","targetConnectionPointDef","targetPointRef","targetLine","anchorDef","cellView","magnet","ref","endType","isConnection","defaultLinkAnchor","perpendicularLinks","name","defaultAnchor","anchorFn","anchorName","anchorNamespace","call","args","connectionPointDef","view","line","linkConnectionPoint","linkConnectionMagnet","start","connectionPointFn","connectionPointName","connectionPointNamespace","offset","_getDefaultLabelPositionProperty","builtinDefaultLabelPosition","position","defaultLabelPosition","_normalizeLabelPosition","labelPosition","distance","angle","_mergeLabelPositionProperty","normalizedLabelPosition","normalizedDefaultLabelPosition","transformationMatrix","_getLabelTransformationMatrix","matrixToTransformString","_cleanLabelMatrices","index","magnetMatrix","connectionLength","getConnectionLength","Number","isNaN","toolPosition","getPointAtLength","x","y","css","endViewProperty","endDef","endId","updateEndMagnet","endModel","getModelById","endView","findView","endMagnetProperty","connectedMagnet","getMagnetFromLinkEnd","sourceArrow","targetArrow","translateAndAutoOrient","cells","_getLabelPositionProperty","_getLabelPositionAngle","_getLabelPositionArgs","_getDefaultLabelPositionArgs","_mergeLabelPositionArgs","labelPositionArgs","defaultLabelPositionArgs","addLabel","p1","p2","p3","p4","localX","localY","localAngle","localOpt","positionArgs","getLabelPosition","insertLabel","addVertex","isPointProvided","getVertexIndex","insertVertex","sendToken","token","callback","onAnimationEnd","vToken","duration","isReversed","direction","animationAttributes","dur","repeatCount","calcMode","fill","keyPoints","keyTimes","querySelector","SVGPathElement","appendTo","animateAlongPath","setTimeout","namespace","routerNamespace","defaultRouter","routerFn","connectorNamespace","defaultConnector","connectorFn","raw","normalizePathData","getConnection","hasOwnProperty","data","serialize","getConnectionSubdivisions","segmentSubdivisions","subdivisions","getSegmentSubdivisions","pointAtLength","getPointAtRatio","ratio","parseFloat","pointAt","getTangentAtLength","tangentAtLength","getTangentAtRatio","tangentAt","getClosestPoint","closestPoint","getClosestPointLength","closestPointLength","getClosestPointRatio","closestPointNormalizedLength","isDistanceRelative","absoluteDistance","isDistanceAbsoluteReverse","reverseDistance","isOffsetAbsolute","absoluteOffset","pathOpt","labelPoint","t","closestPointT","labelDistance","lengthAtT","tangent","tangentAtT","labelOffset","pointOffset","pointAtT","labelOffsetDiff","difference","labelAngle","labelOffsetCoordinates","positionOffset","isKeepGradient","keepGradient","isEnsureLegibility","ensureLegibility","translation","normal","rotate","setLength","createSVGMatrix","getLabelCoordinates","e","f","vertexLength","currentVertex","currentVertexLength","notifyPointerdown","evt","pointerdown","notify","notifyPointermove","pointermove","notifyPointerup","pointerup","pointerdblclick","pointerclick","contextmenu","getAttribute","dragVertexStart","dragVertexRemoveStart","dragArrowheadStart","dragConnectionStart","dragStart","dragData","eventData","action","dragVertex","dragLabel","dragArrowhead","drag","dragVertexEnd","dragLabelEnd","dragArrowheadEnd","dragEnd","checkMouseleave","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onevent","eventName","linkTool","findParentByClass","stopPropagation","ui","delegateDragEvents","onlabel","dragLabelStart","vertexIdx","isDefaultInteractionPrevented","currentTarget","labelIdx","parseInt","initialLabelPosition","coords","dx","dy","positionAngle","vertexNode","removeNode","removeVertex","arrowheadNode","arrowheadType","startArrowheadMove","ignoreBackwardsCompatibility","snapLabels","setOptions","isAsync","async","snapLinks","isSnapped","_snapArrowhead","snapLinksSelf","_snapArrowheadSelf","_connectArrowhead","getEventTarget","_snapArrowheadEnd","_connectArrowheadEnd","linkAllowed","_disallow","_finishEmbedding","_notifyConnectEvent","_afterArrowheadMove","whenNotAllowed","set","arrowhead","initialEnd","embeddingMode","reparent","z","currentEnd","prop","endChanged","endsEqual","findViewByModel","initialMagnet","magnetUnderPointer","_snapToPoints","snapPoint","radius","closestPointX","closestDistanceX","Infinity","closestPointY","closestDistanceY","distX","Math","abs","distY","localToClientPoint","elementFromPoint","connectionStrategy","r","viewsInArea","findViewsInArea","height","prevClosestView","closestView","prevClosestMagnet","closestMagnet","prevMagnetProxy","magnetProxy","minDistance","MAX_VALUE","pointer","candidates","bbox","getNodeBBox","candidate","center","squaredDistance","isAlreadyValidated","validateConnection","validateConnectionArgs","findProxyNode","newClosestMagnet","unhighlight","connecting","snapping","prevEnd","prevX","prevY","getLinkEnd","highlight","findMagnet","eventTarget","viewUnderPointer","_beforeArrowheadMove","toFront","style","pointerEvents","markAvailable","_markAvailableMagnets","_unmarkAvailableMagnets","_createValidateConnectionArgs","oppositeArrowhead","j","isMagnetAvailable","validate","elements","getCells","marked","magnets","querySelectorAll","availableMagnets","filter","bind","m","magnetAvailability","elementAvailability","markedKeys","keys","markedMagnets","onMount","onDetach","onRemove","defineProperty","enumerable"],"sources":["/Users/lijiaxin/Documents/workspace/hydsoft-oms-frontend/node_modules/jointjs/src/dia/LinkView.mjs"],"sourcesContent":["import { CellView } from './CellView.mjs';\nimport { Link } from './Link.mjs';\nimport V from '../V/index.mjs';\nimport { addClassNamePrefix, removeClassNamePrefix, merge, template, assign, toArray, isObject, isFunction, clone, isPercentage, result, isEqual } from '../util/index.mjs';\nimport { Point, Line, Path, normalizeAngle, Rect, Polyline } from '../g/index.mjs';\nimport * as routers from '../routers/index.mjs';\nimport * as connectors from '../connectors/index.mjs';\nimport $ from 'jquery';\n\nconst Flags = {\n    TOOLS: CellView.Flags.TOOLS,\n    RENDER: 'RENDER',\n    UPDATE: 'UPDATE',\n    LEGACY_TOOLS: 'LEGACY_TOOLS',\n    LABELS: 'LABELS',\n    VERTICES: 'VERTICES',\n    SOURCE: 'SOURCE',\n    TARGET: 'TARGET',\n    CONNECTOR: 'CONNECTOR'\n};\n\n// Link base view and controller.\n// ----------------------------------------\n\nexport const LinkView = CellView.extend({\n\n    className: function() {\n\n        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('link');\n\n        return classNames.join(' ');\n    },\n\n    options: {\n\n        shortLinkLength: 105,\n        doubleLinkTools: false,\n        longLinkLength: 155,\n        linkToolsOffset: 40,\n        doubleLinkToolsOffset: 65,\n        sampleInterval: 50\n    },\n\n    _labelCache: null,\n    _labelSelectors: null,\n    _markerCache: null,\n    _V: null,\n    _dragData: null, // deprecated\n\n    metrics: null,\n    decimalsRounding: 2,\n\n    initialize: function() {\n\n        CellView.prototype.initialize.apply(this, arguments);\n\n        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n        // nodes in `updateLabelPosition()` in order to update the label positions.\n        this._labelCache = {};\n\n        // a cache of label selectors\n        this._labelSelectors = {};\n\n        // keeps markers bboxes and positions again for quicker access\n        this._markerCache = {};\n\n        // cache of default markup nodes\n        this._V = {};\n\n        // connection path metrics\n        this.cleanNodesCache();\n    },\n\n    presentationAttributes: {\n        markup: [Flags.RENDER],\n        attrs: [Flags.UPDATE],\n        router: [Flags.UPDATE],\n        connector: [Flags.CONNECTOR],\n        smooth: [Flags.UPDATE],\n        manhattan: [Flags.UPDATE],\n        toolMarkup: [Flags.LEGACY_TOOLS],\n        labels: [Flags.LABELS],\n        labelMarkup: [Flags.LABELS],\n        vertices: [Flags.VERTICES, Flags.UPDATE],\n        vertexMarkup: [Flags.VERTICES],\n        source: [Flags.SOURCE, Flags.UPDATE],\n        target: [Flags.TARGET, Flags.UPDATE]\n    },\n\n    initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n\n    UPDATE_PRIORITY: 1,\n\n    confirmUpdate: function(flags, opt) {\n\n        opt || (opt = {});\n\n        if (this.hasFlag(flags, Flags.SOURCE)) {\n            if (!this.updateEndProperties('source')) return flags;\n            flags = this.removeFlag(flags, Flags.SOURCE);\n        }\n\n        if (this.hasFlag(flags, Flags.TARGET)) {\n            if (!this.updateEndProperties('target')) return flags;\n            flags = this.removeFlag(flags, Flags.TARGET);\n        }\n\n        const { paper, sourceView, targetView } = this;\n        if (paper && ((sourceView && !paper.isViewMounted(sourceView)) || (targetView && !paper.isViewMounted(targetView)))) {\n            // Wait for the sourceView and targetView to be rendered\n            return flags;\n        }\n\n        if (this.hasFlag(flags, Flags.RENDER)) {\n            this.render();\n            this.updateHighlighters(true);\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.VERTICES, Flags.LABELS, Flags.TOOLS, Flags.LEGACY_TOOLS, Flags.CONNECTOR]);\n            return flags;\n        }\n\n        let updateHighlighters = false;\n\n        if (this.hasFlag(flags, Flags.VERTICES)) {\n            this.renderVertexMarkers();\n            flags = this.removeFlag(flags, Flags.VERTICES);\n        }\n\n        const { model } = this;\n        const { attributes } = model;\n        let updateLabels = this.hasFlag(flags, Flags.LABELS);\n        let updateLegacyTools = this.hasFlag(flags, Flags.LEGACY_TOOLS);\n\n        if (updateLabels) {\n            this.onLabelsChange(model, attributes.labels, opt);\n            flags = this.removeFlag(flags, Flags.LABELS);\n            updateHighlighters = true;\n        }\n\n        if (updateLegacyTools) {\n            this.renderTools();\n            flags = this.removeFlag(flags, Flags.LEGACY_TOOLS);\n        }\n\n        const updateAll = this.hasFlag(flags, Flags.UPDATE);\n        const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n        if (updateAll || updateConnector) {\n            if (!updateAll) {\n                // Keep the current route and update the geometry\n                this.updatePath();\n                this.updateDOM();\n            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n                // The link is being translated by an ancestor that will\n                // shift source point, target point and all vertices\n                // by an equal distance.\n                this.translate(opt.tx, opt.ty);\n            } else {\n                this.update();\n            }\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n            updateLabels = false;\n            updateLegacyTools = false;\n            updateHighlighters = true;\n        }\n\n        if (updateLabels) {\n            this.updateLabelPositions();\n        }\n\n        if (updateLegacyTools) {\n            this.updateToolsPosition();\n        }\n\n        if (updateHighlighters) {\n            this.updateHighlighters();\n        }\n\n        if (this.hasFlag(flags, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, Flags.TOOLS);\n        }\n\n        return flags;\n    },\n\n    requestConnectionUpdate: function(opt) {\n        this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n    },\n\n    isLabelsRenderRequired: function(opt = {}) {\n\n        const previousLabels = this.model.previous('labels');\n        if (!previousLabels) return true;\n\n        // Here is an optimization for cases when we know, that change does\n        // not require re-rendering of all labels.\n        if (('propertyPathArray' in opt) && ('propertyValue' in opt)) {\n            // The label is setting by `prop()` method\n            var pathArray = opt.propertyPathArray || [];\n            var pathLength = pathArray.length;\n            if (pathLength > 1) {\n                // We are changing a single label here e.g. 'labels/0/position'\n                var labelExists = !!previousLabels[pathArray[1]];\n                if (labelExists) {\n                    if (pathLength === 2) {\n                        // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return ('markup' in Object(opt.propertyValue));\n                    } else if (pathArray[2] !== 'markup') {\n                        // We are changing a label property but not the markup\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    },\n\n    onLabelsChange: function(_link, _labels, opt) {\n\n        // Note: this optimization works in async=false mode only\n        if (this.isLabelsRenderRequired(opt)) {\n            this.renderLabels();\n        } else {\n            this.updateLabels();\n        }\n    },\n\n    // Rendering.\n    // ----------\n\n    render: function() {\n\n        this.vel.empty();\n        this.unmountLabels();\n        this._V = {};\n        this.renderMarkup();\n        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n        // returns zero values)\n        this.renderLabels();\n        this.update();\n\n        return this;\n    },\n\n    renderMarkup: function() {\n\n        var link = this.model;\n        var markup = link.get('markup') || link.markup;\n        if (!markup) throw new Error('dia.LinkView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.LinkView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        // Selectors\n        this.selectors = doc.selectors;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        // A special markup can be given in the `properties.markup` property. This might be handy\n        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n        // of elements with special meaning though. Therefore, those classes should be preserved in any\n        // special markup passed in `properties.markup`.\n        var children = V(markup);\n        // custom markup may contain only one children\n        if (!Array.isArray(children)) children = [children];\n        // Cache all children elements for quicker access.\n        var cache = this._V; // vectorized markup;\n        for (var i = 0, n = children.length; i < n; i++) {\n            var child = children[i];\n            var className = child.attr('class');\n            if (className) {\n                // Strip the joint class name prefix, if there is one.\n                className = removeClassNamePrefix(className);\n                cache[$.camelCase(className)] = child;\n            }\n        }\n        // partial rendering\n        this.renderTools();\n        this.renderVertexMarkers();\n        this.renderArrowheadMarkers();\n        this.vel.append(children);\n    },\n\n    _getLabelMarkup: function(labelMarkup) {\n\n        if (!labelMarkup) return undefined;\n\n        if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n        if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n        throw new Error('dia.linkView: invalid label markup');\n    },\n\n    _getLabelStringMarkup: function(labelMarkup) {\n\n        var children = V(labelMarkup);\n        var fragment = document.createDocumentFragment();\n\n        if (!Array.isArray(children)) {\n            fragment.appendChild(children.node);\n\n        } else {\n            for (var i = 0, n = children.length; i < n; i++) {\n                var currentChild = children[i].node;\n                fragment.appendChild(currentChild);\n            }\n        }\n\n        return { fragment: fragment, selectors: {}}; // no selectors\n    },\n\n    // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n    // If it doesn't, add the <g /> container here.\n    _normalizeLabelMarkup: function(markup) {\n\n        if (!markup) return undefined;\n\n        var fragment = markup.fragment;\n        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n\n        var vNode;\n        var childNodes = fragment.childNodes;\n\n        if ((childNodes.length > 1) || childNodes[0].nodeName.toUpperCase() !== 'G') {\n            // default markup fragment is not wrapped in <g />\n            // add a <g /> container\n            vNode = V('g').append(fragment);\n        } else {\n            vNode = V(childNodes[0]);\n        }\n\n        vNode.addClass('label');\n\n        return { node: vNode.node, selectors: markup.selectors };\n    },\n\n    renderLabels: function() {\n\n        var cache = this._V;\n        var vLabels = cache.labels;\n        var labelCache = this._labelCache = {};\n        var labelSelectors = this._labelSelectors = {};\n        var model = this.model;\n        var labels = model.attributes.labels || [];\n        var labelsCount = labels.length;\n\n        if (labelsCount === 0) {\n            if (vLabels) vLabels.remove();\n            return this;\n        }\n\n        if (vLabels) {\n            vLabels.empty();\n        }  else {\n            // there is no label container in the markup but some labels are defined\n            // add a <g class=\"labels\" /> container\n            vLabels = cache.labels = V('g').addClass('labels');\n            if (this.options.labelsLayer) {\n                vLabels.addClass(addClassNamePrefix(result(this, 'className')));\n                vLabels.attr('model-id', model.id);\n            }\n        }\n\n        for (var i = 0; i < labelsCount; i++) {\n\n            var label = labels[i];\n            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n            var labelNode;\n            var selectors;\n            if (labelMarkup) {\n\n                labelNode = labelMarkup.node;\n                selectors = labelMarkup.selectors;\n\n            } else {\n\n                var builtinDefaultLabel =  model._builtins.defaultLabel;\n                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n                var defaultLabel = model._getDefaultLabel();\n                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\n                labelNode = defaultMarkup.node;\n                selectors = defaultMarkup.selectors;\n            }\n\n            labelNode.setAttribute('label-idx', i); // assign label-idx\n            vLabels.append(labelNode);\n            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n            selectors[rootSelector] = labelNode;\n\n            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n        }\n        if (!vLabels.parent()) {\n            this.mountLabels();\n        }\n\n        this.updateLabels();\n\n        return this;\n    },\n\n    mountLabels: function() {\n        const { el, paper, model, _V, options } = this;\n        const { labels: vLabels } = _V;\n        if (!vLabels || !model.hasLabels()) return;\n        const { node } = vLabels;\n        if (options.labelsLayer) {\n            paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n        } else {\n            if (node.parentNode !== el) {\n                el.appendChild(node);\n            }\n        }\n    },\n\n    unmountLabels: function() {\n        const { options, _V } = this;\n        if (!_V) return;\n        const { labels: vLabels } = _V;\n        if (vLabels && options.labelsLayer) {\n            vLabels.remove();\n        }\n    },\n\n    findLabelNode: function(labelIndex, selector) {\n        const labelRoot = this._labelCache[labelIndex];\n        if (!labelRoot) return null;\n        const labelSelectors = this._labelSelectors[labelIndex];\n        const [node = null] = this.findBySelector(selector, labelRoot, labelSelectors);\n        return node;\n    },\n\n\n    // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\n        if (labelAttrs === null) return null;\n        if (labelAttrs === undefined) {\n\n            if (defaultLabelAttrs === null) return null;\n            if (defaultLabelAttrs === undefined) {\n\n                if (hasCustomMarkup) return undefined;\n                return builtinDefaultLabelAttrs;\n            }\n\n            if (hasCustomMarkup) return defaultLabelAttrs;\n            return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n        }\n\n        if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n        return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n    },\n\n    // merge default label size into label size (no built-in default)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelSize: function(labelSize, defaultLabelSize) {\n\n        if (labelSize === null) return null;\n        if (labelSize === undefined) {\n\n            if (defaultLabelSize === null) return null;\n            if (defaultLabelSize === undefined) return undefined;\n\n            return defaultLabelSize;\n        }\n\n        return merge({}, defaultLabelSize, labelSize);\n    },\n\n    updateLabels: function() {\n\n        if (!this._V.labels) return this;\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        var canLabelMove = this.can('labelMove');\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelMarkup = defaultLabel.markup;\n        var defaultLabelAttrs = defaultLabel.attrs;\n        var defaultLabelSize = defaultLabel.size;\n\n        for (var i = 0, n = labels.length; i < n; i++) {\n\n            var labelNode = this._labelCache[i];\n            labelNode.setAttribute('cursor', (canLabelMove ? 'move' : 'default'));\n\n            var selectors = this._labelSelectors[i];\n\n            var label = labels[i];\n            var labelMarkup = label.markup;\n            var labelAttrs = label.attrs;\n            var labelSize = label.size;\n\n            var attrs = this._mergeLabelAttrs(\n                (labelMarkup || defaultLabelMarkup),\n                labelAttrs,\n                defaultLabelAttrs,\n                builtinDefaultLabelAttrs\n            );\n\n            var size = this._mergeLabelSize(\n                labelSize,\n                defaultLabelSize\n            );\n\n            this.updateDOMSubtreeAttributes(labelNode, attrs, {\n                rootBBox: new Rect(size),\n                selectors: selectors\n            });\n        }\n\n        return this;\n    },\n\n    renderTools: function() {\n\n        if (!this._V.linkTools) return this;\n\n        // Tools are a group of clickable elements that manipulate the whole link.\n        // A good example of this is the remove tool that removes the whole link.\n        // Tools appear after hovering the link close to the `source` element/point of the link\n        // but are offset a bit so that they don't cover the `marker-arrowhead`.\n\n        var $tools = $(this._V.linkTools.node).empty();\n        var toolTemplate = template(this.model.get('toolMarkup') || this.model.toolMarkup);\n        var tool = V(toolTemplate());\n\n        $tools.append(tool.node);\n\n        // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\n        this._toolCache = tool;\n\n        // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\n        // link as well but only if the link is longer than `longLinkLength`.\n        if (this.options.doubleLinkTools) {\n\n            var tool2;\n            if (this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup) {\n                toolTemplate = template(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup);\n                tool2 = V(toolTemplate());\n            } else {\n                tool2 = tool.clone();\n            }\n\n            $tools.append(tool2.node);\n            this._tool2Cache = tool2;\n        }\n\n        return this;\n    },\n\n    renderVertexMarkers: function() {\n\n        if (!this._V.markerVertices) return this;\n\n        var $markerVertices = $(this._V.markerVertices.node).empty();\n\n        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n        // if default styling (elements) are not desired. This makes it possible to use any\n        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n        var markupTemplate = template(this.model.get('vertexMarkup') || this.model.vertexMarkup);\n\n        this.model.vertices().forEach(function(vertex, idx) {\n            $markerVertices.append(V(markupTemplate(assign({ idx: idx }, vertex))).node);\n        });\n\n        return this;\n    },\n\n    renderArrowheadMarkers: function() {\n\n        // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\n        if (!this._V.markerArrowheads) return this;\n\n        var $markerArrowheads = $(this._V.markerArrowheads.node);\n\n        $markerArrowheads.empty();\n\n        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n        // if default styling (elements) are not desired. This makes it possible to use any\n        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n        var markupTemplate = template(this.model.get('arrowheadMarkup') || this.model.arrowheadMarkup);\n\n        this._V.sourceArrowhead = V(markupTemplate({ end: 'source' }));\n        this._V.targetArrowhead = V(markupTemplate({ end: 'target' }));\n\n        $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\n\n        return this;\n    },\n\n    // remove vertices that lie on (or nearly on) straight lines within the link\n    // return the number of removed points\n    removeRedundantLinearVertices: function(opt) {\n\n        const SIMPLIFY_THRESHOLD = 0.001;\n\n        const link = this.model;\n        const vertices = link.vertices();\n        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n        const numRoutePoints = routePoints.length;\n\n        // put routePoints into a polyline and try to simplify\n        const polyline = new Polyline(routePoints);\n        polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n        const polylinePoints = polyline.points.map((point) => (point.toJSON())); // JSON of points after simplification\n        const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n        // shortcut if simplification did not remove any redundant vertices:\n        if (numRoutePoints === numPolylinePoints) return 0;\n\n        // else: set simplified polyline points as link vertices\n        // remove first and last polyline points again (= source/target anchors)\n        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n        return (numRoutePoints - numPolylinePoints);\n    },\n\n    updateDefaultConnectionPath: function() {\n\n        var cache = this._V;\n\n        if (cache.connection) {\n            cache.connection.attr('d', this.getSerializedConnection());\n        }\n\n        if (cache.connectionWrap) {\n            cache.connectionWrap.attr('d', this.getSerializedConnection());\n        }\n\n        if (cache.markerSource && cache.markerTarget) {\n            this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);\n        }\n    },\n\n    getEndView: function(type) {\n        switch (type) {\n            case 'source':\n                return this.sourceView || null;\n            case 'target':\n                return this.targetView || null;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndAnchor: function(type) {\n        switch (type) {\n            case 'source':\n                return new Point(this.sourceAnchor);\n            case 'target':\n                return new Point(this.targetAnchor);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndConnectionPoint: function(type) {\n        switch (type) {\n            case 'source':\n                return new Point(this.sourcePoint);\n            case 'target':\n                return new Point(this.targetPoint);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndMagnet: function(type) {\n        switch (type) {\n            case 'source':\n                var sourceView = this.sourceView;\n                if (!sourceView) break;\n                return this.sourceMagnet || sourceView.el;\n            case 'target':\n                var targetView = this.targetView;\n                if (!targetView) break;\n                return this.targetMagnet || targetView.el;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n        return null;\n    },\n\n\n    // Updating.\n    // ---------\n\n    update: function() {\n        this.updateRoute();\n        this.updatePath();\n        this.updateDOM();\n        return this;\n    },\n\n    translate: function(tx = 0, ty = 0) {\n        const { route, path } = this;\n        if (!route || !path) return;\n        // translate the route\n        const polyline = new Polyline(route);\n        polyline.translate(tx, ty);\n        this.route = polyline.points;\n        // translate source and target connection and marker points.\n        this._translateConnectionPoints(tx, ty);\n        // translate the geometry path\n        path.translate(tx, ty);\n        this.updateDOM();\n    },\n\n    updateDOM() {\n        const { el, model, selectors } = this;\n        this.cleanNodesCache();\n        // update SVG attributes defined by 'attrs/'.\n        this.updateDOMSubtreeAttributes(el, model.attr(), { selectors });\n        // legacy link path update\n        this.updateDefaultConnectionPath();\n        // update the label position etc.\n        this.updateLabelPositions();\n        this.updateToolsPosition();\n        this.updateArrowheadMarkers();\n        // *Deprecated*\n        // Local perpendicular flag (as opposed to one defined on paper).\n        // Could be enabled inside a connector/router. It's valid only\n        // during the update execution.\n        this.options.perpendicular = null;\n    },\n\n    updateRoute: function() {\n        const { model } = this;\n        const vertices = model.vertices();\n        // 1. Find Anchors\n        const anchors = this.findAnchors(vertices);\n        const sourceAnchor = this.sourceAnchor = anchors.source;\n        const targetAnchor = this.targetAnchor = anchors.target;\n        // 2. Find Route\n        const route = this.findRoute(vertices);\n        this.route = route;\n        // 3. Find Connection Points\n        var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n        this.sourcePoint = connectionPoints.source;\n        this.targetPoint = connectionPoints.target;\n    },\n\n    updatePath: function() {\n        const { route, sourcePoint, targetPoint } = this;\n        // 3b. Find Marker Connection Point - Backwards Compatibility\n        const markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint);\n        // 4. Find Connection\n        const path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);\n        this.path = path;\n    },\n\n    findMarkerPoints: function(route, sourcePoint, targetPoint) {\n\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n\n        // Move the source point by the width of the marker taking into account\n        // its scale around x-axis. Note that scale is the only transform that\n        // makes sense to be set in `.marker-source` attributes object\n        // as all other transforms (translate/rotate) will be replaced\n        // by the `translateAndAutoOrient()` function.\n        var cache = this._markerCache;\n        // cache source and target points\n        var sourceMarkerPoint, targetMarkerPoint;\n\n        if (this._V.markerSource) {\n\n            cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();\n            sourceMarkerPoint = Point(sourcePoint).move(\n                firstWaypoint || targetPoint,\n                cache.sourceBBox.width * this._V.markerSource.scale().sx * -1\n            ).round();\n        }\n\n        if (this._V.markerTarget) {\n\n            cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();\n            targetMarkerPoint = Point(targetPoint).move(\n                lastWaypoint || sourcePoint,\n                cache.targetBBox.width * this._V.markerTarget.scale().sx * -1\n            ).round();\n        }\n\n        // if there was no markup for the marker, use the connection point.\n        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n        cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n\n        return {\n            source: sourceMarkerPoint,\n            target: targetMarkerPoint\n        };\n    },\n\n    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n\n        var firstAnchor, secondAnchor;\n        var firstAnchorRef, secondAnchorRef;\n        var model = this.model;\n        var firstDef = model.get(firstEndType);\n        var secondDef = model.get(secondEndType);\n        var firstView = this.getEndView(firstEndType);\n        var secondView = this.getEndView(secondEndType);\n        var firstMagnet = this.getEndMagnet(firstEndType);\n        var secondMagnet = this.getEndMagnet(secondEndType);\n\n        // Anchor first\n        if (firstView) {\n            if (firstRef) {\n                firstAnchorRef = new Point(firstRef);\n            } else if (secondView) {\n                firstAnchorRef = secondMagnet;\n            } else {\n                firstAnchorRef = new Point(secondDef);\n            }\n            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n        } else {\n            firstAnchor = new Point(firstDef);\n        }\n\n        // Anchor second\n        if (secondView) {\n            secondAnchorRef = new Point(secondRef || firstAnchor);\n            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n        } else {\n            secondAnchor = new Point(secondDef);\n        }\n\n        var res = {};\n        res[firstEndType] = firstAnchor;\n        res[secondEndType] = secondAnchor;\n        return res;\n    },\n\n    findAnchors: function(vertices) {\n\n        var model = this.model;\n        var firstVertex = vertices[0];\n        var lastVertex = vertices[vertices.length - 1];\n\n        if (model.target().priority && !model.source().priority) {\n            // Reversed order\n            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n        }\n\n        // Usual order\n        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    },\n\n    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n        var model = this.model;\n        var sourceDef = model.get('source');\n        var targetDef = model.get('target');\n        var sourceView = this.sourceView;\n        var targetView = this.targetView;\n        var paperOptions = this.paper.options;\n        var sourceMagnet, targetMagnet;\n\n        // Connection Point Source\n        var sourcePoint;\n        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n            sourceMagnet = (this.sourceMagnet || sourceView.el);\n            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var sourcePointRef = firstWaypoint || targetAnchor;\n            var sourceLine = new Line(sourcePointRef, sourceAnchor);\n            sourcePoint = this.getConnectionPoint(\n                sourceConnectionPointDef,\n                sourceView,\n                sourceMagnet,\n                sourceLine,\n                'source'\n            );\n        } else {\n            sourcePoint = sourceAnchor;\n        }\n        // Connection Point Target\n        var targetPoint;\n        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n            targetMagnet = (this.targetMagnet || targetView.el);\n            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var targetPointRef = lastWaypoint || sourceAnchor;\n            var targetLine = new Line(targetPointRef, targetAnchor);\n            targetPoint = this.getConnectionPoint(\n                targetConnectionPointDef,\n                targetView,\n                targetMagnet,\n                targetLine,\n                'target'\n            );\n        } else {\n            targetPoint = targetAnchor;\n        }\n\n        return {\n            source: sourcePoint,\n            target: targetPoint\n        };\n    },\n\n    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n\n        var isConnection = cellView.isNodeConnection(magnet);\n        var paperOptions = this.paper.options;\n        if (!anchorDef) {\n            if (isConnection) {\n                anchorDef = paperOptions.defaultLinkAnchor;\n            } else {\n                if (paperOptions.perpendicularLinks || this.options.perpendicular) {\n                    // Backwards compatibility\n                    // If `perpendicularLinks` flag is set on the paper and there are vertices\n                    // on the link, then try to find a connection point that makes the link perpendicular\n                    // even though the link won't point to the center of the targeted object.\n                    anchorDef = { name: 'perpendicular' };\n                } else {\n                    anchorDef = paperOptions.defaultAnchor;\n                }\n            }\n        }\n\n        if (!anchorDef) throw new Error('Anchor required.');\n        var anchorFn;\n        if (typeof anchorDef === 'function') {\n            anchorFn = anchorDef;\n        } else {\n            var anchorName = anchorDef.name;\n            var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n            anchorFn = paperOptions[anchorNamespace][anchorName];\n            if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n        }\n        var anchor = anchorFn.call(\n            this,\n            cellView,\n            magnet,\n            ref,\n            anchorDef.args || {},\n            endType,\n            this\n        );\n        if (!anchor) return new Point();\n        return anchor.round(this.decimalsRounding);\n    },\n\n\n    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n\n        var connectionPoint;\n        var anchor = line.end;\n        var paperOptions = this.paper.options;\n\n        // Backwards compatibility\n        if (typeof paperOptions.linkConnectionPoint === 'function') {\n            var linkConnectionMagnet = (magnet === view.el) ? undefined : magnet;\n            connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);\n            if (connectionPoint) return connectionPoint;\n        }\n\n        if (!connectionPointDef) return anchor;\n        var connectionPointFn;\n        if (typeof connectionPointDef === 'function') {\n            connectionPointFn = connectionPointDef;\n        } else {\n            var connectionPointName = connectionPointDef.name;\n            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n            if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n        }\n        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n        if (!connectionPoint) return anchor;\n        return connectionPoint.round(this.decimalsRounding);\n    },\n\n    _translateConnectionPoints: function(tx, ty) {\n\n        var cache = this._markerCache;\n\n        cache.sourcePoint.offset(tx, ty);\n        cache.targetPoint.offset(tx, ty);\n        this.sourcePoint.offset(tx, ty);\n        this.targetPoint.offset(tx, ty);\n        this.sourceAnchor.offset(tx, ty);\n        this.targetAnchor.offset(tx, ty);\n    },\n\n    // combine default label position with built-in default label position\n    _getDefaultLabelPositionProperty: function() {\n\n        var model = this.model;\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n        return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n    },\n\n    // if label position is a number, normalize it to a position object\n    // this makes sure that label positions can be merged properly\n    _normalizeLabelPosition: function(labelPosition) {\n\n        if (typeof labelPosition === 'number') return { distance: labelPosition, offset: null, angle: 0, args: null };\n        return labelPosition;\n    },\n\n    // expects normalized position properties\n    // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n    _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {\n\n        if (normalizedLabelPosition === null) return null;\n        if (normalizedLabelPosition === undefined) {\n\n            if (normalizedDefaultLabelPosition === null) return null;\n            return normalizedDefaultLabelPosition;\n        }\n\n        return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n    },\n\n    updateLabelPositions: function() {\n\n        if (!this._V.labels) return this;\n\n        var path = this.path;\n        if (!path) return this;\n\n        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        if (!labels.length) return this;\n\n        var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\n        for (var idx = 0, n = labels.length; idx < n; idx++) {\n            var labelNode = this._labelCache[idx];\n            if (!labelNode) continue;\n            var label = labels[idx];\n            var labelPosition = this._normalizeLabelPosition(label.position);\n            var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n            var transformationMatrix = this._getLabelTransformationMatrix(position);\n            labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n            this._cleanLabelMatrices(idx);\n        }\n\n        return this;\n    },\n\n    _cleanLabelMatrices: function(index) {\n        // Clean magnetMatrix for all nodes of the label.\n        // Cached BoundingRect does not need to updated when the position changes\n        // TODO: this doesn't work for labels with XML String markups.\n        const { metrics, _labelSelectors } = this;\n        const selectors = _labelSelectors[index];\n        if (!selectors) return;\n        for (let selector in selectors) {\n            const { id } = selectors[selector];\n            if (id && (id in metrics)) delete metrics[id].magnetMatrix;\n        }\n    },\n\n    updateToolsPosition: function() {\n\n        if (!this._V.linkTools) return this;\n\n        // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\n        // Note that the offset is hardcoded here. The offset should be always\n        // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n        // this up all the time would be slow.\n\n        var scale = '';\n        var offset = this.options.linkToolsOffset;\n        var connectionLength = this.getConnectionLength();\n\n        // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\n        // In that case we won't update tools position at all.\n        if (!Number.isNaN(connectionLength)) {\n\n            // If the link is too short, make the tools half the size and the offset twice as low.\n            if (connectionLength < this.options.shortLinkLength) {\n                scale = 'scale(.5)';\n                offset /= 2;\n            }\n\n            var toolPosition = this.getPointAtLength(offset);\n\n            this._toolCache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\n            if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\n\n                var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\n\n                toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\n                this._tool2Cache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n                this._tool2Cache.attr('display', 'inline');\n\n            } else if (this.options.doubleLinkTools) {\n\n                this._tool2Cache.attr('display', 'none');\n            }\n        }\n\n        return this;\n    },\n\n    updateArrowheadMarkers: function() {\n\n        if (!this._V.markerArrowheads) return this;\n\n        // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\n        if ($.css(this._V.markerArrowheads.node, 'display') === 'none') return this;\n\n        var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n        this._V.sourceArrowhead.scale(sx);\n        this._V.targetArrowhead.scale(sx);\n\n        this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\n\n        return this;\n    },\n\n    updateEndProperties: function(endType) {\n\n        const { model, paper } = this;\n        const endViewProperty = `${endType}View`;\n        const endDef = model.get(endType);\n        const endId = endDef && endDef.id;\n\n        if (!endId) {\n            // the link end is a point ~ rect 0x0\n            this[endViewProperty] = null;\n            this.updateEndMagnet(endType);\n            return true;\n        }\n\n        const endModel = paper.getModelById(endId);\n        if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n\n        const endView = endModel.findView(paper);\n        if (!endView) {\n            // A view for a model should always exist\n            return false;\n        }\n\n        this[endViewProperty] = endView;\n        this.updateEndMagnet(endType);\n        return true;\n    },\n\n    updateEndMagnet: function(endType) {\n\n        const endMagnetProperty = `${endType}Magnet`;\n        const endView = this.getEndView(endType);\n        if (endView) {\n            let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n            if (connectedMagnet === endView.el) connectedMagnet = null;\n            this[endMagnetProperty] = connectedMagnet;\n        } else {\n            this[endMagnetProperty] = null;\n        }\n    },\n\n    _translateAndAutoOrientArrows: function(sourceArrow, targetArrow) {\n\n        // Make the markers \"point\" to their sticky points being auto-oriented towards\n        // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\n        var route = toArray(this.route);\n        if (sourceArrow) {\n            sourceArrow.translateAndAutoOrient(\n                this.sourcePoint,\n                route[0] || this.targetPoint,\n                this.paper.cells\n            );\n        }\n\n        if (targetArrow) {\n            targetArrow.translateAndAutoOrient(\n                this.targetPoint,\n                route[route.length - 1] || this.sourcePoint,\n                this.paper.cells\n            );\n        }\n    },\n\n    _getLabelPositionProperty: function(idx) {\n\n        return (this.model.label(idx).position || {});\n    },\n\n    _getLabelPositionAngle: function(idx) {\n\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return (labelPosition.angle || 0);\n    },\n\n    _getLabelPositionArgs: function(idx) {\n\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return labelPosition.args;\n    },\n\n    _getDefaultLabelPositionArgs: function() {\n\n        var defaultLabel = this.model._getDefaultLabel();\n        var defaultLabelPosition = defaultLabel.position || {};\n        return defaultLabelPosition.args;\n    },\n\n    // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n\n        if (labelPositionArgs === null) return null;\n        if (labelPositionArgs === undefined) {\n\n            if (defaultLabelPositionArgs === null) return null;\n            return defaultLabelPositionArgs;\n        }\n\n        return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n    },\n\n    // Add default label at given position at end of `labels` array.\n    // Four signatures:\n    // - obj, obj = point, opt\n    // - obj, num, obj = point, angle, opt\n    // - num, num, obj = x, y, opt\n    // - num, num, num, obj = x, y, angle, opt\n    // Assigns relative coordinates by default:\n    // `opt.absoluteDistance` forces absolute coordinates.\n    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n    // `opt.absoluteOffset` forces absolute coordinates for offset.\n    // Additional args:\n    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n    // `opt.ensureLegibility` rotates labels so they are never upside-down.\n    addLabel: function(p1, p2, p3, p4) {\n\n        // normalize data from the four possible signatures\n        var localX;\n        var localY;\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p1 !== 'number') {\n            // {x, y} object provided as first parameter\n            localX = p1.x;\n            localY = p1.y;\n            if (typeof p2 === 'number') {\n                // angle and opt provided as second and third parameters\n                localAngle = p2;\n                localOpt = p3;\n            } else {\n                // opt provided as second parameter\n                localOpt = p2;\n            }\n        } else {\n            // x and y provided as first and second parameters\n            localX = p1;\n            localY = p2;\n            if (typeof p3 === 'number') {\n                // angle and opt provided as third and fourth parameters\n                localAngle = p3;\n                localOpt = p4;\n            } else {\n                // opt provided as third parameter\n                localOpt = p3;\n            }\n        }\n\n        // merge label position arguments\n        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n        var labelPositionArgs = localOpt;\n        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n        // append label to labels array\n        var label = { position: this.getLabelPosition(localX, localY, localAngle, positionArgs) };\n        var idx = -1;\n        this.model.insertLabel(idx, label, localOpt);\n        return idx;\n    },\n\n    // Add a new vertex at calculated index to the `vertices` array.\n    addVertex: function(x, y, opt) {\n\n        // accept input in form `{ x, y }, opt` or `x, y, opt`\n        var isPointProvided = (typeof x !== 'number');\n        var localX = isPointProvided ? x.x : x;\n        var localY = isPointProvided ? x.y : y;\n        var localOpt = isPointProvided ? y : opt;\n\n        var vertex = { x: localX, y: localY };\n        var idx = this.getVertexIndex(localX, localY);\n        this.model.insertVertex(idx, vertex, localOpt);\n        return idx;\n    },\n\n    // Send a token (an SVG element, usually a circle) along the connection path.\n    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n    // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n    // `opt.connection` is an optional selector to the connection path.\n    // `callback` is optional and is a function to be called once the token reaches the target.\n    sendToken: function(token, opt, callback) {\n\n        function onAnimationEnd(vToken, callback) {\n            return function() {\n                vToken.remove();\n                if (typeof callback === 'function') {\n                    callback();\n                }\n            };\n        }\n\n        var duration, isReversed, selector;\n        if (isObject(opt)) {\n            duration = opt.duration;\n            isReversed = (opt.direction === 'reverse');\n            selector = opt.connection;\n        } else {\n            // Backwards compatibility\n            duration = opt;\n            isReversed = false;\n            selector = null;\n        }\n\n        duration = duration || 1000;\n\n        var animationAttributes = {\n            dur: duration + 'ms',\n            repeatCount: 1,\n            calcMode: 'linear',\n            fill: 'freeze'\n        };\n\n        if (isReversed) {\n            animationAttributes.keyPoints = '1;0';\n            animationAttributes.keyTimes = '0;1';\n        }\n\n        var vToken = V(token);\n        var connection;\n        if (typeof selector === 'string') {\n            // Use custom connection path.\n            connection = this.findBySelector(selector, this.el, this.selectors)[0];\n        } else {\n            // Select connection path automatically.\n            var cache = this._V;\n            connection = (cache.connection) ? cache.connection.node : this.el.querySelector('path');\n        }\n\n        if (!(connection instanceof SVGPathElement)) {\n            throw new Error('dia.LinkView: token animation requires a valid connection path.');\n        }\n\n        vToken\n            .appendTo(this.paper.cells)\n            .animateAlongPath(animationAttributes, connection);\n\n        setTimeout(onAnimationEnd(vToken, callback), duration);\n    },\n\n    findRoute: function(vertices) {\n\n        vertices || (vertices = []);\n\n        var namespace = this.paper.options.routerNamespace || routers;\n        var router = this.model.router();\n        var defaultRouter = this.paper.options.defaultRouter;\n\n        if (!router) {\n            if (defaultRouter) router = defaultRouter;\n            else return vertices.map(Point); // no router specified\n        }\n\n        var routerFn = isFunction(router) ? router : namespace[router.name];\n        if (!isFunction(routerFn)) {\n            throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n        }\n\n        var args = router.args || {};\n\n        var route = routerFn.call(\n            this, // context\n            vertices, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (!route) return vertices.map(Point);\n        return route;\n    },\n\n    // Return the `d` attribute value of the `<path>` element representing the link\n    // between `source` and `target`.\n    findPath: function(route, sourcePoint, targetPoint) {\n\n        var namespace = this.paper.options.connectorNamespace || connectors;\n        var connector = this.model.connector();\n        var defaultConnector = this.paper.options.defaultConnector;\n\n        if (!connector) {\n            connector = defaultConnector || {};\n        }\n\n        var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n        if (!isFunction(connectorFn)) {\n            throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n        }\n\n        var args = clone(connector.args || {});\n        args.raw = true; // Request raw g.Path as the result.\n\n        var path = connectorFn.call(\n            this, // context\n            sourcePoint, // start point\n            targetPoint, // end point\n            route, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (typeof path === 'string') {\n            // Backwards compatibility for connectors not supporting `raw` option.\n            path = new Path(V.normalizePathData(path));\n        }\n\n        return path;\n    },\n\n    // Public API.\n    // -----------\n\n    getConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.clone();\n    },\n\n    getSerializedConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('data')) return metrics.data;\n        var data = path.serialize();\n        metrics.data = data;\n        return data;\n    },\n\n    getConnectionSubdivisions: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n        var subdivisions = path.getSegmentSubdivisions();\n        metrics.segmentSubdivisions = subdivisions;\n        return subdivisions;\n    },\n\n    getConnectionLength: function() {\n\n        var path = this.path;\n        if (!path) return 0;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('length')) return metrics.length;\n        var length = path.length({ segmentSubdivisions: this.getConnectionSubdivisions() });\n        metrics.length = length;\n        return length;\n    },\n\n    getPointAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.pointAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getPointAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n        if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n        return path.pointAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPoint: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPoint(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointLength: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointRatio: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointNormalizedLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    // Get label position object based on two provided coordinates, x and y.\n    // (Used behind the scenes when user moves labels around.)\n    // Two signatures:\n    // - num, num, obj = x, y, options\n    // - num, num, num, obj = x, y, angle, options\n    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n    // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n    getLabelPosition: function(x, y, p3, p4) {\n\n        var position = {};\n\n        // normalize data from the two possible signatures\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p3 === 'number') {\n            // angle and opt provided as third and fourth argument\n            localAngle = p3;\n            localOpt = p4;\n        } else {\n            // opt provided as third argument\n            localOpt = p3;\n        }\n\n        // save localOpt as `args` of the position object that is passed along\n        if (localOpt) position.args = localOpt;\n\n        // identify distance/offset settings\n        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n        var isDistanceAbsoluteReverse = (localOpt && localOpt.absoluteDistance && localOpt.reverseDistance); // non-reverse by default\n        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n        // find closest point t\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n        var labelPoint = new Point(x, y);\n        var t = path.closestPointT(labelPoint, pathOpt);\n\n        // DISTANCE:\n        var labelDistance = path.lengthAtT(t, pathOpt);\n        if (isDistanceRelative) labelDistance = (labelDistance / this.getConnectionLength()) || 0; // fix to prevent NaN for 0 length\n        if (isDistanceAbsoluteReverse) labelDistance = (-1 * (this.getConnectionLength() - labelDistance)) || 1; // fix for end point (-0 => 1)\n        position.distance = labelDistance;\n\n        // OFFSET:\n        // use absolute offset if:\n        // - opt.absoluteOffset is true,\n        // - opt.absoluteOffset is not true but there is no tangent\n        var tangent;\n        if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n        var labelOffset;\n        if (tangent) {\n            labelOffset = tangent.pointOffset(labelPoint);\n        } else {\n            var closestPoint = path.pointAtT(t);\n            var labelOffsetDiff = labelPoint.difference(closestPoint);\n            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n        }\n        position.offset = labelOffset;\n\n        // ANGLE:\n        position.angle = localAngle;\n\n        return position;\n    },\n\n    _getLabelTransformationMatrix: function(labelPosition) {\n\n        var labelDistance;\n        var labelAngle = 0;\n        var args = {};\n        if (typeof labelPosition === 'number') {\n            labelDistance = labelPosition;\n        } else if (typeof labelPosition.distance === 'number') {\n            args = labelPosition.args || {};\n            labelDistance = labelPosition.distance;\n            labelAngle = labelPosition.angle || 0;\n        } else {\n            throw new Error('dia.LinkView: invalid label position distance.');\n        }\n\n        var isDistanceRelative = ((labelDistance > 0) && (labelDistance <= 1));\n\n        var labelOffset = 0;\n        var labelOffsetCoordinates = { x: 0, y: 0 };\n        if (labelPosition.offset) {\n            var positionOffset = labelPosition.offset;\n            if (typeof positionOffset === 'number') labelOffset = positionOffset;\n            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n        }\n\n        var isOffsetAbsolute = ((labelOffsetCoordinates.x !== 0) || (labelOffsetCoordinates.y !== 0) || labelOffset === 0);\n\n        var isKeepGradient = args.keepGradient;\n        var isEnsureLegibility = args.ensureLegibility;\n\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\n        var distance = isDistanceRelative ? (labelDistance * this.getConnectionLength()) : labelDistance;\n        var tangent = path.tangentAtLength(distance, pathOpt);\n\n        var translation;\n        var angle = labelAngle;\n        if (tangent) {\n            if (isOffsetAbsolute) {\n                translation = tangent.start.clone();\n                translation.offset(labelOffsetCoordinates);\n            } else {\n                var normal = tangent.clone();\n                normal.rotate(tangent.start, -90);\n                normal.setLength(labelOffset);\n                translation = normal.end;\n            }\n\n            if (isKeepGradient) {\n                angle = (tangent.angle() + labelAngle);\n                if (isEnsureLegibility) {\n                    angle = normalizeAngle(((angle + 90) % 180) - 90);\n                }\n            }\n\n        } else {\n            // fallback - the connection has zero length\n            translation = path.start.clone();\n            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n        }\n\n        return V.createSVGMatrix()\n            .translate(translation.x, translation.y)\n            .rotate(angle);\n    },\n\n    getLabelCoordinates: function(labelPosition) {\n\n        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n        return new Point(transformationMatrix.e, transformationMatrix.f);\n    },\n\n    getVertexIndex: function(x, y) {\n\n        var model = this.model;\n        var vertices = model.vertices();\n\n        var vertexLength = this.getClosestPointLength(new Point(x, y));\n\n        var idx = 0;\n        for (var n = vertices.length; idx < n; idx++) {\n            var currentVertex = vertices[idx];\n            var currentVertexLength = this.getClosestPointLength(currentVertex);\n            if (vertexLength < currentVertexLength) break;\n        }\n\n        return idx;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('link:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('link:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('link:pointerup', evt, x, y);\n        CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('link:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('link:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('link:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n\n        // Backwards compatibility for the default markup\n        var className = evt.target.getAttribute('class');\n        switch (className) {\n\n            case 'marker-vertex':\n                this.dragVertexStart(evt, x, y);\n                return;\n\n            case 'marker-vertex-remove':\n            case 'marker-vertex-remove-area':\n                this.dragVertexRemoveStart(evt, x, y);\n                return;\n\n            case 'marker-arrowhead':\n                this.dragArrowheadStart(evt, x, y);\n                return;\n\n            case 'connection':\n            case 'connection-wrap':\n                this.dragConnectionStart(evt, x, y);\n                return;\n\n            case 'marker-source':\n            case 'marker-target':\n                return;\n        }\n\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) this.eventData(evt, dragData);\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'vertex-move':\n                this.dragVertex(evt, x, y);\n                break;\n\n            case 'label-move':\n                this.dragLabel(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowhead(evt, x, y);\n                break;\n\n            case 'move':\n                this.drag(evt, x, y);\n                break;\n        }\n\n        // Backwards compatibility\n        if (dragData) assign(dragData, this.eventData(evt));\n\n        this.notifyPointermove(evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) {\n            this.eventData(evt, dragData);\n            this._dragData = null;\n        }\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'vertex-move':\n                this.dragVertexEnd(evt, x, y);\n                break;\n\n            case 'label-move':\n                this.dragLabelEnd(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowheadEnd(evt, x, y);\n                break;\n\n            case 'move':\n                this.dragEnd(evt, x, y);\n        }\n\n        this.notifyPointerup(evt, x, y);\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('link:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('link:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('link:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('link:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('link:mousewheel', evt, x, y, delta);\n    },\n\n    onevent: function(evt, eventName, x, y) {\n\n        // Backwards compatibility\n        var linkTool = V(evt.target).findParentByClass('link-tool', this.el);\n        if (linkTool) {\n            // No further action to be executed\n            evt.stopPropagation();\n\n            // Allow `interactive.useLinkTools=false`\n            if (this.can('useLinkTools')) {\n                if (eventName === 'remove') {\n                    // Built-in remove event\n                    this.model.remove({ ui: true });\n                    // Do not trigger link pointerdown\n                    return;\n\n                } else {\n                    // link:options and other custom events inside the link tools\n                    this.notify(eventName, evt, x, y);\n                }\n            }\n\n            this.notifyPointerdown(evt, x, y);\n            this.paper.delegateDragEvents(this, evt.data);\n\n        } else {\n            CellView.prototype.onevent.apply(this, arguments);\n        }\n    },\n\n    onlabel: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n\n        this.dragLabelStart(evt, x, y);\n\n        var stopPropagation = this.eventData(evt).stopPropagation;\n        if (stopPropagation) evt.stopPropagation();\n    },\n\n    // Drag Start Handlers\n\n    dragConnectionStart: function(evt, x, y) {\n\n        if (!this.can('vertexAdd')) return;\n\n        // Store the index at which the new vertex has just been placed.\n        // We'll be update the very same vertex position in `pointermove()`.\n        var vertexIdx = this.addVertex({ x: x, y: y }, { ui: true });\n        this.eventData(evt, {\n            action: 'vertex-move',\n            vertexIdx: vertexIdx\n        });\n    },\n\n    dragLabelStart: function(evt, x, y) {\n\n        if (this.can('labelMove')) {\n\n            if (this.isDefaultInteractionPrevented(evt)) return;\n\n            var labelNode = evt.currentTarget;\n            var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n            var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n            var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n            var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n\n            var coords = this.getLabelCoordinates(position);\n            var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n            var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n\n            var positionAngle = this._getLabelPositionAngle(labelIdx);\n            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n            this.eventData(evt, {\n                action: 'label-move',\n                labelIdx: labelIdx,\n                dx: dx,\n                dy: dy,\n                positionAngle: positionAngle,\n                positionArgs: positionArgs,\n                stopPropagation: true\n            });\n\n        } else {\n\n            // Backwards compatibility:\n            // If labels can't be dragged no default action is triggered.\n            this.eventData(evt, { stopPropagation: true });\n        }\n\n        this.paper.delegateDragEvents(this, evt.data);\n    },\n\n    dragVertexStart: function(evt, x, y) {\n\n        if (!this.can('vertexMove')) return;\n\n        var vertexNode = evt.target;\n        var vertexIdx = parseInt(vertexNode.getAttribute('idx'), 10);\n        this.eventData(evt, {\n            action: 'vertex-move',\n            vertexIdx: vertexIdx\n        });\n    },\n\n    dragVertexRemoveStart: function(evt, x, y) {\n\n        if (!this.can('vertexRemove')) return;\n\n        var removeNode = evt.target;\n        var vertexIdx = parseInt(removeNode.getAttribute('idx'), 10);\n        this.model.removeVertex(vertexIdx);\n    },\n\n    dragArrowheadStart: function(evt, x, y) {\n\n        if (!this.can('arrowheadMove')) return;\n\n        var arrowheadNode = evt.target;\n        var arrowheadType = arrowheadNode.getAttribute('end');\n        var data = this.startArrowheadMove(arrowheadType, { ignoreBackwardsCompatibility: true });\n\n        this.eventData(evt, data);\n    },\n\n    dragStart: function(evt, x, y) {\n\n        if (this.isDefaultInteractionPrevented(evt)) return;\n\n        if (!this.can('linkMove')) return;\n\n        this.eventData(evt, {\n            action: 'move',\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag Handlers\n    dragLabel: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var label = { position: this.getLabelPosition((x + data.dx), (y + data.dy), data.positionAngle, data.positionArgs) };\n        if (this.paper.options.snapLabels) delete label.position.offset;\n        // The `touchmove' events are not fired\n        // when the original event target is removed from the DOM.\n        // The labels are currently re-rendered completely when only\n        // the position changes. This is why we need to make sure that\n        // the label is updated synchronously.\n        // TODO: replace `touchmove` with `pointermove` (breaking change).\n        const setOptions = { ui: true };\n        if (this.paper.isAsync() && evt.type === 'touchmove') {\n            setOptions.async = false;\n        }\n        this.model.label(data.labelIdx, label, setOptions);\n    },\n\n    dragVertex: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        this.model.vertex(data.vertexIdx, { x: x, y: y }, { ui: true });\n    },\n\n    dragArrowhead: function(evt, x, y) {\n        if (this.paper.options.snapLinks) {\n            const isSnapped = this._snapArrowhead(evt, x, y);\n            if (!isSnapped && this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            }\n        } else {\n            if (this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            } else {\n                this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n            }\n        }\n    },\n\n    drag: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        this.model.translate(x - data.dx, y - data.dy, { ui: true });\n        this.eventData(evt, {\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag End Handlers\n\n    dragLabelEnd: function() {\n        // noop\n    },\n\n    dragVertexEnd: function() {\n        // noop\n    },\n\n    dragArrowheadEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var paper = this.paper;\n\n        if (paper.options.snapLinks) {\n            this._snapArrowheadEnd(data);\n        } else {\n            this._connectArrowheadEnd(data, x, y);\n        }\n\n        if (!paper.linkAllowed(this)) {\n            // If the changed link is not allowed, revert to its previous state.\n            this._disallow(data);\n        } else {\n            this._finishEmbedding(data);\n            this._notifyConnectEvent(data, evt);\n        }\n\n        this._afterArrowheadMove(data);\n    },\n\n    dragEnd: function() {\n        // noop\n    },\n\n    _disallow: function(data) {\n\n        switch (data.whenNotAllowed) {\n\n            case 'remove':\n                this.model.remove({ ui: true });\n                break;\n\n            case 'revert':\n            default:\n                this.model.set(data.arrowhead, data.initialEnd, { ui: true });\n                break;\n        }\n    },\n\n    _finishEmbedding: function(data) {\n\n        // Reparent the link if embedding is enabled\n        if (this.paper.options.embeddingMode && this.model.reparent()) {\n            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n            data.z = null;\n        }\n    },\n\n    _notifyConnectEvent: function(data, evt) {\n\n        var arrowhead = data.arrowhead;\n        var initialEnd = data.initialEnd;\n        var currentEnd = this.model.prop(arrowhead);\n        var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n        if (endChanged) {\n            var paper = this.paper;\n            if (initialEnd.id) {\n                this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n            }\n            if (currentEnd.id) {\n                this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n            }\n        }\n    },\n\n    _snapToPoints: function(snapPoint, points, radius) {\n        let closestPointX = null;\n        let closestDistanceX = Infinity;\n\n        let closestPointY = null;\n        let closestDistanceY = Infinity;\n\n        let x = snapPoint.x;\n        let y = snapPoint.y;\n\n        for (let i = 0; i < points.length; i++) {\n            const distX = Math.abs(points[i].x - snapPoint.x);\n            if (distX < closestDistanceX) {\n                closestDistanceX = distX;\n                closestPointX = points[i];\n            }\n\n            const distY = Math.abs(points[i].y - snapPoint.y);\n            if (distY < closestDistanceY) {\n                closestDistanceY = distY;\n                closestPointY = points[i];\n            }\n        }\n\n        if (closestDistanceX < radius) {\n            x = closestPointX.x;\n        }\n        if (closestDistanceY < radius) {\n            y = closestPointY.y;\n        }\n\n        return { x, y };\n    },\n\n    _snapArrowheadSelf: function(evt, x, y) {\n\n        const { paper, model } = this;\n        const { snapLinksSelf } = paper.options;\n        const data = this.eventData(evt);\n        const radius = snapLinksSelf.radius || 20;\n\n        const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');\n        const vertices = model.vertices();\n        const points = [anchor, ...vertices];\n\n        const snapPoint = this._snapToPoints({ x: x, y: y }, points, radius);\n\n        const point = paper.localToClientPoint(snapPoint);\n        this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n    },\n\n    _snapArrowhead: function(evt, x, y) {\n\n        const { paper } = this;\n        const { snapLinks, connectionStrategy } = paper.options;\n        const data = this.eventData(evt);\n        let isSnapped = false;\n        // checking view in close area of the pointer\n\n        var r = snapLinks.radius || 50;\n        var viewsInArea = paper.findViewsInArea({ x: x - r, y: y - r, width: 2 * r, height: 2 * r });\n\n        var prevClosestView = data.closestView || null;\n        var prevClosestMagnet = data.closestMagnet || null;\n        var prevMagnetProxy = data.magnetProxy || null;\n\n        data.closestView = data.closestMagnet = data.magnetProxy = null;\n\n        var minDistance = Number.MAX_VALUE;\n        var pointer = new Point(x, y);\n\n        viewsInArea.forEach(function(view) {\n            const candidates = [];\n            // skip connecting to the element in case '.': { magnet: false } attribute present\n            if (view.el.getAttribute('magnet') !== 'false') {\n                candidates.push({\n                    bbox: view.model.getBBox(),\n                    magnet: view.el\n                });\n            }\n\n            view.$('[magnet]').toArray().forEach(magnet => {\n                candidates.push({\n                    bbox: view.getNodeBBox(magnet),\n                    magnet\n                });\n            });\n\n            candidates.forEach(candidate => {\n                const { magnet, bbox } = candidate;\n                // find distance from the center of the model to pointer coordinates\n                const distance = bbox.center().squaredDistance(pointer);\n                // the connection is looked up in a circle area by `distance < r`\n                if (distance < minDistance) {\n                    const isAlreadyValidated = prevClosestMagnet === magnet;\n                    if (isAlreadyValidated || paper.options.validateConnection.apply(\n                        paper, data.validateConnectionArgs(view, (view.el === magnet) ? null : magnet)\n                    )) {\n                        minDistance = distance;\n                        data.closestView = view;\n                        data.closestMagnet = magnet;\n                    }\n                }\n            });\n\n        }, this);\n\n        var end;\n        var magnetProxy = null;\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestMagnet) {\n            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n        }\n        var endType = data.arrowhead;\n        var newClosestMagnet = (prevClosestMagnet !== closestMagnet);\n        if (prevClosestView && newClosestMagnet) {\n            prevClosestView.unhighlight(prevMagnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n        }\n\n        if (closestView) {\n            const { prevEnd, prevX, prevY } = data;\n            data.prevX = x;\n            data.prevY = y;\n            isSnapped = true;\n\n            if (!newClosestMagnet)  {\n                if (typeof connectionStrategy !== 'function' || (prevX === x && prevY === y)) {\n                    // the magnet has not changed and the link's end does not depend on the x and y\n                    return isSnapped;\n                }\n            }\n\n            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n            if (!newClosestMagnet && isEqual(prevEnd, end)) {\n                // the source/target json has not changed\n                return isSnapped;\n            }\n\n            data.prevEnd = end;\n\n            if (newClosestMagnet) {\n                closestView.highlight(magnetProxy, {\n                    connecting: true,\n                    snapping: true\n                });\n            }\n\n        } else {\n\n            end = { x: x, y: y };\n        }\n\n        this.model.set(endType, end || { x: x, y: y }, { ui: true });\n\n        if (prevClosestView) {\n            this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n        }\n        if (closestView) {\n            this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n        }\n\n        return isSnapped;\n    },\n\n    _snapArrowheadEnd: function(data) {\n\n        // Finish off link snapping.\n        // Everything except view unhighlighting was already done on pointermove.\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestView && closestMagnet) {\n\n            closestView.unhighlight(data.magnetProxy, { connecting: true, snapping: true });\n            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n        }\n\n        data.closestView = data.closestMagnet = null;\n    },\n\n    _connectArrowhead: function(target, x, y, data) {\n\n        // checking views right under the pointer\n        const { paper, model } = this;\n\n        if (data.eventTarget !== target) {\n            // Unhighlight the previous view under pointer if there was one.\n            if (data.magnetProxy) {\n                data.viewUnderPointer.unhighlight(data.magnetProxy, {\n                    connecting: true\n                });\n            }\n\n            const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n            if (viewUnderPointer) {\n                // If we found a view that is under the pointer, we need to find the closest\n                // magnet based on the real target element of the event.\n                const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n                const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n                if (magnetUnderPointer && this.paper.options.validateConnection.apply(\n                    paper,\n                    data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer)\n                )) {\n                    // If there was no magnet found, do not highlight anything and assume there\n                    // is no view under pointer we're interested in reconnecting to.\n                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n                    if (magnetProxy) {\n                        viewUnderPointer.highlight(magnetProxy, {\n                            connecting: true\n                        });\n                    }\n                } else {\n                    // This type of connection is not valid. Disregard this magnet.\n                    data.magnetUnderPointer = null;\n                    data.magnetProxy = null;\n                }\n            } else {\n                // Make sure we'll unset previous magnet.\n                data.magnetUnderPointer = null;\n                data.magnetProxy = null;\n            }\n        }\n\n        data.eventTarget = target;\n\n        model.set(data.arrowhead, { x: x, y: y }, { ui: true });\n    },\n\n    _connectArrowheadEnd: function(data = {}, x, y) {\n\n        const { model } = this;\n        const { viewUnderPointer, magnetUnderPointer, magnetProxy, arrowhead } = data;\n\n        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n\n        viewUnderPointer.unhighlight(magnetProxy, { connecting: true });\n\n        // The link end is taken from the magnet under the pointer, not the proxy.\n        const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n        model.set(arrowhead, end, { ui: true });\n    },\n\n    _beforeArrowheadMove: function(data) {\n\n        data.z = this.model.get('z');\n        this.model.toFront();\n\n        // Let the pointer propagate through the link view elements so that\n        // the `evt.target` is another element under the pointer, not the link itself.\n        var style = this.el.style;\n        data.pointerEvents = style.pointerEvents;\n        style.pointerEvents = 'none';\n\n        if (this.paper.options.markAvailable) {\n            this._markAvailableMagnets(data);\n        }\n    },\n\n    _afterArrowheadMove: function(data) {\n\n        if (data.z !== null) {\n            this.model.set('z', data.z, { ui: true });\n            data.z = null;\n        }\n\n        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n        this.el.style.pointerEvents = data.pointerEvents;\n\n        if (this.paper.options.markAvailable) {\n            this._unmarkAvailableMagnets(data);\n        }\n    },\n\n    _createValidateConnectionArgs: function(arrowhead) {\n        // It makes sure the arguments for validateConnection have the following form:\n        // (source view, source magnet, target view, target magnet and link view)\n        var args = [];\n\n        args[4] = arrowhead;\n        args[5] = this;\n\n        var oppositeArrowhead;\n        var i = 0;\n        var j = 0;\n\n        if (arrowhead === 'source') {\n            i = 2;\n            oppositeArrowhead = 'target';\n        } else {\n            j = 2;\n            oppositeArrowhead = 'source';\n        }\n\n        var end = this.model.get(oppositeArrowhead);\n\n        if (end.id) {\n            var view = args[i] = this.paper.findViewByModel(end.id);\n            var magnet = view.getMagnetFromLinkEnd(end);\n            if (magnet === view.el) magnet = undefined;\n            args[i + 1] = magnet;\n        }\n\n        function validateConnectionArgs(cellView, magnet) {\n            args[j] = cellView;\n            args[j + 1] = cellView.el === magnet ? undefined : magnet;\n            return args;\n        }\n\n        return validateConnectionArgs;\n    },\n\n    _markAvailableMagnets: function(data) {\n\n        function isMagnetAvailable(view, magnet) {\n            var paper = view.paper;\n            var validate = paper.options.validateConnection;\n            return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n        }\n\n        var paper = this.paper;\n        var elements = paper.model.getCells();\n        data.marked = {};\n\n        for (var i = 0, n = elements.length; i < n; i++) {\n            var view = elements[i].findView(paper);\n\n            if (!view) {\n                continue;\n            }\n\n            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n            if (view.el.getAttribute('magnet') !== 'false') {\n                // Element wrapping group is also a magnet\n                magnets.push(view.el);\n            }\n\n            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n            if (availableMagnets.length > 0) {\n                // highlight all available magnets\n                for (var j = 0, m = availableMagnets.length; j < m; j++) {\n                    view.highlight(availableMagnets[j], { magnetAvailability: true });\n                }\n                // highlight the entire view\n                view.highlight(null, { elementAvailability: true });\n\n                data.marked[view.model.id] = availableMagnets;\n            }\n        }\n    },\n\n    _unmarkAvailableMagnets: function(data) {\n\n        var markedKeys = Object.keys(data.marked);\n        var id;\n        var markedMagnets;\n\n        for (var i = 0, n = markedKeys.length; i < n; i++) {\n            id = markedKeys[i];\n            markedMagnets = data.marked[id];\n\n            var view = this.paper.findViewByModel(id);\n            if (view) {\n                for (var j = 0, m = markedMagnets.length; j < m; j++) {\n                    view.unhighlight(markedMagnets[j], { magnetAvailability: true });\n                }\n                view.unhighlight(null, { elementAvailability: true });\n            }\n        }\n\n        data.marked = null;\n    },\n\n    startArrowheadMove: function(end, opt) {\n\n        opt || (opt = {});\n\n        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n        // move without need to click on the actual arrowhead dom element.\n        var data = {\n            action: 'arrowhead-move',\n            arrowhead: end,\n            whenNotAllowed: opt.whenNotAllowed || 'revert',\n            initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n            initialEnd: clone(this.model.get(end)),\n            validateConnectionArgs: this._createValidateConnectionArgs(end)\n        };\n\n        this._beforeArrowheadMove(data);\n\n        if (opt.ignoreBackwardsCompatibility !== true) {\n            this._dragData = data;\n        }\n\n        return data;\n    },\n\n    // Lifecycle methods\n\n    onMount: function() {\n        CellView.prototype.onMount.apply(this, arguments);\n        this.mountLabels();\n    },\n\n    onDetach: function() {\n        CellView.prototype.onDetach.apply(this, arguments);\n        this.unmountLabels();\n    },\n\n    onRemove: function() {\n        CellView.prototype.onRemove.apply(this, arguments);\n        this.unmountLabels();\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var sourceView = this.sourceView;\n        if (!sourceView) {\n            var sourceDef = this.model.source();\n            return new Rect(sourceDef.x, sourceDef.y);\n        }\n        var sourceMagnet = this.sourceMagnet;\n        if (sourceView.isNodeConnection(sourceMagnet)) {\n            return new Rect(this.sourceAnchor);\n        }\n        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n    }\n\n});\n\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var targetView = this.targetView;\n        if (!targetView) {\n            var targetDef = this.model.target();\n            return new Rect(targetDef.x, targetDef.y);\n        }\n        var targetMagnet = this.targetMagnet;\n        if (targetView.isNodeConnection(targetMagnet)) {\n            return new Rect(this.targetAnchor);\n        }\n        return targetView.getNodeBBox(targetMagnet || targetView.el);\n    }\n});\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}