{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isEqual, uniq } from '@antv/util';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot, getDistance } from './utils/data-preprocessing';\nimport Vector from './utils/vector';\nimport { DistanceType } from './types'; // 获取质心\n\nvar getCentroid = function getCentroid(distanceType, allPropertiesWeight, index) {\n  var centroid = [];\n  switch (distanceType) {\n    case DistanceType.EuclideanDistance:\n      centroid = allPropertiesWeight[index];\n      break;\n    default:\n      centroid = [];\n      break;\n  }\n  return centroid;\n};\n/**\n *  k-means算法 根据节点之间的距离将节点聚类为K个簇\n * @param data 图数据\n * @param k 质心（聚类中心）个数\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param distanceType 距离类型 默认节点属性的欧式距离\n */\n\nvar kMeans = function kMeans(data, k, propertyKey, involvedKeys, uninvolvedKeys, distanceType) {\n  if (k === void 0) {\n    k = 3;\n  }\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n  if (distanceType === void 0) {\n    distanceType = DistanceType.EuclideanDistance;\n  }\n  var _a = data.nodes,\n    nodes = _a === void 0 ? [] : _a,\n    _b = data.edges,\n    edges = _b === void 0 ? [] : _b;\n  var defaultClusterInfo = {\n    clusters: [{\n      id: \"0\",\n      nodes: nodes\n    }],\n    clusterEdges: []\n  }; // 距离类型为欧式距离且没有属性时，直接return\n\n  if (distanceType === DistanceType.EuclideanDistance && !nodes.every(function (node) {\n    return node.hasOwnProperty(propertyKey);\n  })) {\n    return defaultClusterInfo;\n  } // 所有节点属性集合\n\n  var properties = []; // 所有节点属性one-hot特征向量集合\n\n  var allPropertiesWeight = [];\n  if (distanceType === DistanceType.EuclideanDistance) {\n    properties = getAllProperties(nodes, propertyKey);\n    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  }\n  if (!allPropertiesWeight.length) {\n    return defaultClusterInfo;\n  }\n  var allPropertiesWeightUniq = uniq(allPropertiesWeight.map(function (item) {\n    return item.join('');\n  })); // 当输入节点数量或者属性集合的长度小于k时，k调整为其中最小的值\n\n  var finalK = Math.min(k, nodes.length, allPropertiesWeightUniq.length); // 记录节点的原始index，与allPropertiesWeight对应\n\n  for (var i = 0; i < nodes.length; i++) {\n    nodes[i].originIndex = i;\n  } // 初始化质心（聚类中心）\n\n  var centroids = [];\n  var centroidIndexList = [];\n  var clusters = [];\n  for (var i = 0; i < finalK; i++) {\n    if (i === 0) {\n      // 随机选取质心（聚类中心）\n      var randomIndex = Math.floor(Math.random() * nodes.length);\n      switch (distanceType) {\n        case DistanceType.EuclideanDistance:\n          centroids[i] = allPropertiesWeight[randomIndex];\n          break;\n        default:\n          centroids[i] = [];\n          break;\n      }\n      centroidIndexList.push(randomIndex);\n      clusters[i] = [nodes[randomIndex]];\n      nodes[randomIndex].clusterId = String(i);\n    } else {\n      var maxDistance = -Infinity;\n      var maxDistanceNodeIndex = 0;\n      var _loop_1 = function _loop_1(m) {\n        if (!centroidIndexList.includes(m)) {\n          var totalDistance = 0;\n          for (var j = 0; j < centroids.length; j++) {\n            // 求节点到质心的距离（默认节点属性的欧式距离）\n            var distance = 0;\n            switch (distanceType) {\n              case DistanceType.EuclideanDistance:\n                distance = getDistance(allPropertiesWeight[nodes[m].originIndex], centroids[j], distanceType);\n                break;\n              default:\n                break;\n            }\n            totalDistance += distance;\n          } // 节点到各质心的平均距离（默认欧式距离）\n\n          var avgDistance = totalDistance / centroids.length; // 记录到已有质心最远的的距离和节点索引\n\n          if (avgDistance > maxDistance && !centroids.find(function (centroid) {\n            return isEqual(centroid, getCentroid(distanceType, allPropertiesWeight, nodes[m].originIndex));\n          })) {\n            maxDistance = avgDistance;\n            maxDistanceNodeIndex = m;\n          }\n        }\n      }; // 选取与已有质心平均距离最远的点做为新的质心\n\n      for (var m = 0; m < nodes.length; m++) {\n        _loop_1(m);\n      }\n      centroids[i] = getCentroid(distanceType, allPropertiesWeight, maxDistanceNodeIndex);\n      centroidIndexList.push(maxDistanceNodeIndex);\n      clusters[i] = [nodes[maxDistanceNodeIndex]];\n      nodes[maxDistanceNodeIndex].clusterId = String(i);\n    }\n  }\n  var iterations = 0;\n  while (true) {\n    for (var i = 0; i < nodes.length; i++) {\n      var minDistanceIndex = 0;\n      var minDistance = Infinity;\n      if (!(iterations === 0 && centroidIndexList.includes(i))) {\n        for (var j = 0; j < centroids.length; j++) {\n          // 求节点到质心的距离（默认节点属性的欧式距离）\n          var distance = 0;\n          switch (distanceType) {\n            case DistanceType.EuclideanDistance:\n              distance = getDistance(allPropertiesWeight[i], centroids[j], distanceType);\n              break;\n            default:\n              break;\n          } // 记录节点最近的质心的索引\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            minDistanceIndex = j;\n          }\n        } // 从原来的类别删除节点\n\n        if (nodes[i].clusterId !== undefined) {\n          for (var n = clusters[Number(nodes[i].clusterId)].length - 1; n >= 0; n--) {\n            if (clusters[Number(nodes[i].clusterId)][n].id === nodes[i].id) {\n              clusters[Number(nodes[i].clusterId)].splice(n, 1);\n            }\n          }\n        } // 将节点划分到距离最小的质心（聚类中心）所对应的类中\n\n        nodes[i].clusterId = String(minDistanceIndex);\n        clusters[minDistanceIndex].push(nodes[i]);\n      }\n    } // 是否存在质心（聚类中心）移动\n\n    var centroidsEqualAvg = false;\n    for (var i = 0; i < clusters.length; i++) {\n      var clusterNodes = clusters[i];\n      var totalVector = new Vector([]);\n      for (var j = 0; j < clusterNodes.length; j++) {\n        totalVector = totalVector.add(new Vector(allPropertiesWeight[clusterNodes[j].originIndex]));\n      } // 计算每个类别的均值向量\n\n      var avgVector = totalVector.avg(clusterNodes.length); // 如果均值向量不等于质心向量\n\n      if (!avgVector.equal(new Vector(centroids[i]))) {\n        centroidsEqualAvg = true; // 移动/更新每个类别的质心（聚类中心）到该均值向量\n\n        centroids[i] = avgVector.getArr();\n      }\n    }\n    iterations++; // 如果每个节点都归属了类别，且不存在质心（聚类中心）移动或者迭代次数超过1000，则停止\n\n    if (nodes.every(function (node) {\n      return node.clusterId !== undefined;\n    }) && centroidsEqualAvg || iterations >= 1000) {\n      break;\n    }\n  } // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var _a, _b;\n    var source = edge.source,\n      target = edge.target;\n    var sourceClusterId = (_a = nodes.find(function (node) {\n      return node.id === source;\n    })) === null || _a === void 0 ? void 0 : _a.clusterId;\n    var targetClusterId = (_b = nodes.find(function (node) {\n      return node.id === target;\n    })) === null || _b === void 0 ? void 0 : _b.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  return {\n    clusters: clusters,\n    clusterEdges: clusterEdges\n  };\n};\nexport default kMeans;","map":{"version":3,"names":["isEqual","uniq","getAllProperties","oneHot","getDistance","Vector","DistanceType","getCentroid","distanceType","allPropertiesWeight","index","centroid","EuclideanDistance","kMeans","data","k","propertyKey","involvedKeys","uninvolvedKeys","undefined","_a","nodes","_b","edges","defaultClusterInfo","clusters","id","clusterEdges","every","node","hasOwnProperty","properties","length","allPropertiesWeightUniq","map","item","join","finalK","Math","min","i","originIndex","centroids","centroidIndexList","randomIndex","floor","random","push","clusterId","String","maxDistance","Infinity","maxDistanceNodeIndex","_loop_1","m","includes","totalDistance","j","distance","avgDistance","find","iterations","minDistanceIndex","minDistance","n","Number","splice","centroidsEqualAvg","clusterNodes","totalVector","add","avgVector","avg","equal","getArr","clusterEdgeMap","forEach","edge","source","target","sourceClusterId","targetClusterId","newEdgeId","concat","count","newEdge"],"sources":["/Users/lijiaxin/Documents/workspace/hydsoft-oms-frontend/node_modules/@antv/algorithm/es/k-means.js"],"sourcesContent":["import { isEqual, uniq } from '@antv/util';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot, getDistance } from './utils/data-preprocessing';\nimport Vector from './utils/vector';\nimport { DistanceType } from './types'; // 获取质心\n\nvar getCentroid = function getCentroid(distanceType, allPropertiesWeight, index) {\n  var centroid = [];\n\n  switch (distanceType) {\n    case DistanceType.EuclideanDistance:\n      centroid = allPropertiesWeight[index];\n      break;\n\n    default:\n      centroid = [];\n      break;\n  }\n\n  return centroid;\n};\n/**\n *  k-means算法 根据节点之间的距离将节点聚类为K个簇\n * @param data 图数据\n * @param k 质心（聚类中心）个数\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param distanceType 距离类型 默认节点属性的欧式距离\n */\n\n\nvar kMeans = function kMeans(data, k, propertyKey, involvedKeys, uninvolvedKeys, distanceType) {\n  if (k === void 0) {\n    k = 3;\n  }\n\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n\n  if (distanceType === void 0) {\n    distanceType = DistanceType.EuclideanDistance;\n  }\n\n  var _a = data.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = data.edges,\n      edges = _b === void 0 ? [] : _b;\n  var defaultClusterInfo = {\n    clusters: [{\n      id: \"0\",\n      nodes: nodes\n    }],\n    clusterEdges: []\n  }; // 距离类型为欧式距离且没有属性时，直接return\n\n  if (distanceType === DistanceType.EuclideanDistance && !nodes.every(function (node) {\n    return node.hasOwnProperty(propertyKey);\n  })) {\n    return defaultClusterInfo;\n  } // 所有节点属性集合\n\n\n  var properties = []; // 所有节点属性one-hot特征向量集合\n\n  var allPropertiesWeight = [];\n\n  if (distanceType === DistanceType.EuclideanDistance) {\n    properties = getAllProperties(nodes, propertyKey);\n    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  }\n\n  if (!allPropertiesWeight.length) {\n    return defaultClusterInfo;\n  }\n\n  var allPropertiesWeightUniq = uniq(allPropertiesWeight.map(function (item) {\n    return item.join('');\n  })); // 当输入节点数量或者属性集合的长度小于k时，k调整为其中最小的值\n\n  var finalK = Math.min(k, nodes.length, allPropertiesWeightUniq.length); // 记录节点的原始index，与allPropertiesWeight对应\n\n  for (var i = 0; i < nodes.length; i++) {\n    nodes[i].originIndex = i;\n  } // 初始化质心（聚类中心）\n\n\n  var centroids = [];\n  var centroidIndexList = [];\n  var clusters = [];\n\n  for (var i = 0; i < finalK; i++) {\n    if (i === 0) {\n      // 随机选取质心（聚类中心）\n      var randomIndex = Math.floor(Math.random() * nodes.length);\n\n      switch (distanceType) {\n        case DistanceType.EuclideanDistance:\n          centroids[i] = allPropertiesWeight[randomIndex];\n          break;\n\n        default:\n          centroids[i] = [];\n          break;\n      }\n\n      centroidIndexList.push(randomIndex);\n      clusters[i] = [nodes[randomIndex]];\n      nodes[randomIndex].clusterId = String(i);\n    } else {\n      var maxDistance = -Infinity;\n      var maxDistanceNodeIndex = 0;\n\n      var _loop_1 = function _loop_1(m) {\n        if (!centroidIndexList.includes(m)) {\n          var totalDistance = 0;\n\n          for (var j = 0; j < centroids.length; j++) {\n            // 求节点到质心的距离（默认节点属性的欧式距离）\n            var distance = 0;\n\n            switch (distanceType) {\n              case DistanceType.EuclideanDistance:\n                distance = getDistance(allPropertiesWeight[nodes[m].originIndex], centroids[j], distanceType);\n                break;\n\n              default:\n                break;\n            }\n\n            totalDistance += distance;\n          } // 节点到各质心的平均距离（默认欧式距离）\n\n\n          var avgDistance = totalDistance / centroids.length; // 记录到已有质心最远的的距离和节点索引\n\n          if (avgDistance > maxDistance && !centroids.find(function (centroid) {\n            return isEqual(centroid, getCentroid(distanceType, allPropertiesWeight, nodes[m].originIndex));\n          })) {\n            maxDistance = avgDistance;\n            maxDistanceNodeIndex = m;\n          }\n        }\n      }; // 选取与已有质心平均距离最远的点做为新的质心\n\n\n      for (var m = 0; m < nodes.length; m++) {\n        _loop_1(m);\n      }\n\n      centroids[i] = getCentroid(distanceType, allPropertiesWeight, maxDistanceNodeIndex);\n      centroidIndexList.push(maxDistanceNodeIndex);\n      clusters[i] = [nodes[maxDistanceNodeIndex]];\n      nodes[maxDistanceNodeIndex].clusterId = String(i);\n    }\n  }\n\n  var iterations = 0;\n\n  while (true) {\n    for (var i = 0; i < nodes.length; i++) {\n      var minDistanceIndex = 0;\n      var minDistance = Infinity;\n\n      if (!(iterations === 0 && centroidIndexList.includes(i))) {\n        for (var j = 0; j < centroids.length; j++) {\n          // 求节点到质心的距离（默认节点属性的欧式距离）\n          var distance = 0;\n\n          switch (distanceType) {\n            case DistanceType.EuclideanDistance:\n              distance = getDistance(allPropertiesWeight[i], centroids[j], distanceType);\n              break;\n\n            default:\n              break;\n          } // 记录节点最近的质心的索引\n\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            minDistanceIndex = j;\n          }\n        } // 从原来的类别删除节点\n\n\n        if (nodes[i].clusterId !== undefined) {\n          for (var n = clusters[Number(nodes[i].clusterId)].length - 1; n >= 0; n--) {\n            if (clusters[Number(nodes[i].clusterId)][n].id === nodes[i].id) {\n              clusters[Number(nodes[i].clusterId)].splice(n, 1);\n            }\n          }\n        } // 将节点划分到距离最小的质心（聚类中心）所对应的类中\n\n\n        nodes[i].clusterId = String(minDistanceIndex);\n        clusters[minDistanceIndex].push(nodes[i]);\n      }\n    } // 是否存在质心（聚类中心）移动\n\n\n    var centroidsEqualAvg = false;\n\n    for (var i = 0; i < clusters.length; i++) {\n      var clusterNodes = clusters[i];\n      var totalVector = new Vector([]);\n\n      for (var j = 0; j < clusterNodes.length; j++) {\n        totalVector = totalVector.add(new Vector(allPropertiesWeight[clusterNodes[j].originIndex]));\n      } // 计算每个类别的均值向量\n\n\n      var avgVector = totalVector.avg(clusterNodes.length); // 如果均值向量不等于质心向量\n\n      if (!avgVector.equal(new Vector(centroids[i]))) {\n        centroidsEqualAvg = true; // 移动/更新每个类别的质心（聚类中心）到该均值向量\n\n        centroids[i] = avgVector.getArr();\n      }\n    }\n\n    iterations++; // 如果每个节点都归属了类别，且不存在质心（聚类中心）移动或者迭代次数超过1000，则停止\n\n    if (nodes.every(function (node) {\n      return node.clusterId !== undefined;\n    }) && centroidsEqualAvg || iterations >= 1000) {\n      break;\n    }\n  } // get the cluster edges\n\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var _a, _b;\n\n    var source = edge.source,\n        target = edge.target;\n    var sourceClusterId = (_a = nodes.find(function (node) {\n      return node.id === source;\n    })) === null || _a === void 0 ? void 0 : _a.clusterId;\n    var targetClusterId = (_b = nodes.find(function (node) {\n      return node.id === target;\n    })) === null || _b === void 0 ? void 0 : _b.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  return {\n    clusters: clusters,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default kMeans;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}