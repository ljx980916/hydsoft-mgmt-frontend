{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport * as util from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { Rect, Point } from '../g/index.mjs';\nimport * as Port from '../layout/ports/port.mjs';\nimport * as PortLabel from '../layout/ports/portLabel.mjs';\nvar PortData = function (data) {\n  var clonedData = util.cloneDeep(data) || {};\n  this.ports = [];\n  this.groups = {};\n  this.portLayoutNamespace = Port;\n  this.portLabelLayoutNamespace = PortLabel;\n  this._init(clonedData);\n};\nPortData.prototype = {\n  getPorts: function () {\n    return this.ports;\n  },\n  getGroup: function (name) {\n    return this.groups[name] || {};\n  },\n  getPortsByGroup: function (groupName) {\n    return this.ports.filter(function (port) {\n      return port.group === groupName;\n    });\n  },\n  getGroupPortsMetrics: function (groupName, elBBox) {\n    var group = this.getGroup(groupName);\n    var ports = this.getPortsByGroup(groupName);\n    var groupPosition = group.position || {};\n    var groupPositionName = groupPosition.name;\n    var namespace = this.portLayoutNamespace;\n    if (!namespace[groupPositionName]) {\n      groupPositionName = 'left';\n    }\n    var groupArgs = groupPosition.args || {};\n    var portsArgs = ports.map(function (port) {\n      return port && port.position && port.position.args;\n    });\n    var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);\n    var accumulator = {\n      ports: ports,\n      result: []\n    };\n    util.toArray(groupPortTransformations).reduce(function (res, portTransformation, index) {\n      var port = res.ports[index];\n      res.result.push({\n        portId: port.id,\n        portTransformation: portTransformation,\n        labelTransformation: this._getPortLabelLayout(port, Point(portTransformation), elBBox),\n        portAttrs: port.attrs,\n        portSize: port.size,\n        labelSize: port.label.size\n      });\n      return res;\n    }.bind(this), accumulator);\n    return accumulator.result;\n  },\n  _getPortLabelLayout: function (port, portPosition, elBBox) {\n    var namespace = this.portLabelLayoutNamespace;\n    var labelPosition = port.label.position.name || 'left';\n    if (namespace[labelPosition]) {\n      return namespace[labelPosition](portPosition, elBBox, port.label.position.args);\n    }\n    return null;\n  },\n  _init: function (data) {\n    // prepare groups\n    if (util.isObject(data.groups)) {\n      var groups = Object.keys(data.groups);\n      for (var i = 0, n = groups.length; i < n; i++) {\n        var key = groups[i];\n        this.groups[key] = this._evaluateGroup(data.groups[key]);\n      }\n    }\n\n    // prepare ports\n    var ports = util.toArray(data.items);\n    for (var j = 0, m = ports.length; j < m; j++) {\n      this.ports.push(this._evaluatePort(ports[j]));\n    }\n  },\n  _evaluateGroup: function (group) {\n    return util.merge(group, {\n      position: this._getPosition(group.position, true),\n      label: this._getLabel(group, true)\n    });\n  },\n  _evaluatePort: function (port) {\n    var evaluated = util.assign({}, port);\n    var group = this.getGroup(port.group);\n    evaluated.markup = evaluated.markup || group.markup;\n    evaluated.attrs = util.merge({}, group.attrs, evaluated.attrs);\n    evaluated.position = this._createPositionNode(group, evaluated);\n    evaluated.label = util.merge({}, group.label, this._getLabel(evaluated));\n    evaluated.z = this._getZIndex(group, evaluated);\n    evaluated.size = util.assign({}, group.size, evaluated.size);\n    return evaluated;\n  },\n  _getZIndex: function (group, port) {\n    if (util.isNumber(port.z)) {\n      return port.z;\n    }\n    if (util.isNumber(group.z) || group.z === 'auto') {\n      return group.z;\n    }\n    return 'auto';\n  },\n  _createPositionNode: function (group, port) {\n    return util.merge({\n      name: 'left',\n      args: {}\n    }, group.position, {\n      args: port.args\n    });\n  },\n  _getPosition: function (position, setDefault) {\n    var args = {};\n    var positionName;\n    if (util.isFunction(position)) {\n      positionName = 'fn';\n      args.fn = position;\n    } else if (util.isString(position)) {\n      positionName = position;\n    } else if (position === undefined) {\n      positionName = setDefault ? 'left' : null;\n    } else if (Array.isArray(position)) {\n      positionName = 'absolute';\n      args.x = position[0];\n      args.y = position[1];\n    } else if (util.isObject(position)) {\n      positionName = position.name;\n      util.assign(args, position.args);\n    }\n    var result = {\n      args: args\n    };\n    if (positionName) {\n      result.name = positionName;\n    }\n    return result;\n  },\n  _getLabel: function (item, setDefaults) {\n    var label = item.label || {};\n    var ret = label;\n    ret.position = this._getPosition(label.position, setDefaults);\n    return ret;\n  }\n};\nexport const elementPortPrototype = {\n  _initializePorts: function () {\n    this._createPortData();\n    this.on('change:ports', function () {\n      this._processRemovedPort();\n      this._createPortData();\n    }, this);\n  },\n  /**\n   * remove links tied wiht just removed element\n   * @private\n   */\n  _processRemovedPort: function () {\n    var current = this.get('ports') || {};\n    var currentItemsMap = {};\n    util.toArray(current.items).forEach(function (item) {\n      currentItemsMap[item.id] = true;\n    });\n    var previous = this.previous('ports') || {};\n    var removed = {};\n    util.toArray(previous.items).forEach(function (item) {\n      if (!currentItemsMap[item.id]) {\n        removed[item.id] = true;\n      }\n    });\n    var graph = this.graph;\n    if (graph && !util.isEmpty(removed)) {\n      var inboundLinks = graph.getConnectedLinks(this, {\n        inbound: true\n      });\n      inboundLinks.forEach(function (link) {\n        if (removed[link.get('target').port]) link.remove();\n      });\n      var outboundLinks = graph.getConnectedLinks(this, {\n        outbound: true\n      });\n      outboundLinks.forEach(function (link) {\n        if (removed[link.get('source').port]) link.remove();\n      });\n    }\n  },\n  /**\n   * @returns {boolean}\n   */\n  hasPorts: function () {\n    var ports = this.prop('ports/items');\n    return Array.isArray(ports) && ports.length > 0;\n  },\n  /**\n   * @param {string} id\n   * @returns {boolean}\n   */\n  hasPort: function (id) {\n    return this.getPortIndex(id) !== -1;\n  },\n  /**\n   * @returns {Array<object>}\n   */\n  getPorts: function () {\n    return util.cloneDeep(this.prop('ports/items')) || [];\n  },\n  /**\n   * @returns {Array<object>}\n   */\n  getGroupPorts: function (groupName) {\n    const groupPorts = util.toArray(this.prop(['ports', 'items'])).filter(port => port.group === groupName);\n    return util.cloneDeep(groupPorts);\n  },\n  /**\n   * @param {string} id\n   * @returns {object}\n   */\n  getPort: function (id) {\n    return util.cloneDeep(util.toArray(this.prop('ports/items')).find(function (port) {\n      return port.id && port.id === id;\n    }));\n  },\n  /**\n   * @param {string} groupName\n   * @returns {Object<portId, {x: number, y: number, angle: number}>}\n   */\n  getPortsPositions: function (groupName) {\n    var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, Rect(this.size()));\n    return portsMetrics.reduce(function (positions, metrics) {\n      var transformation = metrics.portTransformation;\n      positions[metrics.portId] = {\n        x: transformation.x,\n        y: transformation.y,\n        angle: transformation.angle\n      };\n      return positions;\n    }, {});\n  },\n  /**\n   * @param {string|Port} port port id or port\n   * @returns {number} port index\n   */\n  getPortIndex: function (port) {\n    var id = util.isObject(port) ? port.id : port;\n    if (!this._isValidPortId(id)) {\n      return -1;\n    }\n    return util.toArray(this.prop('ports/items')).findIndex(function (item) {\n      return item.id === id;\n    });\n  },\n  /**\n   * @param {object} port\n   * @param {object} [opt]\n   * @returns {joint.dia.Element}\n   */\n  addPort: function (port, opt) {\n    if (!util.isObject(port) || Array.isArray(port)) {\n      throw new Error('Element: addPort requires an object.');\n    }\n    var ports = util.assign([], this.prop('ports/items'));\n    ports.push(port);\n    this.prop('ports/items', ports, opt);\n    return this;\n  },\n  /**\n   * @param {string|Port|number} before\n   * @param {object} port\n   * @param {object} [opt]\n   * @returns {joint.dia.Element}\n   */\n  insertPort: function (before, port, opt) {\n    const index = typeof before === 'number' ? before : this.getPortIndex(before);\n    if (!util.isObject(port) || Array.isArray(port)) {\n      throw new Error('dia.Element: insertPort requires an object.');\n    }\n    const ports = util.assign([], this.prop('ports/items'));\n    ports.splice(index, 0, port);\n    this.prop('ports/items', ports, opt);\n    return this;\n  },\n  /**\n   * @param {string} portId\n   * @param {string|object=} path\n   * @param {*=} value\n   * @param {object=} opt\n   * @returns {joint.dia.Element}\n   */\n  portProp: function (portId, path, value, opt) {\n    var index = this.getPortIndex(portId);\n    if (index === -1) {\n      throw new Error('Element: unable to find port with id ' + portId);\n    }\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (Array.isArray(path)) {\n      args[0] = ['ports', 'items', index].concat(path);\n    } else if (util.isString(path)) {\n      // Get/set an attribute by a special path syntax that delimits\n      // nested objects by the colon character.\n      args[0] = ['ports/items/', index, '/', path].join('');\n    } else {\n      args = ['ports/items/' + index];\n      if (util.isPlainObject(path)) {\n        args.push(path);\n        args.push(value);\n      }\n    }\n    return this.prop.apply(this, args);\n  },\n  _validatePorts: function () {\n    var portsAttr = this.get('ports') || {};\n    var errorMessages = [];\n    portsAttr = portsAttr || {};\n    var ports = util.toArray(portsAttr.items);\n    ports.forEach(function (p) {\n      if (typeof p !== 'object') {\n        errorMessages.push('Element: invalid port ', p);\n      }\n      if (!this._isValidPortId(p.id)) {\n        p.id = this.generatePortId();\n      }\n    }, this);\n    if (util.uniq(ports, 'id').length !== ports.length) {\n      errorMessages.push('Element: found id duplicities in ports.');\n    }\n    return errorMessages;\n  },\n  generatePortId: function () {\n    return this.generateId();\n  },\n  /**\n   * @param {string} id port id\n   * @returns {boolean}\n   * @private\n   */\n  _isValidPortId: function (id) {\n    return id !== null && id !== undefined && !util.isObject(id);\n  },\n  addPorts: function (ports, opt) {\n    if (ports.length) {\n      this.prop('ports/items', util.assign([], this.prop('ports/items')).concat(ports), opt);\n    }\n    return this;\n  },\n  removePort: function (port, opt) {\n    const options = opt || {};\n    const index = this.getPortIndex(port);\n    if (index !== -1) {\n      const ports = util.assign([], this.prop(['ports', 'items']));\n      ports.splice(index, 1);\n      options.rewrite = true;\n      this.startBatch('port-remove');\n      this.prop(['ports', 'items'], ports, options);\n      this.stopBatch('port-remove');\n    }\n    return this;\n  },\n  removePorts: function (portsForRemoval, opt) {\n    let options, newPorts;\n    if (Array.isArray(portsForRemoval)) {\n      options = opt || {};\n      if (portsForRemoval.length === 0) return this.this;\n      const currentPorts = util.assign([], this.prop(['ports', 'items']));\n      newPorts = currentPorts.filter(function (cp) {\n        return !portsForRemoval.some(function (rp) {\n          const rpId = util.isObject(rp) ? rp.id : rp;\n          return cp.id === rpId;\n        });\n      });\n    } else {\n      options = portsForRemoval || {};\n      newPorts = [];\n    }\n    this.startBatch('port-remove');\n    options.rewrite = true;\n    this.prop(['ports', 'items'], newPorts, options);\n    this.stopBatch('port-remove');\n    return this;\n  },\n  /**\n   * @private\n   */\n  _createPortData: function () {\n    var err = this._validatePorts();\n    if (err.length > 0) {\n      this.set('ports', this.previous('ports'));\n      throw new Error(err.join(' '));\n    }\n    var prevPortData;\n    if (this._portSettingsData) {\n      prevPortData = this._portSettingsData.getPorts();\n    }\n    this._portSettingsData = new PortData(this.get('ports'));\n    var curPortData = this._portSettingsData.getPorts();\n    if (prevPortData) {\n      var added = curPortData.filter(function (item) {\n        if (!prevPortData.find(function (prevPort) {\n          return prevPort.id === item.id;\n        })) {\n          return item;\n        }\n      });\n      var removed = prevPortData.filter(function (item) {\n        if (!curPortData.find(function (curPort) {\n          return curPort.id === item.id;\n        })) {\n          return item;\n        }\n      });\n      if (removed.length > 0) {\n        this.trigger('ports:remove', this, removed);\n      }\n      if (added.length > 0) {\n        this.trigger('ports:add', this, added);\n      }\n    }\n  }\n};\nexport const elementViewPortPrototype = {\n  portContainerMarkup: 'g',\n  portMarkup: [{\n    tagName: 'circle',\n    selector: 'circle',\n    attributes: {\n      'r': 10,\n      'fill': '#FFFFFF',\n      'stroke': '#000000'\n    }\n  }],\n  portLabelMarkup: [{\n    tagName: 'text',\n    selector: 'text',\n    attributes: {\n      'fill': '#000000'\n    }\n  }],\n  /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */\n  _portElementsCache: null,\n  /**\n   * @private\n   */\n  _initializePorts: function () {\n    this._cleanPortsCache();\n  },\n  /**\n   * @typedef {Object} Port\n   *\n   * @property {string} id\n   * @property {Object} position\n   * @property {Object} label\n   * @property {Object} attrs\n   * @property {string} markup\n   * @property {string} group\n   */\n\n  /**\n   * @private\n   */\n  _refreshPorts: function () {\n    this._removePorts();\n    this._cleanPortsCache();\n    this._renderPorts();\n  },\n  _cleanPortsCache: function () {\n    this._portElementsCache = {};\n  },\n  /**\n   * @private\n   */\n  _renderPorts: function () {\n    // references to rendered elements without z-index\n    var elementReferences = [];\n    var elem = this._getContainerElement();\n    for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {\n      elementReferences.push(elem.node.childNodes[i]);\n    }\n    var portsGropsByZ = util.groupBy(this.model._portSettingsData.getPorts(), 'z');\n    var withoutZKey = 'auto';\n\n    // render non-z first\n    util.toArray(portsGropsByZ[withoutZKey]).forEach(function (port) {\n      var portElement = this._getPortElement(port);\n      elem.append(portElement);\n      elementReferences.push(portElement);\n    }, this);\n    var groupNames = Object.keys(portsGropsByZ);\n    for (var k = 0; k < groupNames.length; k++) {\n      var groupName = groupNames[k];\n      if (groupName !== withoutZKey) {\n        var z = parseInt(groupName, 10);\n        this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n      }\n    }\n    this._updatePorts();\n  },\n  /**\n   * @returns {V}\n   * @private\n   */\n  _getContainerElement: function () {\n    return this.rotatableNode || this.vel;\n  },\n  /**\n   * @param {Array<Port>}ports\n   * @param {number} z\n   * @param refs\n   * @private\n   */\n  _appendPorts: function (ports, z, refs) {\n    var containerElement = this._getContainerElement();\n    var portElements = util.toArray(ports).map(this._getPortElement, this);\n    if (refs[z] || z < 0) {\n      V(refs[Math.max(z, 0)]).before(portElements);\n    } else {\n      containerElement.append(portElements);\n    }\n  },\n  /**\n   * Try to get element from cache,\n   * @param port\n   * @returns {*}\n   * @private\n   */\n  _getPortElement: function (port) {\n    if (this._portElementsCache[port.id]) {\n      return this._portElementsCache[port.id].portElement;\n    }\n    return this._createPortElement(port);\n  },\n  findPortNode: function (portId, selector) {\n    const portCache = this._portElementsCache[portId];\n    if (!portCache) return null;\n    if (!selector) return portCache.portContentElement.node;\n    const portRoot = portCache.portElement.node;\n    const portSelectors = portCache.portSelectors;\n    const [node = null] = this.findBySelector(selector, portRoot, portSelectors);\n    return node;\n  },\n  /**\n   * @private\n   */\n  _updatePorts: function () {\n    // layout ports without group\n    this._updatePortGroup(undefined);\n    // layout ports with explicit group\n    var groupsNames = Object.keys(this.model._portSettingsData.groups);\n    groupsNames.forEach(this._updatePortGroup, this);\n  },\n  /**\n   * @private\n   */\n  _removePorts: function () {\n    util.invoke(this._portElementsCache, 'portElement.remove');\n  },\n  /**\n   * @param {Port} port\n   * @returns {V}\n   * @private\n   */\n  _createPortElement: function (port) {\n    let portElement;\n    let labelElement;\n    let labelSelectors;\n    let portSelectors;\n    var portContainerElement = V(this.portContainerMarkup).addClass('joint-port');\n    var portMarkup = this._getPortMarkup(port);\n    if (Array.isArray(portMarkup)) {\n      var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n      var portFragment = portDoc.fragment;\n      if (portFragment.childNodes.length > 1) {\n        portElement = V('g').append(portFragment);\n      } else {\n        portElement = V(portFragment.firstChild);\n      }\n      portSelectors = portDoc.selectors;\n    } else {\n      portElement = V(portMarkup);\n      if (Array.isArray(portElement)) {\n        portElement = V('g').append(portElement);\n      }\n    }\n    if (!portElement) {\n      throw new Error('ElementView: Invalid port markup.');\n    }\n    portElement.attr({\n      'port': port.id,\n      'port-group': port.group\n    });\n    const labelMarkupDef = this._getPortLabelMarkup(port.label);\n    if (Array.isArray(labelMarkupDef)) {\n      // JSON Markup\n      const {\n        fragment,\n        selectors\n      } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);\n      const childCount = fragment.childNodes.length;\n      if (childCount > 0) {\n        labelSelectors = selectors;\n        labelElement = childCount === 1 ? V(fragment.firstChild) : V('g').append(fragment);\n      }\n    } else {\n      // String Markup\n      labelElement = V(labelMarkupDef);\n      if (Array.isArray(labelElement)) {\n        labelElement = V('g').append(labelElement);\n      }\n    }\n    var portContainerSelectors;\n    if (portSelectors && labelSelectors) {\n      for (var key in labelSelectors) {\n        if (portSelectors[key] && key !== this.selector) throw new Error('ElementView: selectors within port must be unique.');\n      }\n      portContainerSelectors = util.assign({}, portSelectors, labelSelectors);\n    } else {\n      portContainerSelectors = portSelectors || labelSelectors || {};\n    }\n\n    // The `portRootSelector` points to the root SVGNode of the port.\n    // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.\n    // Or the single SVGNode of the port.\n    const portRootSelector = 'portRoot';\n    // The `labelRootSelector` points to the root SVGNode of the label.\n    const labelRootSelector = 'labelRoot';\n    // The `labelTextSelector` points to all text SVGNodes of the label.\n    const labelTextSelector = 'labelText';\n    if (!(portRootSelector in portContainerSelectors)) {\n      portContainerSelectors[portRootSelector] = portElement.node;\n    }\n    if (labelElement) {\n      const labelNode = labelElement.node;\n      if (!(labelRootSelector in portContainerSelectors)) {\n        portContainerSelectors[labelRootSelector] = labelNode;\n      }\n      if (!(labelTextSelector in portContainerSelectors)) {\n        // If the label is a <text> element, we can use it directly.\n        // Otherwise, we need to find the <text> element within the label.\n        const labelTextNode = labelElement.tagName() === 'TEXT' ? labelNode : Array.from(labelNode.querySelectorAll('text'));\n        portContainerSelectors[labelTextSelector] = labelTextNode;\n        if (!labelSelectors) labelSelectors = {};\n        labelSelectors[labelTextSelector] = labelTextNode;\n      }\n    }\n    portContainerElement.append(portElement.addClass('joint-port-body'));\n    if (labelElement) {\n      portContainerElement.append(labelElement.addClass('joint-port-label'));\n    }\n    this._portElementsCache[port.id] = {\n      portElement: portContainerElement,\n      portLabelElement: labelElement,\n      portSelectors: portContainerSelectors,\n      portLabelSelectors: labelSelectors,\n      portContentElement: portElement,\n      portContentSelectors: portSelectors\n    };\n    return portContainerElement;\n  },\n  /**\n   * @param {string=} groupName\n   * @private\n   */\n  _updatePortGroup: function (groupName) {\n    var elementBBox = Rect(this.model.size());\n    var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);\n    for (var i = 0, n = portsMetrics.length; i < n; i++) {\n      var metrics = portsMetrics[i];\n      var portId = metrics.portId;\n      var cached = this._portElementsCache[portId] || {};\n      var portTransformation = metrics.portTransformation;\n      var labelTransformation = metrics.labelTransformation;\n      if (labelTransformation && cached.portLabelElement) {\n        this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n          rootBBox: new Rect(metrics.labelSize),\n          selectors: cached.portLabelSelectors\n        });\n        this.applyPortTransform(cached.portLabelElement, labelTransformation, -portTransformation.angle || 0);\n      }\n      this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n        rootBBox: new Rect(metrics.portSize),\n        selectors: cached.portSelectors\n      });\n      this.applyPortTransform(cached.portElement, portTransformation);\n    }\n  },\n  /**\n   * @param {Vectorizer} element\n   * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n   * @param {number=} initialAngle\n   * @constructor\n   */\n  applyPortTransform: function (element, transformData, initialAngle) {\n    var matrix = V.createSVGMatrix().rotate(initialAngle || 0).translate(transformData.x || 0, transformData.y || 0).rotate(transformData.angle || 0);\n    element.transform(matrix, {\n      absolute: true\n    });\n  },\n  /**\n   * @param {Port} port\n   * @returns {string}\n   * @private\n   */\n  _getPortMarkup: function (port) {\n    return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;\n  },\n  /**\n   * @param {Object} label\n   * @returns {string}\n   * @private\n   */\n  _getPortLabelMarkup: function (label) {\n    return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;\n  }\n};","map":{"version":3,"names":["util","V","Rect","Point","Port","PortLabel","PortData","data","clonedData","cloneDeep","ports","groups","portLayoutNamespace","portLabelLayoutNamespace","_init","prototype","getPorts","getGroup","name","getPortsByGroup","groupName","filter","port","group","getGroupPortsMetrics","elBBox","groupPosition","position","groupPositionName","namespace","groupArgs","args","portsArgs","map","groupPortTransformations","accumulator","result","toArray","reduce","res","portTransformation","index","push","portId","id","labelTransformation","_getPortLabelLayout","portAttrs","attrs","portSize","size","labelSize","label","bind","portPosition","labelPosition","isObject","Object","keys","i","n","length","key","_evaluateGroup","items","j","m","_evaluatePort","merge","_getPosition","_getLabel","evaluated","assign","markup","_createPositionNode","z","_getZIndex","isNumber","setDefault","positionName","isFunction","fn","isString","undefined","Array","isArray","x","y","item","setDefaults","ret","elementPortPrototype","_initializePorts","_createPortData","on","_processRemovedPort","current","get","currentItemsMap","forEach","previous","removed","graph","isEmpty","inboundLinks","getConnectedLinks","inbound","link","remove","outboundLinks","outbound","hasPorts","prop","hasPort","getPortIndex","getGroupPorts","groupPorts","getPort","find","getPortsPositions","portsMetrics","_portSettingsData","positions","metrics","transformation","angle","_isValidPortId","findIndex","addPort","opt","Error","insertPort","before","splice","portProp","path","value","slice","call","arguments","concat","join","isPlainObject","apply","_validatePorts","portsAttr","errorMessages","p","generatePortId","uniq","generateId","addPorts","removePort","options","rewrite","startBatch","stopBatch","removePorts","portsForRemoval","newPorts","this","currentPorts","cp","some","rp","rpId","err","set","prevPortData","curPortData","added","prevPort","curPort","trigger","elementViewPortPrototype","portContainerMarkup","portMarkup","tagName","selector","attributes","portLabelMarkup","_portElementsCache","_cleanPortsCache","_refreshPorts","_removePorts","_renderPorts","elementReferences","elem","_getContainerElement","count","node","childNodes","portsGropsByZ","groupBy","model","withoutZKey","portElement","_getPortElement","append","groupNames","k","parseInt","_appendPorts","_updatePorts","rotatableNode","vel","refs","containerElement","portElements","Math","max","_createPortElement","findPortNode","portCache","portContentElement","portRoot","portSelectors","findBySelector","_updatePortGroup","groupsNames","invoke","labelElement","labelSelectors","portContainerElement","addClass","_getPortMarkup","portDoc","parseDOMJSON","portFragment","fragment","firstChild","selectors","attr","labelMarkupDef","_getPortLabelMarkup","childCount","portContainerSelectors","portRootSelector","labelRootSelector","labelTextSelector","labelNode","labelTextNode","from","querySelectorAll","portLabelElement","portLabelSelectors","portContentSelectors","elementBBox","cached","updateDOMSubtreeAttributes","rootBBox","applyPortTransform","element","transformData","initialAngle","matrix","createSVGMatrix","rotate","translate","transform","absolute"],"sources":["/Users/lijiaxin/Documents/workspace/hydsoft-mgmt-frontend/node_modules/jointjs/src/dia/ports.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { Rect, Point } from '../g/index.mjs';\nimport * as Port from '../layout/ports/port.mjs';\nimport * as PortLabel from '../layout/ports/portLabel.mjs';\n\nvar PortData = function(data) {\n\n    var clonedData = util.cloneDeep(data) || {};\n    this.ports = [];\n    this.groups = {};\n    this.portLayoutNamespace = Port;\n    this.portLabelLayoutNamespace = PortLabel;\n\n    this._init(clonedData);\n};\n\nPortData.prototype = {\n\n    getPorts: function() {\n        return this.ports;\n    },\n\n    getGroup: function(name) {\n        return this.groups[name] || {};\n    },\n\n    getPortsByGroup: function(groupName) {\n\n        return this.ports.filter(function(port) {\n            return port.group === groupName;\n        });\n    },\n\n    getGroupPortsMetrics: function(groupName, elBBox) {\n\n        var group = this.getGroup(groupName);\n        var ports = this.getPortsByGroup(groupName);\n\n        var groupPosition = group.position || {};\n        var groupPositionName = groupPosition.name;\n        var namespace = this.portLayoutNamespace;\n        if (!namespace[groupPositionName]) {\n            groupPositionName = 'left';\n        }\n\n        var groupArgs = groupPosition.args || {};\n        var portsArgs = ports.map(function(port) {\n            return port && port.position && port.position.args;\n        });\n        var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);\n\n        var accumulator = {\n            ports: ports,\n            result: []\n        };\n\n        util.toArray(groupPortTransformations).reduce(function(res, portTransformation, index) {\n            var port = res.ports[index];\n            res.result.push({\n                portId: port.id,\n                portTransformation: portTransformation,\n                labelTransformation: this._getPortLabelLayout(port, Point(portTransformation), elBBox),\n                portAttrs: port.attrs,\n                portSize: port.size,\n                labelSize: port.label.size\n            });\n            return res;\n        }.bind(this), accumulator);\n\n        return accumulator.result;\n    },\n\n    _getPortLabelLayout: function(port, portPosition, elBBox) {\n\n        var namespace = this.portLabelLayoutNamespace;\n        var labelPosition = port.label.position.name || 'left';\n\n        if (namespace[labelPosition]) {\n            return namespace[labelPosition](portPosition, elBBox, port.label.position.args);\n        }\n\n        return null;\n    },\n\n    _init: function(data) {\n\n        // prepare groups\n        if (util.isObject(data.groups)) {\n            var groups = Object.keys(data.groups);\n            for (var i = 0, n = groups.length; i < n; i++) {\n                var key = groups[i];\n                this.groups[key] = this._evaluateGroup(data.groups[key]);\n            }\n        }\n\n        // prepare ports\n        var ports = util.toArray(data.items);\n        for (var j = 0, m = ports.length; j < m; j++) {\n            this.ports.push(this._evaluatePort(ports[j]));\n        }\n    },\n\n    _evaluateGroup: function(group) {\n\n        return util.merge(group, {\n            position: this._getPosition(group.position, true),\n            label: this._getLabel(group, true)\n        });\n    },\n\n    _evaluatePort: function(port) {\n\n        var evaluated = util.assign({}, port);\n\n        var group = this.getGroup(port.group);\n\n        evaluated.markup = evaluated.markup || group.markup;\n        evaluated.attrs = util.merge({}, group.attrs, evaluated.attrs);\n        evaluated.position = this._createPositionNode(group, evaluated);\n        evaluated.label = util.merge({}, group.label, this._getLabel(evaluated));\n        evaluated.z = this._getZIndex(group, evaluated);\n        evaluated.size = util.assign({}, group.size, evaluated.size);\n\n        return evaluated;\n    },\n\n    _getZIndex: function(group, port) {\n\n        if (util.isNumber(port.z)) {\n            return port.z;\n        }\n        if (util.isNumber(group.z) || group.z === 'auto') {\n            return group.z;\n        }\n        return 'auto';\n    },\n\n    _createPositionNode: function(group, port) {\n\n        return util.merge({\n            name: 'left',\n            args: {}\n        }, group.position, { args: port.args });\n    },\n\n    _getPosition: function(position, setDefault) {\n\n        var args = {};\n        var positionName;\n\n        if (util.isFunction(position)) {\n            positionName = 'fn';\n            args.fn = position;\n        } else if (util.isString(position)) {\n            positionName = position;\n        } else if (position === undefined) {\n            positionName = setDefault ? 'left' : null;\n        } else if (Array.isArray(position)) {\n            positionName = 'absolute';\n            args.x = position[0];\n            args.y = position[1];\n        } else if (util.isObject(position)) {\n            positionName = position.name;\n            util.assign(args, position.args);\n        }\n\n        var result = { args: args };\n\n        if (positionName) {\n            result.name = positionName;\n        }\n        return result;\n    },\n\n    _getLabel: function(item, setDefaults) {\n\n        var label = item.label || {};\n\n        var ret = label;\n        ret.position = this._getPosition(label.position, setDefaults);\n\n        return ret;\n    }\n};\n\nexport const elementPortPrototype = {\n\n    _initializePorts: function() {\n\n        this._createPortData();\n        this.on('change:ports', function() {\n\n            this._processRemovedPort();\n            this._createPortData();\n        }, this);\n    },\n\n    /**\n     * remove links tied wiht just removed element\n     * @private\n     */\n    _processRemovedPort: function() {\n\n        var current = this.get('ports') || {};\n        var currentItemsMap = {};\n\n        util.toArray(current.items).forEach(function(item) {\n            currentItemsMap[item.id] = true;\n        });\n\n        var previous = this.previous('ports') || {};\n        var removed = {};\n\n        util.toArray(previous.items).forEach(function(item) {\n            if (!currentItemsMap[item.id]) {\n                removed[item.id] = true;\n            }\n        });\n\n        var graph = this.graph;\n        if (graph && !util.isEmpty(removed)) {\n\n            var inboundLinks = graph.getConnectedLinks(this, { inbound: true });\n            inboundLinks.forEach(function(link) {\n\n                if (removed[link.get('target').port]) link.remove();\n            });\n\n            var outboundLinks = graph.getConnectedLinks(this, { outbound: true });\n            outboundLinks.forEach(function(link) {\n\n                if (removed[link.get('source').port]) link.remove();\n            });\n        }\n    },\n\n    /**\n     * @returns {boolean}\n     */\n    hasPorts: function() {\n\n        var ports = this.prop('ports/items');\n        return Array.isArray(ports) && ports.length > 0;\n    },\n\n    /**\n     * @param {string} id\n     * @returns {boolean}\n     */\n    hasPort: function(id) {\n\n        return this.getPortIndex(id) !== -1;\n    },\n\n    /**\n     * @returns {Array<object>}\n     */\n    getPorts: function() {\n\n        return util.cloneDeep(this.prop('ports/items')) || [];\n    },\n\n    /**\n     * @returns {Array<object>}\n     */\n    getGroupPorts: function(groupName) {\n        const groupPorts = util.toArray(this.prop(['ports','items'])).filter(port => port.group === groupName);\n        return util.cloneDeep(groupPorts);\n    },\n\n    /**\n     * @param {string} id\n     * @returns {object}\n     */\n    getPort: function(id) {\n\n        return util.cloneDeep(util.toArray(this.prop('ports/items')).find(function(port) {\n            return port.id && port.id === id;\n        }));\n    },\n\n    /**\n     * @param {string} groupName\n     * @returns {Object<portId, {x: number, y: number, angle: number}>}\n     */\n    getPortsPositions: function(groupName) {\n\n        var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, Rect(this.size()));\n\n        return portsMetrics.reduce(function(positions, metrics) {\n            var transformation = metrics.portTransformation;\n            positions[metrics.portId] = {\n                x: transformation.x,\n                y: transformation.y,\n                angle: transformation.angle\n            };\n            return positions;\n        }, {});\n    },\n\n    /**\n     * @param {string|Port} port port id or port\n     * @returns {number} port index\n     */\n    getPortIndex: function(port) {\n\n        var id = util.isObject(port) ? port.id : port;\n\n        if (!this._isValidPortId(id)) {\n            return -1;\n        }\n\n        return util.toArray(this.prop('ports/items')).findIndex(function(item) {\n            return item.id === id;\n        });\n    },\n\n    /**\n     * @param {object} port\n     * @param {object} [opt]\n     * @returns {joint.dia.Element}\n     */\n    addPort: function(port, opt) {\n\n        if (!util.isObject(port) || Array.isArray(port)) {\n            throw new Error('Element: addPort requires an object.');\n        }\n\n        var ports = util.assign([], this.prop('ports/items'));\n        ports.push(port);\n        this.prop('ports/items', ports, opt);\n\n        return this;\n    },\n\n    /**\n     * @param {string|Port|number} before\n     * @param {object} port\n     * @param {object} [opt]\n     * @returns {joint.dia.Element}\n     */\n    insertPort: function(before, port, opt) {\n        const index = (typeof before === 'number') ? before : this.getPortIndex(before);\n\n        if (!util.isObject(port) || Array.isArray(port)) {\n            throw new Error('dia.Element: insertPort requires an object.');\n        }\n\n        const ports = util.assign([], this.prop('ports/items'));\n        ports.splice(index, 0, port);\n        this.prop('ports/items', ports, opt);\n\n        return this;\n    },\n\n    /**\n     * @param {string} portId\n     * @param {string|object=} path\n     * @param {*=} value\n     * @param {object=} opt\n     * @returns {joint.dia.Element}\n     */\n    portProp: function(portId, path, value, opt) {\n\n        var index = this.getPortIndex(portId);\n\n        if (index === -1) {\n            throw new Error('Element: unable to find port with id ' + portId);\n        }\n\n        var args = Array.prototype.slice.call(arguments, 1);\n        if (Array.isArray(path)) {\n            args[0] = ['ports', 'items', index].concat(path);\n        } else if (util.isString(path)) {\n\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = ['ports/items/', index, '/', path].join('');\n\n        } else {\n\n            args = ['ports/items/' + index];\n            if (util.isPlainObject(path)) {\n                args.push(path);\n                args.push(value);\n            }\n        }\n\n        return this.prop.apply(this, args);\n    },\n\n    _validatePorts: function() {\n\n        var portsAttr = this.get('ports') || {};\n\n        var errorMessages = [];\n        portsAttr = portsAttr || {};\n        var ports = util.toArray(portsAttr.items);\n\n        ports.forEach(function(p) {\n\n            if (typeof p !== 'object') {\n                errorMessages.push('Element: invalid port ', p);\n            }\n\n            if (!this._isValidPortId(p.id)) {\n                p.id = this.generatePortId();\n            }\n        }, this);\n\n        if (util.uniq(ports, 'id').length !== ports.length) {\n            errorMessages.push('Element: found id duplicities in ports.');\n        }\n\n        return errorMessages;\n    },\n\n    generatePortId: function() {\n        return this.generateId();\n    },\n\n    /**\n     * @param {string} id port id\n     * @returns {boolean}\n     * @private\n     */\n    _isValidPortId: function(id) {\n\n        return id !== null && id !== undefined && !util.isObject(id);\n    },\n\n    addPorts: function(ports, opt) {\n\n        if (ports.length) {\n            this.prop('ports/items', util.assign([], this.prop('ports/items')).concat(ports), opt);\n        }\n\n        return this;\n    },\n\n    removePort: function(port, opt) {\n        const options = opt || {};\n        const index = this.getPortIndex(port);\n        if (index !== -1) {\n            const ports = util.assign([], this.prop(['ports', 'items']));\n            ports.splice(index, 1);\n            options.rewrite = true;\n            this.startBatch('port-remove');\n            this.prop(['ports', 'items'], ports, options);\n            this.stopBatch('port-remove');\n        }\n        return this;\n    },\n\n    removePorts: function(portsForRemoval, opt) {\n        let options, newPorts;\n        if (Array.isArray(portsForRemoval)) {\n            options = opt || {};\n            if (portsForRemoval.length === 0) return this.this;\n            const currentPorts = util.assign([], this.prop(['ports', 'items']));\n            newPorts = currentPorts.filter(function(cp) {\n                return !portsForRemoval.some(function(rp) {\n                    const rpId = util.isObject(rp) ? rp.id : rp;\n                    return cp.id === rpId;\n                });\n            });\n        } else {\n            options = portsForRemoval || {};\n            newPorts = [];\n        }\n        this.startBatch('port-remove');\n        options.rewrite = true;\n        this.prop(['ports', 'items'], newPorts, options);\n        this.stopBatch('port-remove');\n        return this;\n    },\n\n    /**\n     * @private\n     */\n    _createPortData: function() {\n\n        var err = this._validatePorts();\n\n        if (err.length > 0) {\n            this.set('ports', this.previous('ports'));\n            throw new Error(err.join(' '));\n        }\n\n        var prevPortData;\n\n        if (this._portSettingsData) {\n\n            prevPortData = this._portSettingsData.getPorts();\n        }\n\n        this._portSettingsData = new PortData(this.get('ports'));\n\n        var curPortData = this._portSettingsData.getPorts();\n\n        if (prevPortData) {\n\n            var added = curPortData.filter(function(item) {\n                if (!prevPortData.find(function(prevPort) {\n                    return prevPort.id === item.id;\n                })) {\n                    return item;\n                }\n            });\n\n            var removed = prevPortData.filter(function(item) {\n                if (!curPortData.find(function(curPort) {\n                    return curPort.id === item.id;\n                })) {\n                    return item;\n                }\n            });\n\n            if (removed.length > 0) {\n                this.trigger('ports:remove', this, removed);\n            }\n\n            if (added.length > 0) {\n                this.trigger('ports:add', this, added);\n            }\n        }\n    }\n};\n\nexport const elementViewPortPrototype = {\n\n    portContainerMarkup: 'g',\n    portMarkup: [{\n        tagName: 'circle',\n        selector: 'circle',\n        attributes: {\n            'r': 10,\n            'fill': '#FFFFFF',\n            'stroke': '#000000'\n        }\n    }],\n    portLabelMarkup: [{\n        tagName: 'text',\n        selector: 'text',\n        attributes: {\n            'fill': '#000000'\n        }\n    }],\n    /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */\n    _portElementsCache: null,\n\n    /**\n     * @private\n     */\n    _initializePorts: function() {\n        this._cleanPortsCache();\n    },\n\n    /**\n     * @typedef {Object} Port\n     *\n     * @property {string} id\n     * @property {Object} position\n     * @property {Object} label\n     * @property {Object} attrs\n     * @property {string} markup\n     * @property {string} group\n     */\n\n    /**\n     * @private\n     */\n    _refreshPorts: function() {\n\n        this._removePorts();\n        this._cleanPortsCache();\n        this._renderPorts();\n    },\n\n    _cleanPortsCache: function() {\n        this._portElementsCache = {};\n    },\n\n    /**\n     * @private\n     */\n    _renderPorts: function() {\n\n        // references to rendered elements without z-index\n        var elementReferences = [];\n        var elem = this._getContainerElement();\n\n        for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {\n            elementReferences.push(elem.node.childNodes[i]);\n        }\n\n        var portsGropsByZ = util.groupBy(this.model._portSettingsData.getPorts(), 'z');\n        var withoutZKey = 'auto';\n\n        // render non-z first\n        util.toArray(portsGropsByZ[withoutZKey]).forEach(function(port) {\n            var portElement = this._getPortElement(port);\n            elem.append(portElement);\n            elementReferences.push(portElement);\n        }, this);\n\n        var groupNames = Object.keys(portsGropsByZ);\n        for (var k = 0; k < groupNames.length; k++) {\n            var groupName = groupNames[k];\n            if (groupName !== withoutZKey) {\n                var z = parseInt(groupName, 10);\n                this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n            }\n        }\n\n        this._updatePorts();\n    },\n\n    /**\n     * @returns {V}\n     * @private\n     */\n    _getContainerElement: function() {\n\n        return this.rotatableNode || this.vel;\n    },\n\n    /**\n     * @param {Array<Port>}ports\n     * @param {number} z\n     * @param refs\n     * @private\n     */\n    _appendPorts: function(ports, z, refs) {\n\n        var containerElement = this._getContainerElement();\n        var portElements = util.toArray(ports).map(this._getPortElement, this);\n\n        if (refs[z] || z < 0) {\n            V(refs[Math.max(z, 0)]).before(portElements);\n        } else {\n            containerElement.append(portElements);\n        }\n    },\n\n    /**\n     * Try to get element from cache,\n     * @param port\n     * @returns {*}\n     * @private\n     */\n    _getPortElement: function(port) {\n\n        if (this._portElementsCache[port.id]) {\n            return this._portElementsCache[port.id].portElement;\n        }\n        return this._createPortElement(port);\n    },\n\n    findPortNode: function(portId, selector) {\n        const portCache = this._portElementsCache[portId];\n        if (!portCache) return null;\n        if (!selector) return portCache.portContentElement.node;\n        const portRoot = portCache.portElement.node;\n        const portSelectors = portCache.portSelectors;\n        const [node = null] = this.findBySelector(selector, portRoot, portSelectors);\n        return node;\n    },\n\n    /**\n     * @private\n     */\n    _updatePorts: function() {\n\n        // layout ports without group\n        this._updatePortGroup(undefined);\n        // layout ports with explicit group\n        var groupsNames = Object.keys(this.model._portSettingsData.groups);\n        groupsNames.forEach(this._updatePortGroup, this);\n    },\n\n    /**\n     * @private\n     */\n    _removePorts: function() {\n        util.invoke(this._portElementsCache, 'portElement.remove');\n    },\n\n    /**\n     * @param {Port} port\n     * @returns {V}\n     * @private\n     */\n    _createPortElement: function(port) {\n\n        let portElement;\n        let labelElement;\n        let labelSelectors;\n        let portSelectors;\n\n        var portContainerElement = V(this.portContainerMarkup).addClass('joint-port');\n\n        var portMarkup = this._getPortMarkup(port);\n        if (Array.isArray(portMarkup)) {\n            var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n            var portFragment = portDoc.fragment;\n            if (portFragment.childNodes.length > 1) {\n                portElement = V('g').append(portFragment);\n            } else {\n                portElement = V(portFragment.firstChild);\n            }\n            portSelectors = portDoc.selectors;\n        } else {\n            portElement = V(portMarkup);\n            if (Array.isArray(portElement)) {\n                portElement = V('g').append(portElement);\n            }\n        }\n\n        if (!portElement) {\n            throw new Error('ElementView: Invalid port markup.');\n        }\n\n        portElement.attr({\n            'port': port.id,\n            'port-group': port.group\n        });\n\n        const labelMarkupDef = this._getPortLabelMarkup(port.label);\n        if (Array.isArray(labelMarkupDef)) {\n            // JSON Markup\n            const { fragment, selectors } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);\n            const childCount = fragment.childNodes.length;\n            if (childCount > 0) {\n                labelSelectors = selectors;\n                labelElement = (childCount === 1) ? V(fragment.firstChild) : V('g').append(fragment);\n            }\n        } else {\n            // String Markup\n            labelElement = V(labelMarkupDef);\n            if (Array.isArray(labelElement)) {\n                labelElement = V('g').append(labelElement);\n            }\n        }\n\n        var portContainerSelectors;\n        if (portSelectors && labelSelectors) {\n            for (var key in labelSelectors) {\n                if (portSelectors[key] && key !== this.selector) throw new Error('ElementView: selectors within port must be unique.');\n            }\n            portContainerSelectors = util.assign({}, portSelectors, labelSelectors);\n        } else {\n            portContainerSelectors = portSelectors || labelSelectors || {};\n        }\n\n        // The `portRootSelector` points to the root SVGNode of the port.\n        // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.\n        // Or the single SVGNode of the port.\n        const portRootSelector = 'portRoot';\n        // The `labelRootSelector` points to the root SVGNode of the label.\n        const labelRootSelector = 'labelRoot';\n        // The `labelTextSelector` points to all text SVGNodes of the label.\n        const labelTextSelector = 'labelText';\n\n        if (!(portRootSelector in portContainerSelectors)) {\n            portContainerSelectors[portRootSelector] = portElement.node;\n        }\n\n        if (labelElement) {\n            const labelNode = labelElement.node;\n            if (!(labelRootSelector in portContainerSelectors)) {\n                portContainerSelectors[labelRootSelector] = labelNode;\n            }\n            if (!(labelTextSelector in portContainerSelectors)) {\n                // If the label is a <text> element, we can use it directly.\n                // Otherwise, we need to find the <text> element within the label.\n                const labelTextNode = (labelElement.tagName() === 'TEXT')\n                    ? labelNode\n                    : Array.from(labelNode.querySelectorAll('text'));\n                portContainerSelectors[labelTextSelector] = labelTextNode;\n                if (!labelSelectors) labelSelectors = {};\n                labelSelectors[labelTextSelector] = labelTextNode;\n            }\n        }\n\n        portContainerElement.append(portElement.addClass('joint-port-body'));\n        if (labelElement) {\n            portContainerElement.append(labelElement.addClass('joint-port-label'));\n        }\n\n        this._portElementsCache[port.id] = {\n            portElement: portContainerElement,\n            portLabelElement: labelElement,\n            portSelectors: portContainerSelectors,\n            portLabelSelectors: labelSelectors,\n            portContentElement: portElement,\n            portContentSelectors: portSelectors\n        };\n\n        return portContainerElement;\n    },\n\n    /**\n     * @param {string=} groupName\n     * @private\n     */\n    _updatePortGroup: function(groupName) {\n\n        var elementBBox = Rect(this.model.size());\n        var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);\n\n        for (var i = 0, n = portsMetrics.length; i < n; i++) {\n            var metrics = portsMetrics[i];\n            var portId = metrics.portId;\n            var cached = this._portElementsCache[portId] || {};\n            var portTransformation = metrics.portTransformation;\n            var labelTransformation = metrics.labelTransformation;\n            if (labelTransformation && cached.portLabelElement) {\n                this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n                    rootBBox: new Rect(metrics.labelSize),\n                    selectors: cached.portLabelSelectors\n                });\n                this.applyPortTransform(cached.portLabelElement, labelTransformation, (-portTransformation.angle || 0));\n            }\n            this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n                rootBBox: new Rect(metrics.portSize),\n                selectors: cached.portSelectors\n            });\n            this.applyPortTransform(cached.portElement, portTransformation);\n        }\n    },\n\n    /**\n     * @param {Vectorizer} element\n     * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n     * @param {number=} initialAngle\n     * @constructor\n     */\n    applyPortTransform: function(element, transformData, initialAngle) {\n\n        var matrix = V.createSVGMatrix()\n            .rotate(initialAngle || 0)\n            .translate(transformData.x || 0, transformData.y || 0)\n            .rotate(transformData.angle || 0);\n\n        element.transform(matrix, { absolute: true });\n    },\n\n    /**\n     * @param {Port} port\n     * @returns {string}\n     * @private\n     */\n    _getPortMarkup: function(port) {\n\n        return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;\n    },\n\n    /**\n     * @param {Object} label\n     * @returns {string}\n     * @private\n     */\n    _getPortLabelMarkup: function(label) {\n\n        return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;\n    }\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}