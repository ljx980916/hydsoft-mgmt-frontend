{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.slack = exports.longestPathWithLayer = exports.longestPath = void 0;\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nvar longestPath = function (g) {\n  var _a;\n  var visited = {};\n  var dfs = function (v) {\n    var _a;\n    var label = g.node(v);\n    if (!label) return 0;\n    if (visited[v]) {\n      return label.rank;\n    }\n    visited[v] = true;\n    var rank;\n    (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (edgeObj) {\n      var wRank = dfs(edgeObj.w);\n      var minLen = g.edge(edgeObj).minlen;\n      var r = wRank - minLen;\n      if (r) {\n        if (rank === undefined || r < rank) {\n          rank = r;\n        }\n      }\n    });\n    if (!rank) {\n      rank = 0;\n    }\n    label.rank = rank;\n    return rank;\n  };\n  (_a = g.sources()) === null || _a === void 0 ? void 0 : _a.forEach(function (source) {\n    return dfs(source);\n  });\n};\nexports.longestPath = longestPath;\nvar longestPathWithLayer = function (g) {\n  var _a;\n  // 用longest path，找出最深的点\n  var visited = {};\n  var minRank;\n  var dfs = function (v) {\n    var _a;\n    var label = g.node(v);\n    if (!label) return 0;\n    if (visited[v]) {\n      return label.rank;\n    }\n    visited[v] = true;\n    var rank;\n    (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (edgeObj) {\n      var wRank = dfs(edgeObj.w);\n      var minLen = g.edge(edgeObj).minlen;\n      var r = wRank - minLen;\n      if (r) {\n        if (rank === undefined || r < rank) {\n          rank = r;\n        }\n      }\n    });\n    if (!rank) {\n      rank = 0;\n    }\n    if (minRank === undefined || rank < minRank) {\n      minRank = rank;\n    }\n    label.rank = rank;\n    return rank;\n  };\n  (_a = g.sources()) === null || _a === void 0 ? void 0 : _a.forEach(function (source) {\n    if (g.node(source)) dfs(source);\n  });\n  if (minRank === undefined) {\n    minRank = 0;\n  }\n  // minRank += 1; // NOTE: 最小的层级是dummy root，+1\n  // forward一遍，赋值层级\n  var forwardVisited = {};\n  var dfsForward = function (v, nextRank) {\n    var _a;\n    var label = g.node(v);\n    var currRank = !isNaN(label.layer) ? label.layer : nextRank;\n    // 没有指定，取最大值\n    if (label.rank === undefined || label.rank < currRank) {\n      label.rank = currRank;\n    }\n    if (forwardVisited[v]) return;\n    forwardVisited[v] = true;\n    // DFS遍历子节点\n    (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n      dfsForward(e.w, currRank + g.edge(e).minlen);\n    });\n  };\n  // 指定层级的，更新下游\n  g.nodes().forEach(function (n) {\n    var label = g.node(n);\n    if (!label) return;\n    if (!isNaN(label.layer)) {\n      dfsForward(n, label.layer); // 默认的dummy root所在层的rank是-1\n    } else {\n      label.rank -= minRank;\n    }\n  });\n};\nexports.longestPathWithLayer = longestPathWithLayer;\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nvar slack = function (g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\n};\nexports.slack = slack;\nexports.default = {\n  longestPath: longestPath,\n  longestPathWithLayer: longestPathWithLayer,\n  slack: slack\n};","map":{"version":3,"mappings":"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","names":["longestPath","g","visited","dfs","v","label","node","rank","outEdges","forEach","edgeObj","wRank","w","minLen","edge","minlen","r","undefined","sources","source","exports","longestPathWithLayer","minRank","forwardVisited","dfsForward","nextRank","currRank","isNaN","layer","map","e","nodes","n","slack"],"sourceRoot":"","sources":["../../../../../src/layout/dagre/src/rank/util.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}