{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pageRankAsync = exports.minimumSpanningTreeAsync = exports.louvainAsync = exports.labelPropagationAsync = exports.getOutDegreeAsync = exports.getNeighborsAsync = exports.getInDegreeAsync = exports.getDegreeAsync = exports.getAdjMatrixAsync = exports.floydWarshallAsync = exports.findShortestPathAsync = exports.findAllPathAsync = exports.dijkstraAsync = exports.detectCycleAsync = exports.detectAllUndirectedCycleAsync = exports.detectAllDirectedCycleAsync = exports.detectAllCyclesAsync = exports.connectedComponentAsync = exports.GADDIAsync = void 0;\nvar _createWorker = _interopRequireDefault(require(\"./createWorker\"));\nvar _constant = require(\"./constant\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\nvar getAdjMatrixAsync = function getAdjMatrixAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getAdjMatrix).apply(void 0, [graphData, directed]);\n};\n/**\n * 图的连通分量\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\n\nexports.getAdjMatrixAsync = getAdjMatrixAsync;\nvar connectedComponentAsync = function connectedComponentAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.connectedComponent).apply(void 0, [graphData, directed]);\n};\n/**\n * 获取节点的度\n * @param graphData 图数据\n */\n\nexports.connectedComponentAsync = connectedComponentAsync;\nvar getDegreeAsync = function getDegreeAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getDegree)(graphData);\n};\n/**\n * 获取节点的入度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\n\nexports.getDegreeAsync = getDegreeAsync;\nvar getInDegreeAsync = function getInDegreeAsync(graphData, nodeId) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getInDegree)(graphData, nodeId);\n};\n/**\n * 获取节点的出度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\n\nexports.getInDegreeAsync = getInDegreeAsync;\nvar getOutDegreeAsync = function getOutDegreeAsync(graphData, nodeId) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getOutDegree)(graphData, nodeId);\n};\n/**\n * 检测图中的(有向) Cycle\n * @param graphData 图数据\n */\n\nexports.getOutDegreeAsync = getOutDegreeAsync;\nvar detectCycleAsync = function detectCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectCycle)(graphData);\n};\n/**\n * 检测图中的(无向) Cycle\n * @param graphData 图数据\n */\n\nexports.detectCycleAsync = detectCycleAsync;\nvar detectAllCyclesAsync = function detectAllCyclesAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllCycles)(graphData);\n};\n/**\n * 检测图中的所有(有向) Cycle\n * @param graphData 图数据\n */\n\nexports.detectAllCyclesAsync = detectAllCyclesAsync;\nvar detectAllDirectedCycleAsync = function detectAllDirectedCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllDirectedCycle)(graphData);\n};\n/**\n * 检测图中的所有(无向) Cycle\n * @param graphData 图数据\n */\n\nexports.detectAllDirectedCycleAsync = detectAllDirectedCycleAsync;\nvar detectAllUndirectedCycleAsync = function detectAllUndirectedCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllUndirectedCycle)(graphData);\n};\n/**\n * Dijkstra's algorithm, See {@link https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm}\n * @param graphData 图数据\n */\n\nexports.detectAllUndirectedCycleAsync = detectAllUndirectedCycleAsync;\nvar dijkstraAsync = function dijkstraAsync(graphData, source, directed, weightPropertyName) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.dijkstra).apply(void 0, [graphData, source, directed, weightPropertyName]);\n};\n/**\n * 查找两点之间的所有路径\n * @param graphData 图数据\n * @param start 路径起始点ID\n * @param end 路径终点ID\n * @param directed 是否为有向图\n */\n\nexports.dijkstraAsync = dijkstraAsync;\nvar findAllPathAsync = function findAllPathAsync(graphData, start, end, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.findAllPath).apply(void 0, [graphData, start, end, directed]);\n};\n/**\n * 查找两点之间的所有路径\n * @param graphData 图数据\n * @param start 路径起始点ID\n * @param end 路径终点ID\n * @param directed 是否为有向图\n * @param weightPropertyName 边权重的属名称，若数据中没有权重，则默认每条边权重为 1\n */\n\nexports.findAllPathAsync = findAllPathAsync;\nvar findShortestPathAsync = function findShortestPathAsync(graphData, start, end, directed, weightPropertyName) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.findShortestPath).apply(void 0, [graphData, start, end, directed, weightPropertyName]);\n};\n/**\n * Floyd–Warshall algorithm, See {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm}\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\n\nexports.findShortestPathAsync = findShortestPathAsync;\nvar floydWarshallAsync = function floydWarshallAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.floydWarshall).apply(void 0, [graphData, directed]);\n};\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\n\nexports.floydWarshallAsync = floydWarshallAsync;\nvar labelPropagationAsync = function labelPropagationAsync(graphData, directed, weightPropertyName, maxIteration) {\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  }\n  return (0, _createWorker.default)(_constant.ALGORITHM.labelPropagation)(graphData, directed, weightPropertyName, maxIteration);\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold\n */\n\nexports.labelPropagationAsync = labelPropagationAsync;\nvar louvainAsync = function louvainAsync(graphData, directed, weightPropertyName, threshold) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.louvain)(graphData, directed, weightPropertyName, threshold);\n};\n/**\n * 最小生成树，See {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\nexports.louvainAsync = louvainAsync;\nvar minimumSpanningTreeAsync = function minimumSpanningTreeAsync(graphData, weight, algo) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.minimumSpanningTree).apply(void 0, [graphData, weight, algo]);\n};\n/**\n * PageRank https://en.wikipedia.org/wiki/PageRank\n * refer: https://github.com/anvaka/ngraph.pagerank\n * @param graph\n * @param epsilon 判断是否收敛的精度值，默认 0.000001\n * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85\n */\n\nexports.minimumSpanningTreeAsync = minimumSpanningTreeAsync;\nvar pageRankAsync = function pageRankAsync(graphData, epsilon, linkProb) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.pageRank).apply(void 0, [graphData, epsilon, linkProb]);\n};\n/**\n * 获取指定节点的所有邻居\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n * @param type 邻居类型\n */\n\nexports.pageRankAsync = pageRankAsync;\nvar getNeighborsAsync = function getNeighborsAsync(nodeId, edges, type) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getNeighbors).apply(void 0, [nodeId, edges, type]);\n};\n/**\n * GADDI 图模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\n\nexports.getNeighborsAsync = getNeighborsAsync;\nvar GADDIAsync = function GADDIAsync(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\n  if (directed === void 0) {\n    directed = false;\n  }\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n  if (edgeLabelProp === void 0) {\n    edgeLabelProp = 'cluster';\n  }\n  return (0, _createWorker.default)(_constant.ALGORITHM.GADDI).apply(void 0, [graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp]);\n};\nexports.GADDIAsync = GADDIAsync;","map":{"version":3,"names":["Object","defineProperty","exports","value","pageRankAsync","minimumSpanningTreeAsync","louvainAsync","labelPropagationAsync","getOutDegreeAsync","getNeighborsAsync","getInDegreeAsync","getDegreeAsync","getAdjMatrixAsync","floydWarshallAsync","findShortestPathAsync","findAllPathAsync","dijkstraAsync","detectCycleAsync","detectAllUndirectedCycleAsync","detectAllDirectedCycleAsync","detectAllCyclesAsync","connectedComponentAsync","GADDIAsync","_createWorker","_interopRequireDefault","require","_constant","obj","__esModule","default","graphData","directed","ALGORITHM","getAdjMatrix","apply","connectedComponent","getDegree","nodeId","getInDegree","getOutDegree","detectCycle","detectAllCycles","detectAllDirectedCycle","detectAllUndirectedCycle","source","weightPropertyName","dijkstra","start","end","findAllPath","findShortestPath","floydWarshall","maxIteration","labelPropagation","threshold","louvain","weight","algo","minimumSpanningTree","epsilon","linkProb","pageRank","edges","type","getNeighbors","pattern","k","length","nodeLabelProp","edgeLabelProp","GADDI"],"sources":["/Users/lijiaxin/Documents/workspace/hydsoft-oms-frontend/node_modules/@antv/algorithm/lib/workers/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pageRankAsync = exports.minimumSpanningTreeAsync = exports.louvainAsync = exports.labelPropagationAsync = exports.getOutDegreeAsync = exports.getNeighborsAsync = exports.getInDegreeAsync = exports.getDegreeAsync = exports.getAdjMatrixAsync = exports.floydWarshallAsync = exports.findShortestPathAsync = exports.findAllPathAsync = exports.dijkstraAsync = exports.detectCycleAsync = exports.detectAllUndirectedCycleAsync = exports.detectAllDirectedCycleAsync = exports.detectAllCyclesAsync = exports.connectedComponentAsync = exports.GADDIAsync = void 0;\n\nvar _createWorker = _interopRequireDefault(require(\"./createWorker\"));\n\nvar _constant = require(\"./constant\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\nvar getAdjMatrixAsync = function getAdjMatrixAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getAdjMatrix).apply(void 0, [graphData, directed]);\n};\n/**\n * 图的连通分量\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\n\n\nexports.getAdjMatrixAsync = getAdjMatrixAsync;\n\nvar connectedComponentAsync = function connectedComponentAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.connectedComponent).apply(void 0, [graphData, directed]);\n};\n/**\n * 获取节点的度\n * @param graphData 图数据\n */\n\n\nexports.connectedComponentAsync = connectedComponentAsync;\n\nvar getDegreeAsync = function getDegreeAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getDegree)(graphData);\n};\n/**\n * 获取节点的入度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\n\n\nexports.getDegreeAsync = getDegreeAsync;\n\nvar getInDegreeAsync = function getInDegreeAsync(graphData, nodeId) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getInDegree)(graphData, nodeId);\n};\n/**\n * 获取节点的出度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\n\n\nexports.getInDegreeAsync = getInDegreeAsync;\n\nvar getOutDegreeAsync = function getOutDegreeAsync(graphData, nodeId) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getOutDegree)(graphData, nodeId);\n};\n/**\n * 检测图中的(有向) Cycle\n * @param graphData 图数据\n */\n\n\nexports.getOutDegreeAsync = getOutDegreeAsync;\n\nvar detectCycleAsync = function detectCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectCycle)(graphData);\n};\n/**\n * 检测图中的(无向) Cycle\n * @param graphData 图数据\n */\n\n\nexports.detectCycleAsync = detectCycleAsync;\n\nvar detectAllCyclesAsync = function detectAllCyclesAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllCycles)(graphData);\n};\n/**\n * 检测图中的所有(有向) Cycle\n * @param graphData 图数据\n */\n\n\nexports.detectAllCyclesAsync = detectAllCyclesAsync;\n\nvar detectAllDirectedCycleAsync = function detectAllDirectedCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllDirectedCycle)(graphData);\n};\n/**\n * 检测图中的所有(无向) Cycle\n * @param graphData 图数据\n */\n\n\nexports.detectAllDirectedCycleAsync = detectAllDirectedCycleAsync;\n\nvar detectAllUndirectedCycleAsync = function detectAllUndirectedCycleAsync(graphData) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.detectAllUndirectedCycle)(graphData);\n};\n/**\n * Dijkstra's algorithm, See {@link https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm}\n * @param graphData 图数据\n */\n\n\nexports.detectAllUndirectedCycleAsync = detectAllUndirectedCycleAsync;\n\nvar dijkstraAsync = function dijkstraAsync(graphData, source, directed, weightPropertyName) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.dijkstra).apply(void 0, [graphData, source, directed, weightPropertyName]);\n};\n/**\n * 查找两点之间的所有路径\n * @param graphData 图数据\n * @param start 路径起始点ID\n * @param end 路径终点ID\n * @param directed 是否为有向图\n */\n\n\nexports.dijkstraAsync = dijkstraAsync;\n\nvar findAllPathAsync = function findAllPathAsync(graphData, start, end, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.findAllPath).apply(void 0, [graphData, start, end, directed]);\n};\n/**\n * 查找两点之间的所有路径\n * @param graphData 图数据\n * @param start 路径起始点ID\n * @param end 路径终点ID\n * @param directed 是否为有向图\n * @param weightPropertyName 边权重的属名称，若数据中没有权重，则默认每条边权重为 1\n */\n\n\nexports.findAllPathAsync = findAllPathAsync;\n\nvar findShortestPathAsync = function findShortestPathAsync(graphData, start, end, directed, weightPropertyName) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.findShortestPath).apply(void 0, [graphData, start, end, directed, weightPropertyName]);\n};\n/**\n * Floyd–Warshall algorithm, See {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm}\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\n\n\nexports.findShortestPathAsync = findShortestPathAsync;\n\nvar floydWarshallAsync = function floydWarshallAsync(graphData, directed) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.floydWarshall).apply(void 0, [graphData, directed]);\n};\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\n\n\nexports.floydWarshallAsync = floydWarshallAsync;\n\nvar labelPropagationAsync = function labelPropagationAsync(graphData, directed, weightPropertyName, maxIteration) {\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  }\n\n  return (0, _createWorker.default)(_constant.ALGORITHM.labelPropagation)(graphData, directed, weightPropertyName, maxIteration);\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold\n */\n\n\nexports.labelPropagationAsync = labelPropagationAsync;\n\nvar louvainAsync = function louvainAsync(graphData, directed, weightPropertyName, threshold) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.louvain)(graphData, directed, weightPropertyName, threshold);\n};\n/**\n * 最小生成树，See {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\n\nexports.louvainAsync = louvainAsync;\n\nvar minimumSpanningTreeAsync = function minimumSpanningTreeAsync(graphData, weight, algo) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.minimumSpanningTree).apply(void 0, [graphData, weight, algo]);\n};\n/**\n * PageRank https://en.wikipedia.org/wiki/PageRank\n * refer: https://github.com/anvaka/ngraph.pagerank\n * @param graph\n * @param epsilon 判断是否收敛的精度值，默认 0.000001\n * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85\n */\n\n\nexports.minimumSpanningTreeAsync = minimumSpanningTreeAsync;\n\nvar pageRankAsync = function pageRankAsync(graphData, epsilon, linkProb) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.pageRank).apply(void 0, [graphData, epsilon, linkProb]);\n};\n/**\n * 获取指定节点的所有邻居\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n * @param type 邻居类型\n */\n\n\nexports.pageRankAsync = pageRankAsync;\n\nvar getNeighborsAsync = function getNeighborsAsync(nodeId, edges, type) {\n  return (0, _createWorker.default)(_constant.ALGORITHM.getNeighbors).apply(void 0, [nodeId, edges, type]);\n};\n/**\n * GADDI 图模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\n\n\nexports.getNeighborsAsync = getNeighborsAsync;\n\nvar GADDIAsync = function GADDIAsync(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (edgeLabelProp === void 0) {\n    edgeLabelProp = 'cluster';\n  }\n\n  return (0, _createWorker.default)(_constant.ALGORITHM.GADDI).apply(void 0, [graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp]);\n};\n\nexports.GADDIAsync = GADDIAsync;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}